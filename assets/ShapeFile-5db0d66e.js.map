{"version":3,"file":"ShapeFile-5db0d66e.js","sources":["../../node_modules/truncate-utf8-bytes/lib/truncate.js","../../node_modules/utf8-byte-length/browser.js","../../node_modules/truncate-utf8-bytes/browser.js","../../node_modules/sanitize-filename/index.js","../../src/plugins/shape-file/GeojsonLayer.tsx","../../src/plugins/shape-file/ShapeFile.vue"],"sourcesContent":["'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function truncate(getLength, string, byteLength) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var curByteLength = 0;\n  var codePoint;\n  var segment;\n\n  for (var i = 0; i < charLength; i += 1) {\n    codePoint = string.charCodeAt(i);\n    segment = string[i];\n\n    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {\n      i += 1;\n      segment += string[i];\n    }\n\n    curByteLength += getLength(segment);\n\n    if (curByteLength === byteLength) {\n      return string.slice(0, i + 1);\n    }\n    else if (curByteLength > byteLength) {\n      return string.slice(0, i - segment.length + 1);\n    }\n  }\n\n  return string;\n};\n\n","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function getByteLength(string) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var byteLength = 0;\n  var codePoint = null;\n  var prevCodePoint = null;\n  for (var i = 0; i < charLength; i++) {\n    codePoint = string.charCodeAt(i);\n    // handle 4-byte non-BMP chars\n    // low surrogate\n    if (isLowSurrogate(codePoint)) {\n      // when parsing previous hi-surrogate, 3 is added to byteLength\n      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {\n        byteLength += 1;\n      }\n      else {\n        byteLength += 3;\n      }\n    }\n    else if (codePoint <= 0x7f ) {\n      byteLength += 1;\n    }\n    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {\n      byteLength += 2;\n    }\n    else if (codePoint >= 0x800 && codePoint <= 0xffff) {\n      byteLength += 3;\n    }\n    prevCodePoint = codePoint;\n  }\n\n  return byteLength;\n};\n","'use strict';\n\nvar truncate = require(\"./lib/truncate\");\nvar getLength = require(\"utf8-byte-length/browser\");\nmodule.exports = truncate.bind(null, getLength);\n","/*jshint node:true*/\n'use strict';\n\n/**\n * Replaces characters in strings that are illegal/unsafe for filenames.\n * Unsafe characters are either removed or replaced by a substitute set\n * in the optional `options` object.\n *\n * Illegal Characters on Various Operating Systems\n * / ? < > \\ : * | \"\n * https://kb.acronis.com/content/39790\n *\n * Unicode Control codes\n * C0 0x00-0x1f & C1 (0x80-0x9f)\n * http://en.wikipedia.org/wiki/C0_and_C1_control_codes\n *\n * Reserved filenames on Unix-based systems (\".\", \"..\")\n * Reserved filenames in Windows (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\",\n * \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n * \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", and\n * \"LPT9\") case-insesitively and with or without filename extensions.\n *\n * Capped at 255 characters in length.\n * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n *\n * @param  {String} input   Original filename\n * @param  {Object} options {replacement: String | Function }\n * @return {String}         Sanitized filename\n */\n\nvar truncate = require(\"truncate-utf8-bytes\");\n\nvar illegalRe = /[\\/\\?<>\\\\:\\*\\|\"]/g;\nvar controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g;\nvar reservedRe = /^\\.+$/;\nvar windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$/i;\nvar windowsTrailingRe = /[\\. ]+$/;\n\nfunction sanitize(input, replacement) {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  var sanitized = input\n    .replace(illegalRe, replacement)\n    .replace(controlRe, replacement)\n    .replace(reservedRe, replacement)\n    .replace(windowsReservedRe, replacement)\n    .replace(windowsTrailingRe, replacement);\n  return truncate(sanitized, 255);\n}\n\nmodule.exports = function (input, options) {\n  var replacement = (options && options.replacement) || '';\n  var output = sanitize(input, replacement);\n  if (replacement === '') {\n    return output;\n  }\n  return sanitize(output, '');\n};\n","import React, { useState, useMemo, useEffect, useRef } from 'react'\nimport DeckGL from '@deck.gl/react'\nimport { GeoJsonLayer } from '@deck.gl/layers'\nimport { DataFilterExtension } from '@deck.gl/extensions'\n\nimport { StaticMap, MapRef } from 'react-map-gl'\nimport { rgb } from 'd3-color'\n\nimport { DataTable, MAPBOX_TOKEN, REACT_VIEW_HANDLES } from '@/Globals'\n\nimport globalStore from '@/store'\nimport { OFFSET_DIRECTION } from '@/layers/LineOffsetLayer'\nimport GeojsonOffsetLayer from '@/layers/GeojsonOffsetLayer'\n\nimport screenshots from '@/js/screenshots'\n\nimport type { BackgroundLayer } from './ShapeFile.vue'\n\ninterface DeckObject {\n  index: number\n  target: number[]\n  data: any\n}\n\nexport default function Component({\n  viewId = 0,\n  fillColors = '#59a14f' as string | Uint8Array,\n  lineColors = '#4e79a7' as string | Uint8Array,\n  lineWidths = 0 as number | Float32Array,\n  fillHeights = 0 as number | Float32Array,\n  opacity = 1,\n  pointRadii = 4 as number | Float32Array,\n  screenshot = 0,\n  redraw = 0,\n  featureFilter = new Float32Array(0),\n  cbTooltip = {} as any,\n  bgLayers = {} as { [name: string]: BackgroundLayer },\n  handleClickEvent = {} as any,\n  highlightedLinkIndex = -1 as number,\n}) {\n  // const features = globalStore.state.globalCache[viewId] as any[]\n  const [features, setFeatures] = useState([] as any[])\n\n  const [viewState, setViewState] = useState(globalStore.state.viewState)\n  const [screenshotCount, setScreenshot] = useState(screenshot)\n\n  const _mapRef = useRef<MapRef>() as any\n  // release _mapRef on unmount to avoid memory leak\n  // TODO: WAIT! Releasing _mapRef breaks screenshot functionality.\n  // useEffect(() => {\n  //   if (screenshot <= screenshotCount) _mapRef.current = false\n  // })\n\n  // MAP VIEW -------------------------------------------------------------------------\n  REACT_VIEW_HANDLES[viewId] = () => {\n    setViewState(globalStore.state.viewState)\n  }\n\n  // console.log(featureFilter)\n\n  // Feature setter hack:\n  // Using the array itself causes an enormous memory leak. I am not sure why\n  // Vue/React/Deck.gl are not managing this array correctly. Surely the problem\n  // is in our code, not theirs? But I spent days trying to find it.\n  // Anyway, making this deep copy of the feature array seems to solve it.\n  REACT_VIEW_HANDLES[1000 + viewId] = (features: any[]) => {\n    const fullCopy = features.map(feature => {\n      const f = {\n        type: '' + feature.type,\n        geometry: JSON.parse(JSON.stringify(feature.geometry)),\n        properties: JSON.parse(JSON.stringify(feature?.properties || {})),\n      } as any\n      if ('id' in feature) f.id = '' + feature.id\n      return f\n    })\n    setFeatures(fullCopy)\n  }\n\n  // SCREENSHOT -----------------------------------------------------------------------\n  let isTakingScreenshot = screenshot > screenshotCount\n\n  // FILL COLORS ----------------------------------------------------------------------\n  let cbFillColor // can be callback OR a plain string in simple mode\n  if (typeof fillColors == 'string') {\n    // simple color mode\n    const color = rgb(fillColors)\n    cbFillColor = [color.r, color.g, color.b]\n  } else {\n    // array of colors\n    cbFillColor = (feature: any, o: DeckObject) => {\n      return [\n        fillColors[o.index * 3 + 0], // r\n        fillColors[o.index * 3 + 1], // g\n        fillColors[o.index * 3 + 2], // b\n        255, // no opacity, for now\n      ]\n    }\n  }\n\n  // LINE COLORS ----------------------------------------------------------------------\n  const isStroked = !!lineColors\n\n  let cbLineColor // can be callback OR a plain string in simple mode\n  if (typeof lineColors == 'string') {\n    // simple color mode\n    const color = rgb(lineColors)\n    cbLineColor = [color.r, color.g, color.b]\n    if (!isStroked) cbLineColor.push(0) // totally transparent\n  } else {\n    // array of colors\n    cbLineColor = (_: any, o: DeckObject) => {\n      if (features[o.index].properties._hide) return [0, 0, 0, 0]\n\n      return [\n        lineColors[o.index * 3 + 0], // r\n        lineColors[o.index * 3 + 1], // g\n        lineColors[o.index * 3 + 2], // b\n        255, // no opacity, for now\n      ]\n    }\n  }\n\n  // LINE WIDTHS ----------------------------------------------------------------------\n  let cbLineWidth // can be callback OR a plain string in simple mode\n  if (typeof lineWidths == 'number') {\n    // simple width mode\n    cbLineWidth = lineWidths\n  } else {\n    // array of widths\n    cbLineWidth = (_: any, o: DeckObject) => {\n      return lineWidths[o.index]\n    }\n  }\n\n  // CIRCLE RADIISESS ---------------------------------------------------------------\n  let cbPointRadius // can be callback OR a plain string in simple mode\n  if (typeof pointRadii == 'number') {\n    // simple radius mode\n    cbPointRadius = pointRadii\n  } else {\n    cbPointRadius = (_: any, o: DeckObject) => {\n      return pointRadii[o.index]\n    }\n  }\n\n  // FILL HEIGHTS -----------------------------------------------------------------\n  let cbFillHeight // can be callback OR a plain string in simple mode\n  if (typeof fillHeights == 'number') {\n    // simple mode\n    cbFillHeight = fillHeights\n  } else {\n    // array function\n    cbFillHeight = (_: any, o: DeckObject) => {\n      return fillHeights[o.index]\n    }\n  }\n\n  function handleViewState(view: any) {\n    if (!view.latitude) return\n    view.center = [view.longitude, view.latitude]\n    setViewState(view)\n    globalStore.commit('setMapCamera', view)\n  }\n\n  // CLICK  ---------------------------------------------------------------------\n  function handleClick(event: any) {\n    // console.log('click!')\n    // console.log(event)\n    // TODO: send click event to parent\n    if (handleClickEvent) handleClickEvent(event)\n  }\n\n  // TOOLTIP ------------------------------------------------------------------\n  function getTooltip({ object, index }: { object: any; index: number }) {\n    if (cbTooltip) cbTooltip(index, object)\n  }\n\n  // BACKGROUND-LAYERS --------------------------------------------------\n  const backgroundLayers = [] as any[]\n  const onTopLayers = [] as any[]\n\n  for (const name of Object.keys(bgLayers).reverse()) {\n    const layerDetails = bgLayers[name]\n\n    // if (layerDetails.visible == false) continue\n\n    const bgLayer = new GeoJsonLayer({\n      id: `background-layer-${name}`,\n      data: layerDetails.features,\n      getFillColor: (d: any) => d.properties.__fill__,\n      getLineColor: layerDetails.borderColor,\n      getLineWidth: layerDetails.borderWidth,\n      // getText: layerDetails.label ? (d: any) => d.properties[layerDetails.label] : null,\n      getText: (d: any) => d.properties.label,\n      getTextSize: 12,\n      getTextColor: [255, 255, 255, 255],\n      getTextBackgroundColor: [0, 0, 0, 255],\n      pointType: 'circle+text',\n      textFontWeight: 'bold',\n      lineWidthUnits: 'pixels',\n      autohighlight: false,\n      opacity: layerDetails.opacity,\n      pickable: false,\n      stroked: layerDetails.borderWidth ? true : false,\n      fp64: false,\n      parameters: { depthTest: false },\n      visible: layerDetails.visible,\n    })\n\n    if (layerDetails.onTop) {\n      onTopLayers.push(bgLayer)\n    } else {\n      backgroundLayers.push(bgLayer)\n    }\n  }\n\n  // ----------------------------------------------------------------------------\n  const mainLayer = new GeojsonOffsetLayer({\n    id: 'geoJsonOffsetLayer',\n    data: features,\n    // function callbacks: --------------\n    getLineWidth: cbLineWidth,\n    getLineColor: cbLineColor,\n    getFillColor: cbFillColor,\n    getPointRadius: cbPointRadius,\n    getElevation: cbFillHeight,\n    // settings: ------------------------\n    extruded: !!fillHeights,\n    highlightedObjectIndex: highlightedLinkIndex,\n    highlightColor: [255, 0, 224],\n    // lineJointRounded: true,\n    lineWidthUnits: 'pixels',\n    lineWidthScale: 1,\n    lineWidthMinPixels: typeof lineWidths === 'number' ? 0 : 1,\n    lineWidthMaxPixels: 50,\n    getOffset: OFFSET_DIRECTION.RIGHT,\n    opacity: fillHeights ? 1.0 : 0.8, // 3D must be opaque\n    pickable: true,\n    pointRadiusUnits: 'pixels',\n    pointRadiusMinPixels: 2,\n    // pointRadiusMaxPixels: 50,\n    stroked: isStroked,\n    useDevicePixels: isTakingScreenshot,\n    fp64: false,\n    // material: false,\n    updateTriggers: {\n      getFillColor: fillColors,\n      getLineColor: lineColors,\n      getLineWidth: lineWidths,\n      getPointRadius: pointRadii,\n      getElevation: fillHeights,\n      getFilterValue: featureFilter,\n    },\n    transitions: {\n      getFillColor: 300,\n      getLineColor: 300,\n      getLineWidth: 300,\n      getPointRadius: 300,\n    },\n    parameters: {\n      depthTest: !!fillHeights,\n      fp64: false,\n    },\n    glOptions: {\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n      preserveDrawingBuffer: true,\n      fp64: false,\n    },\n    // filter shapes\n    extensions: [new DataFilterExtension({ filterSize: 1 })],\n    filterRange: [0, 1], // set filter to -1 to filter element out\n    getFilterValue: (_: any, o: DeckObject) => {\n      return featureFilter[o.index]\n    },\n  }) as any\n\n  const deckInstance = (\n    /*\n    //@ts-ignore */\n    <DeckGL\n      layers={[...backgroundLayers, mainLayer, ...onTopLayers]}\n      viewState={viewState}\n      controller={true}\n      pickingRadius={4}\n      getTooltip={getTooltip}\n      onClick={handleClick}\n      onViewStateChange={(e: any) => handleViewState(e.viewState)}\n      getCursor={({ isDragging, isHovering }: any) =>\n        isDragging ? 'grabbing' : isHovering ? 'pointer' : 'grab'\n      }\n      onAfterRender={async () => {\n        if (screenshot > screenshotCount) {\n          await screenshots.savePNG(\n            deckInstance.props.layers[0],\n            _mapRef?.current?.getMap()._canvas\n          )\n          setScreenshot(screenshot) // update scrnshot count so we don't take 1000 screenshots by mistake :-/\n        }\n      }}\n    >\n      {\n        /*\n        // @ts-ignore */\n        <StaticMap mapStyle={globalStore.getters.mapStyle} mapboxApiAccessToken={MAPBOX_TOKEN} />\n      }\n    </DeckGL>\n  )\n\n  return deckInstance\n}\n","<template lang=\"pug\">\n.shapefile-viewer(:class=\"{'hide-thumbnail': !thumbnail}\" :style='{\"background\": urlThumbnail}' oncontextmenu=\"return false\")\n\n  modal-id-column-picker(v-if=\"showJoiner\" v-bind=\"datasetJoinSelector\" @join=\"cbDatasetJoined\")\n\n  .main-layout(\n      @mousemove.stop=\"dividerDragging\"\n  )\n\n    .dragger(v-show=\"showLegend\"\n      @mousedown=\"dividerDragStart\"\n      @mouseup=\"dividerDragEnd\"\n      @mousemove.stop=\"dividerDragging\"\n    )\n\n    .new-rightside-info-panel(v-show=\"showLegend\" :style=\"{width: `${legendSectionWidth}px`}\")\n\n      .legend-panel\n        p(v-if=\"!legendStore.state?.sections?.length\" style=\"font-size: 1.1rem\"): b INFO PANEL\n        legend-box(:legendStore=\"legendStore\")\n\n      .tooltip-html(v-if=\"tooltipHtml && !statusText\" v-html=\"tooltipHtml\")\n        .bglayer-section\n          b-checkbox.simple-checkbox(v-for=\"layer in Object.keys(bgLayers)\" :key=\"layer\"\n            @input=\"updateBgLayers\" v-model=\"bgLayers[layer].visible\"\n          ) {{  layer }}\n\n    .area-map(v-if=\"!thumbnail\" :id=\"`container-${layerId}`\")\n      .status-bar(v-show=\"false && statusText\") {{ statusText }}\n\n      //- drawing-tool.draw-tool(v-if=\"isLoaded && !thumbnail\")\n\n      geojson-layer.map-layers(v-if=\"!needsInitialMapExtent\"\n        :viewId=\"layerId\"\n        :fillColors=\"dataFillColors\"\n        :lineColors=\"dataLineColors\"\n        :lineWidths=\"dataLineWidths\"\n        :fillHeights=\"dataFillHeights\"\n        :screenshot=\"triggerScreenshot\"\n        :featureFilter=\"boundaryFilters\"\n        :opacity=\"sliderOpacity\"\n        :pointRadii=\"dataPointRadii\"\n        :cbTooltip=\"cbTooltip\"\n        :bgLayers=\"bgLayers\"\n        :handleClickEvent=\"handleClickEvent\"\n        :highlightedLinkIndex=\"highlightedLinkIndex\"\n        :redraw=\"redraw\"\n      )\n\n      //- :features=\"useCircles ? centroids: boundaries\"\n      //- background-map-on-top(v-if=\"isLoaded\")\n\n      viz-configurator(v-if=\"isLoaded\"\n        :embedded=\"isEmbedded\"\n        :sections=\"configuratorSections\"\n        :fileSystem=\"fileSystem\"\n        :subfolder=\"subfolder\"\n        :yamlConfig=\"generatedExportFilename\"\n        :vizDetails=\"vizDetails\"\n        :datasets=\"datasets\"\n        :legendStore=\"legendStore\"\n        :filterDefinitions=\"currentUIFilterDefinitions\"\n        @update=\"changeConfiguration\"\n        @screenshot=\"takeScreenshot\"\n        @toggleLegend=\"showLegend=!showLegend\"\n      )\n\n      .details-panel\n\n\n      zoom-buttons(v-if=\"isLoaded && !thumbnail\")\n\n      .config-bar(v-if=\"!thumbnail && !isEmbedded && isLoaded && Object.keys(filters).length\"\n        :class=\"{'is-standalone': !configFromDashboard, 'is-disabled': !isLoaded}\")\n\n      //- Filter pickers\n      .filter(v-for=\"filter in Object.keys(filters)\")\n        p {{ filter }}\n        b-dropdown(\n          v-model=\"filters[filter].active\"\n          :scrollable=\"filters[filter].active.length > 10\"\n          max-height=\"250\"\n          multiple\n          @change=\"handleUserSelectedNewFilters(filter)\"\n          aria-role=\"list\" :mobile-modal=\"false\" :close-on-click=\"true\"\n        )\n          template(#trigger=\"{ active }\")\n            b-button.is-primary(\n              :type=\"filters[filter].active.length ? '' : 'is-outlined'\"\n              :label=\"filterLabel(filter)\"\n            )\n\n          b-dropdown-item(v-for=\"option in filters[filter].options\"\n            :key=\"option\" :value=\"option\" aria-role=\"listitem\") {{ option }}\n\n      //- .map-type-buttons(v-if=\"isAreaMode\")\n      //-   img.img-button(@click=\"showCircles(false)\" src=\"../../assets/btn-polygons.jpg\" title=\"Shapes\")\n      //-   img.img-button(@click=\"showCircles(true)\" src=\"../../assets/btn-circles.jpg\" title=\"Circles\")\n\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\nimport { group, zip, sum } from 'd3-array'\n\nimport * as shapefile from 'shapefile'\nimport * as turf from '@turf/turf'\nimport avro from '@/js/avro'\nimport readBlob from 'read-blob'\nimport reproject from 'reproject'\nimport Sanitize from 'sanitize-filename'\nimport YAML from 'yaml'\n\nimport * as d3ScaleChromatic from 'd3-scale-chromatic'\nimport * as d3Interpolate from 'd3-interpolate'\nimport { scaleSequential } from 'd3-scale'\nimport { rgb } from 'd3-color'\n\nimport globalStore from '@/store'\nimport {\n  DataTable,\n  DataTableColumn,\n  DataType,\n  FileSystemConfig,\n  VisualizationPlugin,\n  DEFAULT_PROJECTION,\n  REACT_VIEW_HANDLES,\n  Status,\n} from '@/Globals'\n\nimport GeojsonLayer from './GeojsonLayer'\nimport BackgroundMapOnTop from '@/components/BackgroundMapOnTop.vue'\nimport ColorWidthSymbologizer, { buildRGBfromHexCodes } from '@/js/ColorsAndWidths'\nimport VizConfigurator from '@/components/viz-configurator/VizConfigurator.vue'\nimport LegendBox from '@/components/viz-configurator/LegendBox.vue'\nimport ModalIdColumnPicker from '@/components/ModalIdColumnPicker.vue'\nimport ZoomButtons from '@/components/ZoomButtons.vue'\nimport DrawingTool from '@/components/DrawingTool/DrawingTool.vue'\n\nimport HTTPFileSystem from '@/js/HTTPFileSystem'\nimport DashboardDataManager, { FilterDefinition, checkFilterValue } from '@/js/DashboardDataManager'\nimport { arrayBufferToBase64 } from '@/js/util'\nimport { CircleRadiusDefinition } from '@/components/viz-configurator/CircleRadius.vue'\nimport { FillColorDefinition } from '@/components/viz-configurator/FillColors.vue'\nimport { LineColorDefinition } from '@/components/viz-configurator/LineColors.vue'\nimport { LineWidthDefinition } from '@/components/viz-configurator/LineWidths.vue'\nimport { FillHeightDefinition } from '@/components/viz-configurator/FillHeight.vue'\nimport { DatasetDefinition } from '@/components/viz-configurator/AddDatasets.vue'\nimport { LayerDefinition } from '@/components/viz-configurator/Layers.vue'\nimport Coords from '@/js/Coords'\nimport LegendStore from '@/js/LegendStore'\n\ninterface FilterDetails {\n  column: string\n  label?: string\n  options: any[]\n  active: any[]\n  dataset?: any\n}\n\nexport interface BackgroundLayer {\n  features: any[]\n  opacity: number\n  borderWidth: number\n  borderColor: number[]\n  visible: boolean\n  onTop: boolean\n}\n\nconst MyComponent = defineComponent({\n  name: 'ShapeFilePlugin',\n  components: {\n    BackgroundMapOnTop,\n    LegendBox,\n    GeojsonLayer,\n    ModalIdColumnPicker,\n    VizConfigurator,\n    ZoomButtons,\n    DrawingTool,\n  },\n\n  props: {\n    root: { type: String, required: true },\n    subfolder: { type: String, required: true },\n    datamanager: { type: Object as PropType<DashboardDataManager> },\n    configFromDashboard: { type: Object as any },\n    yamlConfig: String,\n    thumbnail: Boolean,\n    // fsConfig: { type: Object as PropType<FileSystemConfig> },\n  },\n\n  data() {\n    return {\n      avroNetwork: null as any,\n      isAvroFile: false,\n      //drag\n      isDraggingDivider: 0,\n      isDragHappening: false,\n      dragStartWidth: 200,\n      legendSectionWidth: 200,\n      //\n      boundaries: [] as any[],\n      centroids: [] as any[],\n      cbDatasetJoined: undefined as any,\n      legendStore: new LegendStore(),\n      chosenNewFilterColumn: '',\n      boundaryDataTable: {} as DataTable,\n      dataFillColors: '#888' as string | Uint8ClampedArray,\n      dataLineColors: '' as string | Uint8ClampedArray,\n      dataLineWidths: 1 as number | Float32Array,\n      dataPointRadii: 5 as number | Float32Array,\n      dataFillHeights: 0 as number | Float32Array,\n      dataCalculatedValues: null as Float32Array | null,\n      dataNormalizedValues: null as Float32Array | null,\n      constantLineWidth: null as null | number,\n      dataCalculatedValueLabel: '',\n\n      globalStore,\n      globalState: globalStore.state,\n      layerId: Math.floor(1e12 * Math.random()),\n\n      activeColumn: '',\n      useCircles: false,\n      sliderOpacity: 100,\n\n      maxValue: 1000,\n      expColors: false,\n      isLoaded: false,\n      isAreaMode: true,\n      statusText: 'Loading...',\n\n      // Filters. Key is column id; value array is empty for \"all\" or a list of \"or\" values\n      filters: {} as { [column: string]: FilterDetails },\n\n      needsInitialMapExtent: true,\n      datasetJoinColumn: '',\n      featureJoinColumn: '',\n      triggerScreenshot: 0,\n      redraw: 0,\n\n      datasetKeyToFilename: {} as any,\n\n      datasetJoinSelector: {} as { [id: string]: { title: string; columns: string[] } },\n      showJoiner: false,\n      showLegend: true,\n\n      // DataManager might be passed in from the dashboard; or we might be\n      // in single-view mode, in which case we need to create one for ourselves\n      myDataManager: this.datamanager || new DashboardDataManager(this.root, this.subfolder),\n\n      config: {} as any,\n      // these are the settings defined in the UI\n      currentUIFilterDefinitions: {} as any,\n      currentUIFillColorDefinitions: {} as any,\n      currentUILineColorDefinitions: {} as any,\n\n      // these are the processed filter defs passed to the data manager\n      filterDefinitions: [] as FilterDefinition[],\n\n      isEmbedded: false,\n      resizer: null as null | ResizeObserver,\n      boundaryFilters: new Float32Array(0),\n      thumbnailUrl: \"url('assets/thumbnail.jpg') no-repeat;\",\n      boundaryJoinLookups: {} as { [column: string]: { [lookup: string | number]: number } },\n      datasetValuesColumn: '',\n\n      tooltipHtml: '' as string,\n      tooltipIsFixed: false as boolean,\n      highlightedLinkIndex: -1 as number,\n\n      bgLayers: {} as { [name: string]: BackgroundLayer },\n\n      vizDetails: {\n        title: '',\n        description: '',\n        datasets: {} as { [id: string]: { file: string; join: string } },\n        useSlider: false,\n        showDifferences: false,\n        shpFile: '',\n        dbfFile: '',\n        network: '',\n        geojsonFile: '',\n        projection: '',\n        widthFactor: null as any,\n        thumbnail: '',\n        sum: false,\n        filters: [] as { [filterId: string]: any }[],\n        shapes: '' as string | { file: string; join: string },\n        zoom: null as number | null,\n        center: null as any[] | null,\n        pitch: null as number | null,\n        bearing: null as number | null,\n        display: {\n          fill: {} as any,\n          fillHeight: {} as any,\n          color: {} as any,\n          width: {} as any,\n          lineColor: {} as any,\n          lineWidth: {} as any,\n          radius: {} as any,\n        },\n        tooltip: [] as string[],\n        backgroundLayers: {} as {\n          [name: string]: {\n            shapes: string\n            projection: string\n            fill: string\n            opacity: number\n            borderWidth: any\n            borderColor: string\n            label: string\n            visible: boolean\n          }\n        },\n      },\n\n      datasets: {} as { [id: string]: DataTable },\n    }\n  },\n\n  computed: {\n    fileApi(): HTTPFileSystem {\n      return new HTTPFileSystem(this.fileSystem, globalStore)\n    },\n\n    fileSystem(): FileSystemConfig {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === this.root\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n\n    configuratorSections(): string[] {\n      if (this.isAreaMode)\n        return [\n          'fill-color',\n          'fill-height',\n          'line-color',\n          'line-width',\n          'circle-radius',\n          'layers',\n          'filters',\n        ]\n      else return ['line-color', 'line-width', 'layers', 'filters']\n    },\n\n    datasetChoices(): string[] {\n      return Object.keys(this.datasets)\n    },\n\n    generatedExportFilename(): string {\n      let filename = Sanitize(this.yamlConfig ?? '')\n      filename = filename.replaceAll(' ', '-')\n\n      if (!filename.startsWith('viz-map-')) filename = 'viz-map-' + filename\n      if (!filename.endsWith('.yml') && !filename.endsWith('.yaml')) filename = filename + '.yaml'\n\n      return filename\n    },\n\n    urlThumbnail(): string {\n      return this.thumbnailUrl\n    },\n  },\n\n  watch: {\n    'globalState.viewState'() {\n      if (!REACT_VIEW_HANDLES[this.layerId]) return\n      REACT_VIEW_HANDLES[this.layerId]()\n    },\n\n    'globalState.colorScheme'() {\n      // change one element to force a deck.gl redraw\n      this.$nextTick().then(p => {\n        const tooltips = this.vizDetails.tooltip || []\n        this.vizDetails.tooltip = [...tooltips]\n      })\n    },\n  },\n\n  methods: {\n    dividerDragStart(e: MouseEvent) {\n      console.log('dragStart', e)\n      this.isDraggingDivider = e.clientX\n      this.dragStartWidth = this.legendSectionWidth\n    },\n\n    dividerDragEnd(e: MouseEvent) {\n      this.isDraggingDivider = 0\n    },\n\n    dividerDragging(e: MouseEvent) {\n      if (!this.isDraggingDivider) return\n\n      const deltaX = this.isDraggingDivider - e.clientX\n      this.legendSectionWidth = Math.max(0, this.dragStartWidth + deltaX)\n      // localStorage.setItem('leftPanelWidth', `${this.legendSectionWidth}`)\n    },\n\n    // incrementing screenshot count triggers the screenshot.\n    takeScreenshot() {\n      this.triggerScreenshot++\n    },\n\n    setEmbeddedMode() {\n      if ('embed' in this.$route.query) {\n        console.log('EMBEDDED MODE')\n        this.isEmbedded = true\n        this.$store.commit('setShowLeftBar', false)\n        this.$store.commit('setFullWidth', true)\n      }\n    },\n\n    setupLogoMover() {\n      this.resizer = new ResizeObserver(this.moveLogo)\n      const deckmap = document.getElementById(`container-${this.layerId}`) as HTMLElement\n      if (deckmap) this.resizer.observe(deckmap)\n    },\n\n    moveLogo() {\n      const deckmap = document.getElementById(`container-${this.layerId}`) as HTMLElement\n      const logo = deckmap?.querySelector('.mapboxgl-ctrl-bottom-left') as HTMLElement\n      if (logo) {\n        const right = deckmap.clientWidth > 640 ? '280px' : '36px'\n        logo.style.right = right\n      }\n    },\n\n    columnsInDataset(datasetId: string) {\n      const data = this.datasets[datasetId]\n      return Object.keys(data)\n    },\n\n    filterShapesNow() {\n      // shape filters only\n      const shapeFilters = this.filterDefinitions.filter(f => f.dataset === 'shapes')\n\n      this.boundaryFilters = new Float32Array(this.boundaries.length)\n\n      // show all elements if there are no shapefilters defined\n      if (!shapeFilters.length) return\n\n      const isLTGT = /^(<|>)/ // starts with < or >\n\n      for (const filter of shapeFilters) {\n        // console.log('filter >>>:', filter)\n        let spec = filter.value\n        let conditional = ''\n\n        // check categorical\n        if (spec == '@categorical') {\n          conditional = '@categorical'\n          spec = ''\n        }\n        // check LT/GT\n        else if (isLTGT.test(spec)) {\n          if (spec.startsWith('<=')) {\n            conditional = '<='\n            spec = parseFloat(spec.substring(2).trim())\n          } else if (spec.startsWith('>=')) {\n            conditional = '>='\n            spec = parseFloat(spec.substring(2).trim())\n          } else if (spec.startsWith('<')) {\n            conditional = '<'\n            spec = parseFloat(spec.substring(1).trim())\n          } else if (spec.startsWith('>')) {\n            conditional = '>'\n            spec = parseFloat(spec.substring(1).trim())\n          }\n        }\n        // handle case where we are testing equal/inequal and its a \"numeric\" string\n        else {\n          if (typeof spec === 'string') {\n            // handle a comma-separated list\n            if (spec.indexOf(',') > -1) {\n              spec = spec\n                .split(',')\n                .map(v => v.trim())\n                .map(v => (Number.isNaN(parseFloat(v)) ? v : parseFloat(v)))\n            } else {\n              const numericString = parseFloat(spec)\n              if (!Number.isNaN(numericString)) spec = numericString\n            }\n          }\n        }\n\n        if (!Array.isArray(spec)) spec = [spec]\n\n        const fullSpecification = { conditional, invert: filter.invert || false, values: spec }\n        // console.log('HEREWEGO: ', fullSpecification)\n        const dataColumnValues = this.boundaryDataTable[filter.column].values\n\n        // update every row\n        for (let i = 0; i < this.boundaries.length; i++) {\n          if (!checkFilterValue(fullSpecification, dataColumnValues[i])) {\n            this.boundaryFilters[i] = -1\n          }\n        }\n      }\n    },\n\n    // this will only round a number if it is a plain old regular number with\n    // a fractional part to the right of the decimal point.\n    truncateFractionalPart(value: any, precision: number) {\n      if (typeof value !== 'number') return value\n\n      let printValue = '' + value\n      if (printValue.includes('.') && printValue.indexOf('.') === printValue.lastIndexOf('.')) {\n        if (/\\d$/.test(printValue))\n          return printValue.substring(0, 1 + precision + printValue.lastIndexOf('.')) // precise(value, precision)\n      }\n      return value\n    },\n\n    async handleClickEvent(event: any) {\n      if (event.index != -1) {\n        this.cbTooltip(event.index, event, true)\n        this.tooltipIsFixed = true\n      } else {\n        this.tooltipIsFixed = false\n        this.highlightedLinkIndex = -1\n        this.tooltipHtml = ''\n      }\n    },\n\n    cbTooltip(index: number, object: any, forceUpdate: boolean = false) {\n      if (this.tooltipIsFixed && !forceUpdate) return\n\n      this.highlightedLinkIndex = index\n\n      // tooltip will show values for color settings and for width settings.\n      // if there is base data, it will also show values and diff vs. base\n      // for both color and width.\n\n      const PRECISION = 4\n\n      if (object === null || !this.boundaries[index]?.properties) {\n        this.tooltipHtml = ''\n        return\n      }\n\n      const propList = []\n\n      // normalized value first\n      if (this.dataNormalizedValues) {\n        const label = this.dataCalculatedValueLabel ?? 'Normalized Value'\n        let value = this.truncateFractionalPart(this.dataNormalizedValues[index], PRECISION)\n\n        propList.push(\n          `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${label}</td><td><b>${value}</b></td></tr>`\n        )\n      }\n\n      // calculated value\n      if (this.dataCalculatedValues) {\n        let cLabel = this.dataCalculatedValueLabel ?? 'Value'\n\n        const label = this.dataNormalizedValues\n          ? cLabel.substring(0, cLabel.lastIndexOf('/'))\n          : cLabel\n        let value = this.truncateFractionalPart(this.dataCalculatedValues[index], PRECISION)\n        if (this.dataCalculatedValueLabel.startsWith('%')) value = `${value} %`\n\n        propList.push(\n          `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${label}</td><td><b>${value}</b></td></tr>\n         <tr><td>&nbsp;</td></tr>`\n        )\n      }\n\n      // --- dataset tooltip lines ---\n      let datasetProps = ''\n      const featureTips = Object.entries(this.boundaries[index].properties)\n\n      for (const [tipKey, tipValue] of featureTips) {\n        if (tipValue === null) continue\n\n        // Truncate fractional digits IF it is a simple number that has a fraction\n        let value = this.truncateFractionalPart(tipValue, PRECISION)\n        datasetProps += `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${tipKey}</td><td><b>${value}</b></td></tr>`\n      }\n      if (datasetProps) propList.push(datasetProps)\n\n      // --- boundary feature tooltip lines ---\n      let columns = Object.keys(this.boundaryDataTable)\n      if (this.vizDetails.tooltip?.length) {\n        columns = this.vizDetails.tooltip.map(tip => tip.substring(tip.indexOf(':') + 1))\n      }\n\n      let featureProps = ''\n      columns.forEach(column => {\n        if (this.boundaryDataTable[column]) {\n          let value = this.boundaryDataTable[column].values[index]\n          if (value == null) return\n          if (typeof value == 'number') value = this.truncateFractionalPart(value, PRECISION)\n          featureProps += `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${column}</td><td><b>${value}</b></td></tr>`\n        }\n      })\n      if (featureProps) propList.push(featureProps)\n\n      // nothing to show? no tooltip\n      if (!propList.length) {\n        this.tooltipHtml = ''\n        return\n      }\n\n      let finalHTML = propList.join('')\n      const html = `<table>${finalHTML}</table>`\n      this.tooltipHtml = html\n    },\n\n    filterShapesNowOriginal() {\n      // shape filters only\n      const shapeFilters = this.filterDefinitions.filter(f => f.dataset === 'shapes')\n\n      this.boundaryFilters = new Float32Array(this.boundaries.length)\n\n      // show all elements if there are no shapefilters defined\n      if (!shapeFilters.length) return\n\n      // console.log({ shapeFilters, length: this.boundaries.length })\n\n      // loop on all boundaries and centroids\n      for (let i = 0; i < this.boundaries.length; i++) {\n        for (const filter of shapeFilters) {\n          const hideElement = !this.checkIsFiltered(i, filter)\n          if (hideElement) this.boundaryFilters[i] = -1\n        }\n      }\n    },\n\n    checkIsFiltered(i: number, filter: FilterDefinition) {\n      const dataset =\n        filter.dataset == 'shapes' ? this.boundaryDataTable : this.datasets[filter.dataset]\n      const actualValue = dataset[filter.column].values[i]\n\n      let includeElement = false\n\n      let filterValue = filter.value\n      if (typeof filterValue == 'string' && filterValue.indexOf(',') > -1) {\n        filterValue = filterValue\n          .split(',')\n          .map(v => v.trim())\n          .map(v => (isNaN(parseFloat(v)) ? v : parseFloat(v)))\n      }\n\n      if (Array.isArray(filterValue)) {\n        // 1. filter is an array of categories\n        includeElement = filterValue.indexOf(actualValue) > -1\n      } else {\n        // 2. filter is a string: exact value or CSV\n        includeElement = filterValue == actualValue\n      }\n\n      // Invert if inverted\n      if (filter.invert) includeElement = !includeElement\n\n      return includeElement\n    },\n\n    parseFilterDefinitions(filterDefs: any) {\n      // no filters? go away\n      if (!filterDefs) return []\n\n      const filters = [] as FilterDefinition[]\n\n      // User may have specified an array or an object:\n      let filterSpecs: any[]\n      if (Array.isArray(filterDefs)) {\n        filterSpecs = filterDefs.map(f => Object.entries(f)[0])\n      } else {\n        filterSpecs = Object.entries(filterDefs)\n      }\n\n      for (const filter of filterSpecs) {\n        const [id, value] = filter\n        const [dataset, column] = id.split('.')\n        const filterDefinition: FilterDefinition = {\n          dataset,\n          value,\n          column: column.endsWith('!') ? column.substring(0, column.length - 1) : column,\n          invert: column.endsWith('!'),\n        }\n        filters.push(filterDefinition)\n\n        // // categorical filters may already have UI settings that need merging\n        // if (column in this.filters) {\n        //   filterDefinition.....\n        // }\n      }\n\n      return filters\n    },\n\n    honorQueryParameters() {\n      const query = this.$route.query\n      if (query.show == 'dots') this.useCircles = true\n\n      // this.setupQueryFilters()\n    },\n\n    // perhaps we have some active filters in the URL query\n    setupQueryFilters() {\n      const datasetKeys = Object.keys(this.datasets)\n      // TODO - make this multi-dataset aware  // 2 means shapes + dataset #1.\n      if (datasetKeys.length !== 2) return\n\n      const firstDatasetKey = datasetKeys[1]\n      const firstDataset = this.datasets[firstDatasetKey]\n\n      const columnNames = Object.keys(firstDataset)\n\n      const queryFilters = Object.keys(this.$route.query).filter(f => columnNames.indexOf(f) > -1)\n\n      for (const column of queryFilters) {\n        if (!this.filters[column]) {\n          console.log('CREATING category filter:', column)\n          this.handleUserCreatedNewFilter(`${firstDatasetKey}:${column}`)\n        }\n\n        const text = '' + this.$route.query[column]\n        if (text) this.filters[column].active = text.split(',')\n\n        this.myDataManager.setFilter({\n          dataset: this.datasetKeyToFilename[firstDatasetKey],\n          column,\n          value: this.filters[column].active,\n        })\n        this.activateFiltersForDataset(firstDatasetKey)\n      }\n    },\n\n    convertCommasToArray(thing: any): any[] {\n      if (thing === undefined) return []\n      if (Array.isArray(thing)) return thing\n\n      if (thing.indexOf(',') > -1) {\n        thing = thing.split(',').map((f: any) => f.trim())\n      } else {\n        thing = [thing.trim()]\n      }\n      return thing\n    },\n\n    async getVizDetails() {\n      const emptyState = {\n        datasets: {} as any,\n        display: { fill: {} as any },\n      }\n\n      // are we in a dashboard?\n      if (this.configFromDashboard) {\n        this.config = JSON.parse(JSON.stringify(this.configFromDashboard))\n        this.vizDetails = Object.assign({}, emptyState, this.configFromDashboard)\n      } else {\n        // was a YAML file was passed in?\n        const filename = (this.yamlConfig ?? '').toLocaleLowerCase()\n\n        if (filename?.endsWith('yaml') || filename?.endsWith('yml')) {\n          const ycfg = await this.loadYamlConfig()\n          this.config = ycfg\n          this.vizDetails = Object.assign({}, emptyState, ycfg)\n        }\n\n        // OR is this a bare geojson/shapefile file? - build vizDetails manually\n        if (\n          /(network\\.xml)(|\\.gz)$/.test(filename) ||\n          /(\\.geojson)(|\\.gz)$/.test(filename) ||\n          /\\.shp$/.test(filename) ||\n          /network\\.avro$/.test(filename)\n        ) {\n          const title = `${filename.endsWith('shp') ? 'Shapefile' : 'File'}: ${this.yamlConfig}`\n\n          this.vizDetails = Object.assign({}, emptyState, this.vizDetails, {\n            title,\n            description: this.subfolder,\n            shapes: this.yamlConfig,\n          })\n\n          this.config = JSON.parse(JSON.stringify(this.vizDetails))\n        }\n      }\n\n      if (!this.vizDetails.backgroundLayers) this.vizDetails.backgroundLayers = {}\n\n      const t = this.vizDetails.title || 'Map'\n      this.$emit('title', t)\n    },\n\n    // figure out old-style joins\n    buildOldJoinLookups() {\n      const oldJoinFieldPerDataset = {} as any\n\n      for (const dataset of Object.keys(this.vizDetails.datasets || [])) {\n        const join = this.vizDetails.datasets[dataset].join\n        if (!join) continue\n\n        const colon = join.indexOf(':')\n        oldJoinFieldPerDataset[dataset] = join.substring(colon + 1)\n        if (typeof this.vizDetails.shapes == 'string') {\n          const shapeJoinField = colon > -1 ? join.substring(0, colon) : join\n          this.vizDetails.shapes = { file: this.vizDetails.shapes, join: shapeJoinField }\n        }\n      }\n\n      // apply old-style joins to elements\n      for (const section of Object.keys(this.vizDetails.display || [])) {\n        const display = this.vizDetails.display as any\n        const details = display[section]\n        if ((details.dataset || details.diff) && !details.join) {\n          details.join = oldJoinFieldPerDataset[details.dataset]\n        }\n      }\n    },\n\n    async buildThumbnail() {\n      if (this.thumbnail && this.vizDetails.thumbnail) {\n        try {\n          const blob = await this.fileApi.getFileBlob(\n            this.subfolder + '/' + this.vizDetails.thumbnail\n          )\n          const buffer = await readBlob.arraybuffer(blob)\n          const base64 = arrayBufferToBase64(buffer)\n          if (base64)\n            this.thumbnailUrl = `center / cover no-repeat url(data:image/png;base64,${base64})`\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n\n    getFileSystem(name: string) {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === name\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n\n    async loadYamlConfig() {\n      const config = this.yamlConfig ?? ''\n      const filename = config.indexOf('/') > -1 ? config : this.subfolder + '/' + config\n\n      // 1. First try loading the file directly\n      try {\n        const text = await this.fileApi.getFileText(filename)\n        return YAML.parse(text)\n      } catch (err) {\n        const message = '' + err\n        if (message.startsWith('YAMLSemantic')) {\n          this.$emit('error', `${filename}: ${message}`)\n        }\n        console.log(`${filename} not found, trying config folders`)\n      }\n\n      // 2. Try loading from a config folder instead\n      const { vizes } = await this.fileApi.findAllYamlConfigs(this.subfolder)\n      if (vizes[config]) {\n        try {\n          const text = await this.fileApi.getFileText(vizes[config])\n          return YAML.parse(text)\n        } catch (err) {\n          console.error(`Also failed to load ${vizes[config]}`)\n        }\n      }\n      this.$emit('error', 'Could not load YAML: ' + filename)\n    },\n\n    /**\n     * changeConfiguration: is the main entry point for changing the viz model.\n     * anything that wants to change colors, widths, data, anthing like that\n     * should all pass through this function so the underlying data model\n     * is modified properly.\n     */\n    changeConfiguration(props: {\n      fill?: FillColorDefinition\n      dataset?: DatasetDefinition\n      lineColor?: LineColorDefinition\n      lineWidth?: LineWidthDefinition\n      radius?: CircleRadiusDefinition\n      fillHeight?: FillHeightDefinition\n      filters?: FilterDefinition\n      layers?: LayerDefinition[]\n    }) {\n      // console.log('PROPS', props)\n\n      try {\n        if (props['fill']) {\n          this.vizDetails.display.fill = props.fill\n          this.handleNewFillColor(props.fill)\n        }\n\n        if (props['fillHeight']) {\n          this.vizDetails.display.fillHeight = props.fillHeight\n          this.handleNewFillHeight(props.fillHeight)\n        }\n\n        if (props['lineColor']) {\n          this.vizDetails.display.lineColor = props.lineColor\n          this.handleNewLineColor(props.lineColor)\n        }\n\n        if (props['lineWidth']) {\n          this.vizDetails.display.lineWidth = props.lineWidth\n          this.handleNewLineWidth(props.lineWidth)\n          // redo colors after widths to ensure categorical widths are set properly\n          if (this.currentUILineColorDefinitions)\n            this.handleNewLineColor(this.currentUILineColorDefinitions)\n        }\n\n        if (props['radius']) {\n          this.vizDetails.display.radius = props.radius\n          this.handleNewRadius(props.radius)\n        }\n\n        if (props['dataset']) {\n          // vizdetails just had the string name, whereas props.dataset contains\n          // a fully-build DatasetDefinition, so let's just handle that\n          this.handleNewDataset(props.dataset)\n        }\n\n        if (props['layers']) {\n          // this.vizDetails.display.radius = props.radius\n          this.handleNewLayers(props.layers)\n        }\n\n        if (props['filters']) {\n          this.handleNewFilters(props.filters)\n        }\n\n        // console.log('DONE updating')\n      } catch (e) {\n        this.$emit('error', '' + e)\n      }\n    },\n\n    handleNewLayers(props: LayerDefinition[]) {\n      const layers = {} as any\n      for (const layer of props) {\n        const { title, ...details } = layer\n        layers[title] = details\n      }\n      this.vizDetails.backgroundLayers = layers\n      try {\n        this.loadBackgroundLayers()\n        this.bgLayers = { ...this.bgLayers }\n      } catch (e) {\n        console.error('Error handling layers, check filenames and parameters: ' + e)\n      }\n    },\n\n    async handleNewDataset(props: DatasetDefinition) {\n      const { key, dataTable, filename } = props\n      const datasetId = key\n      const datasetFilename = filename || datasetId\n\n      console.log('HANDLE NEW DATASET:', datasetId, datasetFilename)\n\n      if (!this.boundaryDataTable[this.featureJoinColumn])\n        throw Error(`Geodata does not have property ${this.featureJoinColumn}`)\n\n      this.myDataManager.setPreloadedDataset({\n        key: this.datasetKeyToFilename[datasetId],\n        dataTable,\n      })\n\n      this.myDataManager.addFilterListener(\n        { dataset: this.datasetKeyToFilename[datasetId] },\n        this.processFiltersNow\n      )\n\n      this.vizDetails.datasets[datasetId] = {\n        file: datasetFilename,\n        // if join columns are not named identically, use \"this:that\" format\n        // join:\n        //   featureJoinColumn === dataJoinColumn\n        //     ? featureJoinColumn\n        //     : `${featureJoinColumn}:${dataJoinColumn}`,\n      } as any\n\n      this.vizDetails = Object.assign({}, this.vizDetails)\n      this.datasets[datasetId] = dataTable\n      this.datasets = Object.assign({}, this.datasets)\n    },\n\n    setupJoin(props: { dataTable: DataTable; datasetId: string; dataJoinColumn: string }) {\n      const { dataTable, datasetId, dataJoinColumn } = props\n      // console.log('> setupJoin', datasetId, dataJoinColumn)\n\n      // if no join at all, don't do anything\n      if (!dataJoinColumn) return\n\n      // if join already exists, don't do anything\n      if (`@@${dataJoinColumn}` in dataTable) return\n\n      // make sure columns exist!\n      if (!this.boundaryDataTable[this.featureJoinColumn])\n        throw Error(`Geodata does not have property ${this.featureJoinColumn}`)\n      if (!dataTable[dataJoinColumn])\n        throw Error(`Dataset ${datasetId} does not have column ${dataJoinColumn}`)\n\n      // create lookup column and write lookup offsets\n      const lookupColumn: DataTableColumn = {\n        type: DataType.LOOKUP,\n        values: [],\n        name: `@@${dataJoinColumn}`,\n      }\n\n      const lookupValues = dataTable[dataJoinColumn].values\n      const boundaryOffsets = this.getBoundaryOffsetLookup(this.featureJoinColumn)\n\n      for (let i = 0; i < lookupValues.length; i++) {\n        // set lookup data\n        const featureOffset = boundaryOffsets[lookupValues[i]]\n        lookupColumn.values[i] = featureOffset\n      }\n\n      // add/replace this dataset in the datamanager, with the new lookup column\n      dataTable[`@@${dataJoinColumn}`] = lookupColumn\n      this.myDataManager.setPreloadedDataset({\n        key: this.datasetKeyToFilename[datasetId],\n        dataTable,\n      })\n\n      this.vizDetails.datasets[datasetId] = {\n        file: this.datasetKeyToFilename[datasetId],\n        // if join columns are not named identically, use \"this:that\" format\n        join:\n          this.featureJoinColumn === dataJoinColumn\n            ? this.featureJoinColumn\n            : `${this.featureJoinColumn}:${dataJoinColumn}`,\n      } as any\n\n      this.myDataManager.addFilterListener(\n        { dataset: this.datasetKeyToFilename[datasetId] },\n        this.processFiltersNow\n      )\n\n      this.prepareTooltipData(props)\n\n      // Notify Deck.gl of the new tooltip data\n      if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n        REACT_VIEW_HANDLES[1000 + this.layerId](this.boundaries)\n      }\n      // console.log('triggering updates')\n      this.datasets[datasetId] = dataTable\n    },\n\n    prepareTooltipData(props: { dataTable: DataTable; datasetId: string; dataJoinColumn: string }) {\n      // if user wants specific tooltips based on this dataset, save the values\n      // TODO - this is in the wrong place and probably causes problems with\n      // survey-style multi-record datasets\n\n      const { dataTable, datasetId, dataJoinColumn } = props\n\n      const tips = this.vizDetails.tooltip || []\n      const relevantTips = tips\n        .filter(tip => tip.substring(0, tip.indexOf(':')).startsWith(datasetId))\n        .map(tip => {\n          return { id: tip, column: tip.substring(1 + tip.indexOf(':')) }\n        })\n\n      // no tips for this datasetId\n      if (!relevantTips.length) return\n\n      const lookupValues = dataTable[dataJoinColumn].values\n      const boundaryOffsets = this.getBoundaryOffsetLookup(this.featureJoinColumn)\n\n      for (const tip of relevantTips) {\n        // make sure tip column exists\n        if (!dataTable[tip.column]) {\n          this.$emit('error', `Tooltip references \"${tip.id}\" but that column doesn't exist`)\n          continue\n        }\n\n        // set the tooltip data\n        for (let i = 0; i < lookupValues.length; i++) {\n          const featureOffset = boundaryOffsets[lookupValues[i]]\n          const feature = this.boundaries[featureOffset]\n          const value = dataTable[tip.column].values[i]\n          if (feature) feature.properties[tip.id] = value\n        }\n      }\n    },\n\n    getBoundaryOffsetLookup(joinColumn: string) {\n      // return it if we already built it\n      if (this.boundaryJoinLookups[joinColumn]) return this.boundaryJoinLookups[joinColumn]\n\n      // build it\n      try {\n        this.statusText = 'Joining datasets...'\n        this.boundaryJoinLookups[joinColumn] = {}\n        const lookupValues = this.boundaryJoinLookups[joinColumn]\n\n        const boundaryLookupColumnValues = this.boundaryDataTable[joinColumn].values\n\n        for (let i = 0; i < this.boundaries.length; i++) {\n          lookupValues[boundaryLookupColumnValues[i]] = i\n        }\n        this.statusText = ''\n        return lookupValues\n      } catch (e) {\n        console.warn('waahaa')\n        return {}\n      }\n    },\n\n    removeAnyOldFilters(filters: any) {\n      const oldFilters = new Set(\n        Object.keys(this.currentUIFilterDefinitions).filter(f => !f.startsWith('shapes.'))\n      )\n      const newFilters = new Set(Object.keys(filters).filter(f => !f.startsWith('shapes.')))\n      newFilters.forEach(f => oldFilters.delete(f))\n\n      for (const deletedFilter of oldFilters) {\n        console.log('REMOVING', deletedFilter)\n        const dot = deletedFilter.indexOf('.')\n        const dataset = deletedFilter.slice(0, dot)\n        const column = deletedFilter.slice(dot + 1)\n        this.myDataManager.setFilter({\n          dataset: this.datasetKeyToFilename[dataset],\n          column,\n          value: [],\n        })\n\n        // also remove from category-UI and URL\n        if (column in this.filters) {\n          const query = Object.assign({}, this.$route.query)\n          delete query[column]\n          this.$router.replace({ query })\n\n          delete this.filters[column]\n        }\n      }\n    },\n\n    async handleNewFilters(filters: any) {\n      // Remove removed filters first!\n      this.removeAnyOldFilters(filters)\n\n      this.currentUIFilterDefinitions = filters\n      const newDefinitions = this.parseFilterDefinitions(filters)\n      this.filterDefinitions = newDefinitions\n\n      // Filter the shapes/boundaries\n      this.filterShapesNow()\n\n      // Filter attached datasets\n      Object.keys(this.datasets).forEach(async (datasetKey, i) => {\n        if (i === 0) return // skip shapes, we just did them\n        await this.activateFiltersForDataset(datasetKey)\n        this.processFiltersNow(datasetKey)\n      })\n    },\n\n    handleColorDiffMode(section: string, color: FillColorDefinition | LineColorDefinition) {\n      if (!color.diffDatasets) return\n\n      const columnName = color.columnName\n      const lookupColumn = color.join || ''\n      const key1 = color.diffDatasets[0] || ''\n      const dataset1 = this.datasets[key1]\n      const key2 = color.diffDatasets[1] || ''\n      const dataset2 = this.datasets[key2]\n      const relative = !!color.relative\n\n      if (dataset1 && dataset2) {\n        // generate the lookup columns we need\n        this.setupJoin({ datasetId: key1, dataTable: dataset1, dataJoinColumn: lookupColumn })\n        this.setupJoin({ datasetId: key2, dataTable: dataset2, dataJoinColumn: lookupColumn })\n\n        const lookup1 = dataset1[`@@${lookupColumn}`]\n        const lookup2 = dataset2[`@@${lookupColumn}`]\n        const dataCol1 = dataset1[columnName]\n        const dataCol2 = dataset2[columnName]\n\n        if (!dataCol1) throw Error(`Dataset ${key1} does not contain column \"${columnName}\"`)\n        if (!dataCol2) throw Error(`Dataset ${key2} does not contain column \"${columnName}\"`)\n\n        // NORMALIZE if we need to\n        let normalColumn\n        let normalLookup\n\n        if (color.normalize) {\n          const [dataset, column] = color.normalize.split(':')\n          if (!this.datasets[dataset] || !this.datasets[dataset][column]) {\n            throw Error(`${dataset} does not contain column \"${column}\"`)\n          }\n          this.dataCalculatedValueLabel += `/ ${column}`\n          normalColumn = this.datasets[dataset][column]\n          // Create yet one more join for the normal column if it's not from the featureset itself\n          if (this.datasetChoices[0] !== dataset) {\n            this.setupJoin({\n              datasetId: dataset,\n              dataTable: this.datasets[dataset],\n              dataJoinColumn: lookupColumn,\n            })\n            normalLookup = this.datasets[dataset][`@@${lookupColumn}`]\n          }\n        }\n\n        const ramp = {\n          ramp: color.colorRamp?.ramp || 'Viridis',\n          style: color.colorRamp?.style || 0,\n          reverse: color.colorRamp?.reverse || false,\n          steps: color.colorRamp?.steps || 9,\n          breakpoints: color.colorRamp?.breakpoints,\n        }\n\n        // Calculate colors for each feature\n        const { rgbArray, legend, calculatedValues } =\n          ColorWidthSymbologizer.getColorsForDataColumn({\n            numFeatures: this.boundaries.length,\n            data: dataCol1,\n            data2: dataCol2,\n            lookup: lookup1,\n            lookup2: lookup2,\n            normalColumn: normalColumn,\n            normalLookup,\n            options: { colorRamp: ramp, fixedColors: color.fixedColors },\n            filter: this.boundaryFilters,\n            relative,\n          })\n\n        if (!rgbArray) return\n\n        if (section === 'fill') {\n          this.dataFillColors = rgbArray\n        } else {\n          this.dataLineColors = rgbArray\n        }\n        this.dataCalculatedValues = calculatedValues\n        this.dataCalculatedValueLabel = `${relative ? '% ' : ''}Diff: ${columnName}` // : ${key1}-${key2}`\n\n        this.legendStore.setLegendSection({\n          section: section === 'fill' ? 'FillColor' : 'Line Color',\n          column: dataCol1.name,\n          values: legend,\n          diff: true,\n          relative,\n          normalColumn: normalColumn ? normalColumn.name : '',\n        })\n      }\n    },\n\n    paintColorsWithFilter(section: string, dataTable: DataTable) {\n      const currentDefinition =\n        section === 'fill' ? this.currentUIFillColorDefinitions : this.currentUILineColorDefinitions\n\n      const columnName = currentDefinition.columnName\n      const lookupColumn =\n        currentDefinition.join === '@count'\n          ? dataTable[`@@${columnName}`]\n          : dataTable[`@@${currentDefinition.join}`]\n\n      let normalColumn\n      if (currentDefinition.normalize) {\n        const keys = currentDefinition.normalize.split(':')\n        this.dataCalculatedValueLabel = columnName + '/' + keys[1]\n        const datasetKey = currentDefinition.dataset\n\n        if (!this.datasets[keys[0]] || !this.datasets[keys[0]][keys[1]]) {\n          throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n        }\n        normalColumn = dataTable[keys[1]]\n      }\n\n      const props = {\n        numFeatures: this.boundaries.length,\n        data: dataTable[columnName],\n        lookup: lookupColumn,\n        normalColumn,\n        filter: this.boundaryFilters,\n        options: currentDefinition,\n        join: currentDefinition.join,\n      }\n\n      const { rgbArray, legend, calculatedValues } =\n        ColorWidthSymbologizer.getColorsForDataColumn(props)\n\n      if (!rgbArray) return\n\n      if (section === 'fill') {\n        this.dataFillColors = rgbArray\n      } else {\n        this.dataLineColors = rgbArray\n      }\n\n      this.dataCalculatedValues = calculatedValues\n\n      this.legendStore.setLegendSection({\n        section: section === 'fill' ? 'FillColor' : 'Line Color',\n        column: columnName,\n        values: legend,\n      })\n    },\n\n    handleNewFillColor(fillOrFilteredDataTable: FillColorDefinition | DataTable) {\n      // *** FILTER: if prop has a columnName, then this is a FillColorDefinition\n      const isFillColorDefinition = 'columnName' in fillOrFilteredDataTable\n      const isFilterTable = !isFillColorDefinition\n\n      // If we received a new fill color definition AND the dataset is filtered,\n      // then bookmark that definition and process the filter first/instead.\n      // (note, processFiltersNow() will call this function again once the calcs are done)\n      if (isFillColorDefinition) {\n        const dataset = fillOrFilteredDataTable?.dataset as string\n        const { filteredRows } = this.myDataManager.getFilteredDataset({\n          dataset: `${dataset}` || '',\n        })\n        if (filteredRows && filteredRows.length) {\n          this.currentUIFillColorDefinitions = fillOrFilteredDataTable\n          this.processFiltersNow(dataset)\n          return\n        }\n      }\n\n      if (isFilterTable) {\n        this.paintColorsWithFilter('fill', fillOrFilteredDataTable)\n        return\n      }\n\n      const color = fillOrFilteredDataTable as FillColorDefinition\n      this.currentUIFillColorDefinitions = color\n\n      const columnName = color.columnName\n\n      if (color.diffDatasets) {\n        // *** diff mode *************************\n        this.handleColorDiffMode('fill', color)\n        return\n      }\n\n      if (!columnName) {\n        // *** simple color **********************\n        this.dataFillColors = color.fixedColors[0]\n        this.dataCalculatedValueLabel = ''\n        this.legendStore.clear('FillColor')\n        return\n      }\n\n      // *** Data column mode *************************************************************\n      const datasetKey = color.dataset || ''\n      const selectedDataset = this.datasets[datasetKey]\n      this.dataCalculatedValueLabel = ''\n\n      // no selected dataset or datacol missing? Not sure what to do here, just give up...\n      if (!selectedDataset) {\n        console.warn('color: no selected dataset yet, maybe still loading')\n        return\n      }\n      const dataColumn = selectedDataset[columnName]\n      if (!dataColumn) throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n      this.dataCalculatedValueLabel = columnName ?? ''\n\n      // Do we need a join? Join it\n      let dataJoinColumn = ''\n      if (color.join && color.join !== '@count') {\n        // join column name set by user\n        dataJoinColumn = color.join\n      } else if (color.join === '@count') {\n        // rowcount specified: join on the column name itself\n        dataJoinColumn = columnName\n      } else {\n        // nothing specified: let's hope they didn't want to join\n        if (this.datasetChoices.length > 1) {\n          console.warn('No join; lets hope user just wants to display data in boundary file')\n        }\n      }\n\n      this.setupJoin({\n        datasetId: datasetKey,\n        dataTable: selectedDataset,\n        dataJoinColumn,\n      })\n\n      const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n      // NORMALIZE if we need to\n      let normalColumn\n      let normalLookup\n      if (color.normalize) {\n        const [dataset, column] = color.normalize.split(':')\n        if (!this.datasets[dataset] || !this.datasets[dataset][column]) {\n          throw Error(`${dataset} does not contain column \"${column}\"`)\n        }\n        this.dataCalculatedValueLabel += `/ ${column}`\n        normalColumn = this.datasets[dataset][column]\n        // Create yet one more join for the normal column if it's not from the featureset itself\n        if (this.datasetChoices[0] !== dataset) {\n          this.setupJoin({\n            datasetId: dataset,\n            dataTable: this.datasets[dataset],\n            dataJoinColumn,\n          })\n          normalLookup = this.datasets[dataset][`@@${dataJoinColumn}`]\n        }\n      }\n\n      const ramp = {\n        ramp: color.colorRamp?.ramp || 'Viridis',\n        style: color.colorRamp?.style || 0,\n        reverse: color.colorRamp?.reverse || false,\n        steps: color.colorRamp?.steps || 9,\n        breakpoints: color.colorRamp?.breakpoints || undefined,\n      }\n\n      // Calculate colors for each feature\n      const { rgbArray, legend, calculatedValues } = ColorWidthSymbologizer.getColorsForDataColumn({\n        numFeatures: this.boundaries.length,\n        data: dataColumn,\n        normalColumn,\n        normalLookup,\n        lookup: lookupColumn,\n        filter: this.boundaryFilters,\n        options: { colorRamp: ramp, fixedColors: color.fixedColors },\n        join: color.join,\n      })\n\n      if (rgbArray) {\n        this.dataFillColors = rgbArray\n        this.dataCalculatedValues = calculatedValues\n        this.dataNormalizedValues = calculatedValues || null\n\n        this.legendStore.setLegendSection({\n          section: 'FillColor',\n          column: dataColumn.name,\n          values: legend,\n          normalColumn: normalColumn ? normalColumn.name : '',\n        })\n      }\n    },\n\n    handleNewLineColor(colorOrFilteredDataTable: LineColorDefinition | DataTable | false) {\n      if (colorOrFilteredDataTable === false) {\n        this.dataLineColors = ''\n        this.legendStore.clear('Line Color')\n        return\n      }\n\n      // *** FILTER: if prop has a columnName, then this is a LineColorDefinition\n      const isColorDefinition = 'columnName' in colorOrFilteredDataTable\n      const isFilterTable = !isColorDefinition\n\n      // If we received a new color definition AND the dataset is filtered,\n      // then bookmark that definition and process the filter first/instead.\n      // (note, processFiltersNow() will call this function again once the calcs are done)\n      if (isColorDefinition) {\n        const dataset = colorOrFilteredDataTable?.dataset as string\n        const { filteredRows } = this.myDataManager.getFilteredDataset({\n          dataset: `${dataset}` || '',\n        })\n        if (filteredRows && filteredRows.length) {\n          this.currentUILineColorDefinitions = colorOrFilteredDataTable\n          this.processFiltersNow(dataset)\n          return\n        }\n      }\n\n      if (isFilterTable) {\n        this.paintColorsWithFilter('lineColor', colorOrFilteredDataTable)\n        return\n      }\n\n      const color = colorOrFilteredDataTable as LineColorDefinition\n      this.currentUILineColorDefinitions = color\n\n      const columnName = color.columnName\n\n      if (color.diffDatasets) {\n        // *** diff mode *************************\n        this.handleColorDiffMode('lineColor', color)\n        return\n      } else if (!columnName) {\n        // *** simple color **********************\n        this.dataLineColors = color.fixedColors[0]\n        this.dataCalculatedValueLabel = ''\n        this.legendStore.clear('Line Color')\n        return\n      } else {\n        // *** Data column mode ******************\n        const datasetKey = color.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        this.dataCalculatedValueLabel = ''\n\n        // no selected dataset or datacol missing? Not sure what to do here, just give up...\n        if (!selectedDataset) {\n          console.warn('color: no selected dataset yet, maybe still loading')\n          return\n        }\n\n        const dataColumn = selectedDataset[columnName]\n        if (!dataColumn) {\n          throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n        }\n\n        this.dataCalculatedValueLabel = columnName ?? ''\n\n        // Do we need a join? Join it\n        let dataJoinColumn = ''\n        if (color.join && color.join !== '@count') {\n          // join column name set by user\n          dataJoinColumn = color.join\n        } else if (color.join === '@count') {\n          // rowcount specified: join on the column name itself\n          dataJoinColumn = columnName\n        } else {\n          // nothing specified: let's hope they didn't want to join\n          if (this.datasetChoices.length > 1) {\n            console.warn('No join; lets hope user just wants to display data in boundary file')\n          }\n        }\n\n        this.setupJoin({\n          datasetId: datasetKey,\n          dataTable: selectedDataset,\n          dataJoinColumn,\n        })\n\n        const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n        // NORMALIZE if we need to\n        let normalColumn\n        let normalLookup\n        if (color.normalize) {\n          const [dataset, column] = color.normalize.split(':')\n          if (!this.datasets[dataset] || !this.datasets[dataset][column]) {\n            throw Error(`${dataset} does not contain column \"${column}\"`)\n          }\n          this.dataCalculatedValueLabel += `/ ${column}`\n          normalColumn = this.datasets[dataset][column]\n          // Create yet one more join for the normal column if it's not from the featureset itself\n          if (this.datasetChoices[0] !== dataset) {\n            this.setupJoin({\n              datasetId: dataset,\n              dataTable: this.datasets[dataset],\n              dataJoinColumn,\n            })\n            normalLookup = this.datasets[dataset][`@@${dataJoinColumn}`]\n          }\n        }\n\n        // Calculate colors for each feature\n\n        const ramp = {\n          ramp: color.colorRamp?.ramp || 'Viridis',\n          style: color.colorRamp?.style || 0,\n          reverse: color.colorRamp?.reverse || false,\n          steps: color.colorRamp?.steps || 9,\n          breakpoints: color.colorRamp?.breakpoints,\n        }\n\n        const result = ColorWidthSymbologizer.getColorsForDataColumn({\n          numFeatures: this.boundaries.length,\n          data: dataColumn,\n          lookup: lookupColumn,\n          normalColumn,\n          normalLookup,\n          filter: this.boundaryFilters,\n          options: { colorRamp: ramp, fixedColors: color.fixedColors },\n          join: color.join,\n        }) as any\n\n        const { rgbArray, legend, calculatedValues } = result\n\n        if (!rgbArray) return\n\n        this.dataLineColors = rgbArray\n\n        this.dataCalculatedValues = calculatedValues\n        this.dataNormalizedValues = calculatedValues || null\n\n        // If colors are based on category and line widths are constant, then use a\n        // 1-pixel line width when the category is undefined.\n        if (result.hasCategory && this.constantLineWidth !== null) {\n          const lineWidth = this.constantLineWidth as number\n          const variableConstantWidth = new Float32Array(this.boundaries.length).fill(1)\n          Object.keys(result.hasCategory).forEach((i: any) => {\n            variableConstantWidth[i] = lineWidth\n          })\n          this.dataLineWidths = variableConstantWidth\n        }\n        this.legendStore.setLegendSection({\n          section: 'Line Color',\n          column: dataColumn.name,\n          values: legend,\n          normalColumn: normalColumn ? normalColumn.name : '',\n        })\n      }\n    },\n\n    handleNewLineWidth(width: LineWidthDefinition) {\n      const columnName = width.columnName || ''\n\n      // constant line width?  @0, @1, @2\n      if (width.dataset && /^@\\d$/.test(width.dataset)) {\n        this.dataLineWidths = Number.parseInt(width.dataset.substring(1))\n        this.constantLineWidth = this.dataLineWidths\n        this.legendStore.clear('Line Width')\n        return\n      } else {\n        this.constantLineWidth = null\n      }\n\n      // No scale factor?\n      if (width.scaleFactor && isNaN(width.scaleFactor)) {\n        this.dataLineWidths = 1\n        this.legendStore.clear('Line Width')\n        return\n      }\n\n      if (width.diffDatasets) {\n        const lookupColumn = width.join || ''\n        const key1 = width.diffDatasets[0] || ''\n        const dataset1 = this.datasets[key1]\n        const key2 = width.diffDatasets[1] || ''\n        const dataset2 = this.datasets[key2]\n        // const relative = !!width.relative\n\n        if (dataset1 && dataset2) {\n          // generate the lookup columns we need\n          this.setupJoin({ datasetId: key1, dataTable: dataset1, dataJoinColumn: lookupColumn })\n          this.setupJoin({ datasetId: key2, dataTable: dataset2, dataJoinColumn: lookupColumn })\n\n          const lookup1 = dataset1[`@@${lookupColumn}`]\n          const lookup2 = dataset2[`@@${lookupColumn}`]\n          const dataCol1 = dataset1[columnName]\n          const dataCol2 = dataset2[columnName]\n\n          if (!dataCol1) throw Error(`Dataset ${key1} does not contain column \"${columnName}\"`)\n          if (!dataCol2) throw Error(`Dataset ${key2} does not contain column \"${columnName}\"`)\n\n          // Calculate widths for each feature\n          const { array, legend, calculatedValues } = ColorWidthSymbologizer.getWidthsForDataColumn(\n            {\n              numFeatures: this.boundaries.length,\n              data: dataCol1,\n              data2: dataCol2,\n              lookup: lookup1,\n              lookup2: lookup2,\n              options: width,\n            }\n          )\n\n          this.dataLineWidths = array || 0\n          this.dataCalculatedValues = calculatedValues\n          this.dataCalculatedValueLabel = 'Diff: ' + columnName\n\n          this.legendStore.setLegendSection({\n            section: 'Line Width',\n            column: `${dataCol1.name} (Diff)`,\n            values: legend,\n          })\n        }\n      } else if (columnName) {\n        // Get the data column\n        const datasetKey = width.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        if (selectedDataset) {\n          const dataColumn = selectedDataset[columnName]\n          if (!dataColumn)\n            throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n          // Do we need a join? Join it\n          let dataJoinColumn = ''\n          if (width.join && width.join !== '@count') {\n            // join column name set by user\n            dataJoinColumn = width.join\n          } else if (width.join === '@count') {\n            // rowcount specified: join on the column name itself\n            dataJoinColumn = columnName\n          } else {\n            // nothing specified: let's hope they didn't want to join\n            if (this.datasetChoices.length > 1) {\n              console.warn('No join; lets hope user just wants to display data in boundary file')\n            }\n          }\n\n          this.setupJoin({\n            datasetId: datasetKey,\n            dataTable: selectedDataset,\n            dataJoinColumn,\n          })\n\n          const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n          // Calculate widths for each feature\n          const { array, legend, calculatedValues } = ColorWidthSymbologizer.getWidthsForDataColumn(\n            {\n              numFeatures: this.boundaries.length,\n              data: dataColumn,\n              lookup: lookupColumn,\n              join: width.join,\n              options: width,\n            }\n          )\n\n          this.dataLineWidths = array || 0\n          this.dataCalculatedValues = calculatedValues\n          this.dataCalculatedValueLabel = columnName\n\n          if (legend.length) {\n            this.legendStore.setLegendSection({\n              section: 'Line Width',\n              column: dataColumn.name,\n              values: legend,\n            })\n          } else {\n            this.legendStore.clear('Line Width')\n          }\n        }\n      } else {\n        // simple width\n\n        this.dataLineWidths = 1\n        this.dataCalculatedValueLabel = ''\n        this.legendStore.clear('Line Width')\n      }\n      // this.filterListener()\n    },\n\n    handleNewFillHeight(height: FillHeightDefinition) {\n      const columnName = height.columnName\n      if (columnName) {\n        // Get the data column\n        const datasetKey = height.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        if (selectedDataset) {\n          const dataColumn = selectedDataset[columnName]\n          if (!dataColumn)\n            throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n          // Do we need a join? Join it\n          let dataJoinColumn = ''\n          if (height.join && height.join !== '@count') {\n            // join column name set by user\n            dataJoinColumn = height.join\n          } else if (height.join === '@count') {\n            // rowcount specified: join on the column name itself\n            dataJoinColumn = columnName\n          } else {\n            // nothing specified: let's hope they didn't want to join\n            if (this.datasetChoices.length > 1) {\n              console.warn('No join; lets hope user just wants to display data in boundary file')\n            }\n          }\n\n          this.setupJoin({\n            datasetId: datasetKey,\n            dataTable: selectedDataset,\n            dataJoinColumn,\n          })\n\n          const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n          // Figure out the normal\n          let normalColumn\n          if (height.normalize) {\n            const keys = height.normalize.split(':')\n            // console.log({ keys, datasets: this.datasets })\n            if (!this.datasets[keys[0]] || !this.datasets[keys[0]][keys[1]])\n              throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n            normalColumn = this.datasets[keys[0]][keys[1]]\n            // console.log({ normalColumn })\n            this.dataCalculatedValueLabel = columnName + '/' + keys[1]\n          }\n\n          // Calculate for each feature\n          const { heights, calculatedValues, normalizedValues } =\n            ColorWidthSymbologizer.getHeightsBasedOnNumericValues({\n              length: this.boundaries.length,\n              data: dataColumn,\n              lookup: lookupColumn,\n              options: height,\n              normalize: normalColumn,\n              join: height.join,\n            })\n\n          this.dataFillHeights = heights\n          this.dataCalculatedValues = calculatedValues\n          this.dataNormalizedValues = normalizedValues || null\n          // this.dataCalculatedValueLabel = ''\n\n          if (this.$store.state.viewState.pitch == 0) {\n            const angledView = Object.assign({}, this.$store.state.viewState, {\n              pitch: 30,\n            })\n            this.$store.commit('setMapCamera', angledView)\n          }\n        }\n      } else {\n        // simple\n        this.dataFillHeights = 0\n        this.dataCalculatedValues = null\n        this.dataCalculatedValueLabel = ''\n      }\n    },\n\n    handleNewRadius(radiusOptions: CircleRadiusDefinition) {\n      const columnName = radiusOptions.columnName\n      if (columnName) {\n        // Get the data column\n        const datasetKey = radiusOptions.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n\n        // no selected dataset or datacol missing? Not sure what to do here, just give up...\n        if (!selectedDataset) {\n          console.warn('radius: no selected dataset yet, maybe still loading')\n          return\n        }\n\n        if (selectedDataset) {\n          const dataColumn = selectedDataset[columnName]\n          if (!dataColumn)\n            throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n          // Do we need a join? Join it\n          let dataJoinColumn = ''\n          if (radiusOptions.join && radiusOptions.join !== '@count') {\n            // join column name set by user\n            dataJoinColumn = radiusOptions.join\n          } else if (radiusOptions.join === '@count') {\n            // rowcount specified: join on the column name itself\n            dataJoinColumn = columnName\n          } else {\n            // nothing specified: let's hope they didn't want to join\n            if (this.datasetChoices.length > 1) {\n              console.warn('No join; lets hope user just wants to display data in boundary file')\n            }\n          }\n\n          this.setupJoin({\n            datasetId: datasetKey,\n            dataTable: selectedDataset,\n            dataJoinColumn,\n          })\n\n          const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n          // Calculate radius for each feature\n          const { radius, calculatedValues } = ColorWidthSymbologizer.getRadiusForDataColumn({\n            length: this.boundaries.length,\n            data: dataColumn,\n            lookup: lookupColumn,\n            join: dataJoinColumn,\n            options: radiusOptions,\n          })\n          this.dataPointRadii = radius\n          this.dataCalculatedValues = calculatedValues\n          this.dataCalculatedValueLabel = dataColumn.name\n        }\n      } else {\n        // simple width\n        this.dataPointRadii = 5\n      }\n\n      // this.filterListener()\n\n      // set features INSIDE react component\n      if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n        REACT_VIEW_HANDLES[1000 + this.layerId](\n          typeof this.dataPointRadii == 'number' ? this.boundaries : this.centroids\n        )\n      }\n    },\n\n    async handleMapClick(click: any) {\n      try {\n        const { x, y, data } = click.points[0]\n        const filter = this.config.groupBy\n        const value = x\n\n        // this.datamanager.setFilter(this.config.dataset, filter, value)\n      } catch (e) {\n        console.error(e)\n      }\n    },\n\n    async figureOutFeatureIdColumn() {\n      // if user specified it in a data join in the YAML, we're done\n      if (this.featureJoinColumn) return this.featureJoinColumn\n\n      // if user specified it in the shapefile yaml, we're done\n      if ('string' !== typeof this.vizDetails.shapes && this.vizDetails.shapes.join) {\n        // Special case for backwards compatibility with Avro networkd. In older avro networdk the join column was 'id' but the shapefile had 'linkId'\n        // TODO: check if the column id does not exist in the avro network\n        if (this.isAvroFile && this.vizDetails.shapes.join === 'id') {\n          return 'linkId'\n        }\n\n        return this.vizDetails.shapes.join\n      }\n\n      // if boundary features have 'id' outside of properties, we're done\n      if (this.boundaries.length && this.boundaries[0].id) return 'id'\n\n      if ('string' !== typeof this.vizDetails.shapes && this.vizDetails.shapes.join) {\n        return this.vizDetails.shapes.join\n      }\n\n      // if there's only one column, we're done\n      const featureDataset = this.datasets[Object.keys(this.datasets)[0]]\n      const availableColumns = Object.keys(featureDataset)\n      if (availableColumns.length === 1) return availableColumns[0]\n\n      // ask the user\n      const join: string = await new Promise((resolve, reject) => {\n        const boundaryProperties = new Set()\n        // Some geojsons have an 'id' separate from their property table\n        if (this.boundaries[0].id) boundaryProperties.add('id')\n        // Add list of boundary properties from feature dataset\n        Object.keys(featureDataset).forEach(key => boundaryProperties.add(key))\n\n        this.datasetJoinSelector = {\n          data1: { title: 'Properties', columns: Array.from(boundaryProperties) as string[] },\n        }\n        this.showJoiner = true\n\n        this.cbDatasetJoined = (join: string) => {\n          this.datasetJoinSelector = {}\n          this.showJoiner = false\n          resolve(join)\n        }\n      })\n\n      return join.length ? join : 'id'\n    },\n\n    async processFiltersNow(datasetName?: string) {\n      // This callback occurs when there is a newly filtered dataset.\n\n      console.log('> processFiltersNow', datasetName)\n\n      const { filteredRows } = this.myDataManager.getFilteredDataset({ dataset: datasetName || '' })\n      const filteredDataTable: { [id: string]: DataTableColumn } = {}\n\n      // if we got NULL, remove this filter totally\n      if (filteredRows) {\n        // turn array of objects into data columns for consumption by fill/line/height doodads\n        // (do this here... or should this be somewhere else?)\n\n        // CONVERT array of objects to column-based DataTableColumns\n        const allColumns = filteredRows.length > 0 ? Object.keys(filteredRows[0]) : []\n        allColumns.forEach(columnId => {\n          const column = { name: columnId, values: [], type: DataType.UNKNOWN } as any\n          for (const row of filteredRows) column.values.push(row[columnId])\n          filteredDataTable[columnId] = column\n        })\n\n        // TEMPORARY: filter out any shapes that do not pass the test.\n        // TODO: this will need to be revisited when we do layer-mode.\n        const lookups = this.getBoundaryOffsetLookup(this.featureJoinColumn)\n\n        // hide shapes not in filtered set\n        const hideBoundary = new Float32Array(this.boundaryFilters.length)\n        hideBoundary.fill(1)\n        for (const row of filteredRows) {\n          const joinText = row[this.featureJoinColumn]\n          const boundaryIndex = lookups[joinText]\n          hideBoundary[boundaryIndex] = 0 // keep this one\n        }\n        // merge new hide/show with existing hide/show\n        for (let i = 0; i < this.boundaryFilters.length; i++) {\n          if (hideBoundary[i]) this.boundaryFilters[i] = -1\n        }\n      }\n\n      try {\n        // now redraw colors for fills and liness\n        if (this.currentUIFillColorDefinitions?.dataset) {\n          this.handleNewFillColor(\n            filteredRows ? filteredDataTable : this.currentUIFillColorDefinitions\n          )\n        }\n\n        if (this.currentUILineColorDefinitions?.dataset) {\n          this.handleNewLineColor(\n            filteredRows ? filteredDataTable : this.currentUILineColorDefinitions\n          )\n        }\n      } catch (e) {\n        this.$emit('error', '' + e)\n      }\n    },\n\n    // ------------------------------------\n    // TODO do shapes later\n\n    // // hide shapes that don't match filter.\n    // const hideFeature = new Uint8Array(this.boundaries.length).fill(1) // hide by default\n    // filteredRows.forEach(row => {\n    //   const rowNumber = row['@']\n    //   hideFeature[rowNumber] = 0\n    // })\n    // const newFilter = new Float32Array(this.boundaries.length)\n    // for (let i = 0; i < this.boundaries.length; i++) {\n    //   if (this.boundaryFilters[i] == -1 || hideFeature[i]) newFilter[i] = -1\n    // }\n\n    // this.boundaryFilters = newFilter\n    // return\n\n    // ------------------------------------\n\n    // let groupLookup: any // this will be the map of boundary IDs to rows\n    // let groupIndex: any = 1 // unfiltered values will always be element 1 of [key, values[]]\n\n    // if (!filteredRows) {\n    //   // is filter UN-selected? Rebuild full dataset\n    //   // TODO: FIXME this is old ------:\n    //   // const joinCol = this.boundaryDataTable[this.datasetJoinColumn].values\n    //   // const dataValues = this.boundaryDataTable[this.datasetValuesColumn].values\n    //   // groupLookup = group(zip(joinCol, dataValues), d => d[0]) // group by join key\n    //   filteredRows = [] // get rid of this\n    // } else {\n    //   // group filtered values by lookup key\n    //   groupLookup = group(filteredRows, d => d[join[0]])\n    //   groupIndex = this.datasetValuesColumn // index is values column name\n    // }\n\n    // console.log({ groupLookup })\n\n    // // Build the filtered dataset columns\n    // const filteredDataset: DataTable = {}\n    // const columns = Object.keys(filteredRows[0])\n    // for (const column of columns) {\n    //   filteredDataset[column] = { name: column, values: [], type: DataType.NUMBER }\n    // }\n    // for (let i = 0; i < filteredRows.length; i++) {\n    //   for (const column of columns) {\n    //     filteredDataset[column].values[i] = filteredRows[i][column]\n    //   }\n    // }\n\n    // console.log({ filteredDataset })\n    // // ok we have a filter, let's update the geojson values\n    // this.setupJoin(filteredDataset, '_filter', join[0], join[1])\n\n    // // const filteredBoundaries = [] as any[]\n\n    //       this.boundaries.forEach(boundary => {\n    //         // id can be in root of feature, or in properties\n    //         let lookupKey = boundary.properties[joinShapesBy] || boundary[joinShapesBy]\n    //         if (!lookupKey) this.$emit('error', `Shape is missing property \"${joinShapesBy}\"`)\n\n    //         // the groupy thing doesn't auto-convert between strings and numbers\n    //         let row = groupLookup.get(lookupKey)\n    //         if (row == undefined) row = groupLookup.get('' + lookupKey)\n\n    //         // do we have an answer\n    //         boundary.properties.value = row ? sum(row.map((v: any) => v[groupIndex])) : 'N/A'\n    //         filteredBoundaries.push(boundary)\n    //       })\n\n    // // centroids\n    // const filteredCentroids = [] as any[]\n    // this.centroids.forEach(centroid => {\n    //   const centroidId = centroid.properties!.id\n    //   if (!centroidId) return\n\n    //   let row = groupLookup.get(centroidId)\n    //   if (row == undefined) row = groupLookup.get('' + centroidId)\n    //   centroid.properties!.value = row ? sum(row.map((v: any) => v[groupIndex])) : 'N/A'\n    //   filteredCentroids.push(centroid)\n    // })\n\n    // this.boundaries = filteredBoundaries\n    // this.centroids = filteredCentroids\n    // } catch (e) {\n    //   console.error('' + e)\n    // }\n\n    async loadAvroNetwork(filename: string) {\n      const path = `${this.subfolder}/${filename}`\n      const blob = await this.fileApi.getFileBlob(path)\n\n      const records: any[] = await new Promise((resolve, reject) => {\n        const rows = [] as any[]\n        avro\n          .createBlobDecoder(blob)\n          .on('metadata', (schema: any) => {})\n          .on('data', (row: any) => {\n            rows.push(row)\n          })\n          .on('end', () => {\n            resolve(rows)\n          })\n      })\n\n      const network = records[0]\n\n      // Build features with geometry, but no properties yet\n      // (properties get added in setFeaturePropertiesAsDataSource)\n      const numLinks = network.linkId.length\n      const features = [] as any\n      const crs = network.crs || 'EPSG:4326'\n      const needsProjection = crs !== 'EPSG:4326' && crs !== 'WGS84'\n\n      for (let i = 0; i < numLinks; i++) {\n        const linkID = network.linkId[i]\n        const fromOffset = 2 * network.from[i]\n        const toOffset = 2 * network.to[i]\n        let coordFrom = [\n          network.nodeCoordinates[fromOffset],\n          network.nodeCoordinates[1 + fromOffset],\n        ]\n        let coordTo = [network.nodeCoordinates[toOffset], network.nodeCoordinates[1 + toOffset]]\n        if (!coordFrom || !coordTo) continue\n\n        if (needsProjection) {\n          coordFrom = Coords.toLngLat(crs, coordFrom)\n          coordTo = Coords.toLngLat(crs, coordTo)\n        }\n\n        const coords = [coordFrom, coordTo]\n\n        const feature = {\n          id: linkID,\n          type: 'Feature',\n          properties: {},\n          geometry: { type: 'LineString', coordinates: coords },\n        }\n        features.push(feature)\n      }\n\n      this.avroNetwork = network\n      this.isAvroFile = true\n\n      return features\n    },\n\n    async loadXMLNetwork(filename: string): Promise<any> {\n      if (!this.myDataManager) throw Error('links: no datamanager')\n\n      this.statusText = 'Loading XML network...'\n\n      try {\n        const network = await this.myDataManager.getRoadNetwork(\n          filename,\n          this.subfolder,\n          this.vizDetails,\n          (message: string) => {\n            this.statusText = message\n          }\n        )\n        // for now convert to shapefile\n        const numLinks = network.source.length / 2\n        const boundaries = [] as any[]\n        for (let i = 0; i < numLinks; i++) {\n          const offset = i * 2\n          const feature = {\n            type: 'Feature',\n            id: network.linkIds[i],\n            properties: {},\n            geometry: {\n              type: 'LineString',\n              coordinates: [\n                [network.source[offset], network.source[offset + 1]],\n                [network.dest[offset], network.dest[offset + 1]],\n              ],\n            },\n          }\n          boundaries.push(feature)\n        }\n        return boundaries\n      } catch (e) {\n        console.error('' + e)\n      }\n    },\n\n    async loadBoundaries() {\n      let now = Date.now()\n\n      const shapeConfig =\n        this.config.boundaries || this.config.shapes || this.config.geojson || this.config.network\n\n      if (!shapeConfig) return\n\n      // shapes could be a string or an object: shape.file=blah\n      let filename: string = shapeConfig.file || shapeConfig\n\n      let featureProperties = [] as any[]\n      let boundaries: any[]\n\n      try {\n        this.statusText = 'Loading features...'\n\n        if (filename.startsWith('http')) {\n          // geojson from url!\n          boundaries = (await fetch(filename).then(async r => await r.json())).features\n        } else if (filename.toLocaleLowerCase().endsWith('.shp')) {\n          // shapefile!\n          boundaries = await this.loadShapefileFeatures(filename)\n        } else if (filename.toLocaleLowerCase().indexOf('.xml') > -1) {\n          // MATSim XML Network\n          boundaries = await this.loadXMLNetwork(filename)\n          console.log(777, { boundaries })\n        } else if (filename.toLocaleLowerCase().includes('network.avro')) {\n          // avro network!\n          boundaries = await this.loadAvroNetwork(filename)\n        } else {\n          // geojson!\n          boundaries = (await this.fileApi.getFileJson(`${this.subfolder}/${filename}`)).features\n        }\n\n        this.statusText = 'Processing data...'\n        await this.$nextTick()\n\n        // for a big speedup, move properties to its own nabob\n        let hasNoLines = true\n        let hasNoPolygons = true\n        let hasPoints = false\n\n        boundaries.forEach(b => {\n          const properties = b.properties ?? {}\n          // geojson sometimes has \"id\" outside of properties:\n          if ('id' in b) properties.id = b.id\n          // create a new properties object for each row;\n          // push this new property object to the featureProperties array\n          featureProperties.push({ ...properties })\n          // clear out actual feature properties; they are now in featureProperties instead\n          b.properties = {}\n\n          // points?\n          if (b.geometry.type == 'Point' || b.geometry.type == 'MultiPoint') {\n            hasPoints = true\n          }\n\n          // check if we have linestrings: network mode !\n          if (\n            hasNoLines &&\n            (b.geometry.type == 'LineString' || b.geometry.type == 'MultiLineString')\n          ) {\n            hasNoLines = false\n          }\n\n          // check if we have polygons: area-map mode !\n          if (\n            hasNoPolygons &&\n            (b.geometry.type == 'Polygon' || b.geometry.type == 'MultiPolygon')\n          ) {\n            hasNoPolygons = false\n          }\n        })\n\n        this.moveLogo()\n\n        // set feature properties as a data source\n        await this.setFeaturePropertiesAsDataSource(filename, [...featureProperties], shapeConfig)\n\n        // turn ON line borders if it's a SMALL dataset (user can re-enable)\n        if (!hasNoLines || boundaries.length < 5000) {\n          this.dataLineColors = '#4e79a7'\n        }\n\n        // hide polygon/point buttons and opacity if we have no polygons or we do have points\n        if (hasNoPolygons) this.isAreaMode = false\n        if (hasPoints) this.isAreaMode = true\n\n        this.boundaries = boundaries\n\n        // generate centroids if we have polygons\n        if (!hasNoPolygons || hasPoints) {\n          await this.generateCentroidsAndMapCenter()\n        } else if (this.needsInitialMapExtent) {\n          this.calculateAndMoveToCenter()\n        }\n\n        // Need to wait one tick so Vue inserts the Deck.gl view AFTER center is calculated\n        // (not everyone lives in Berlin)\n        await this.$nextTick()\n\n        // set features INSIDE react component\n        if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n          REACT_VIEW_HANDLES[1000 + this.layerId](this.boundaries)\n        }\n      } catch (e) {\n        const err = e as any\n        const message = err.statusText || 'Could not load'\n        const fullError = `${message}: \"${filename}\"`\n\n        this.statusText = ''\n        this.$emit('isLoaded')\n\n        throw Error(fullError)\n      }\n\n      if (!this.boundaries) throw Error(`No \"features\" found in shapes file`)\n    },\n\n    async setFeaturePropertiesAsDataSource(\n      filename: string,\n      featureProperties: any[],\n      config: any\n    ) {\n      let dataTable\n\n      if (this.avroNetwork) {\n        // AVRO\n        // create the DataTable right here, we already have everything in memory\n        const avroTable: DataTable = {}\n\n        const columns = this.avroNetwork.linkAttributes as string[]\n        columns.sort()\n\n        for (const colName of columns) {\n          const values = this.avroNetwork[colName]\n          const type =\n            Number.isFinite(values[0]) || Number.isNaN(values[0])\n              ? DataType.NUMBER\n              : DataType.STRING\n          const dataColumn: DataTableColumn = {\n            name: colName,\n            values,\n            type,\n          }\n          avroTable[colName] = dataColumn\n        }\n\n        // special case: allowedModes\n        const modeLookup = this.avroNetwork['modes']\n        const allowedModes = avroTable['allowedModes']\n        allowedModes.type = DataType.STRING\n        allowedModes.values = allowedModes.values.map((v: number) => modeLookup[v])\n\n        dataTable = await this.myDataManager.setRowWisePropertyTable(filename, avroTable, config)\n        // save memory: no longer need the avro input file\n        this.avroNetwork = null\n      } else {\n        // NON-AVRO\n        dataTable = await this.myDataManager.setFeatureProperties(\n          filename,\n          featureProperties,\n          config\n        )\n      }\n      this.boundaryDataTable = dataTable\n\n      const datasetId = filename.substring(1 + filename.lastIndexOf('/'))\n      this.datasets[datasetId] = dataTable\n\n      this.vizDetails.datasets[datasetId] = {\n        file: datasetId,\n        join: this.datasetJoinColumn,\n      } as any\n\n      this.config.datasets = Object.assign({}, this.vizDetails.datasets)\n\n      // this.myDataManager.addFilterListener({ dataset: datasetId }, this.filterListener)\n      // this.figureOutRemainingFilteringOptions()\n    },\n\n    async calculateAndMoveToCenter() {\n      let centerLong = 0\n      let centerLat = 0\n      let numCoords = 0\n      const numFeatures = this.boundaries.length\n\n      for (let idx = 0; idx < numFeatures; idx += 256) {\n        const centroid = turf.centerOfMass(this.boundaries[idx])\n        if (centroid?.geometry?.coordinates) {\n          centerLong += centroid.geometry.coordinates[0]\n          centerLat += centroid.geometry.coordinates[1]\n          numCoords += 1\n        }\n      }\n\n      centerLong /= numCoords\n      centerLat /= numCoords\n\n      console.log('CENTER', centerLong, centerLat)\n      if (this.needsInitialMapExtent && !this.vizDetails.center) {\n        this.$store.commit('setMapCamera', {\n          longitude: centerLong,\n          latitude: centerLat,\n          center: [centerLong, centerLat],\n          bearing: 0,\n          pitch: 0,\n          zoom: 9,\n          initial: true,\n        })\n        this.needsInitialMapExtent = false\n      }\n    },\n\n    async generateCentroidsAndMapCenter() {\n      this.statusText = 'Calculating centroids...'\n      await this.$nextTick()\n      const idField = this.config.shapes.join || 'id'\n\n      // Find the map center while we're here\n      let centerLong = 0\n      let centerLat = 0\n      let count = 0\n\n      for (const feature of this.boundaries) {\n        let centroid = {} as any\n        try {\n          centroid = turf.centerOfMass(feature as any)\n        } catch (e) {\n          console.warn('no coordinates:')\n          console.warn(feature)\n          continue\n        }\n\n        if (!centroid.properties) centroid.properties = {}\n\n        if (feature.properties[this.config.boundariesLabel]) {\n          centroid.properties.label = feature.properties[this.config.boundariesLabel]\n        }\n\n        centroid.properties.id = feature.properties[idField]\n        if (centroid.properties.id === undefined) centroid.properties.id = feature[idField]\n\n        this.centroids.push(centroid)\n\n        if (centroid.geometry) {\n          centerLong += centroid.geometry.coordinates[0]\n          centerLat += centroid.geometry.coordinates[1]\n          count++\n        }\n      }\n\n      centerLong /= count\n      centerLat /= count\n\n      console.log('CENTER', centerLong, centerLat)\n      if (this.needsInitialMapExtent && !this.vizDetails.center) {\n        this.$store.commit('setMapCamera', {\n          longitude: centerLong,\n          latitude: centerLat,\n          center: [centerLong, centerLat],\n          bearing: 0,\n          pitch: 0,\n          zoom: 9,\n          initial: true,\n        })\n        this.needsInitialMapExtent = false\n      }\n    },\n\n    async loadShapefileFeatures(filename: string) {\n      this.statusText = 'Loading shapefile...'\n      console.log('loading', filename)\n\n      const url = `${this.subfolder}/${filename}`\n      let shpPromise, dbfPromise, dbfBlob\n\n      // first, get shp/dbf files\n      let geojson: any = {}\n      try {\n        shpPromise = await this.fileApi.getFileBlob(url)\n      } catch (e) {\n        this.$emit('error', 'Error loading ' + url)\n        return []\n      }\n\n      try {\n        const dbfFilename = url\n          .replace('.shp', '.dbf')\n          .replace('.SHP', '.DBF')\n          .replace('.Shp', '.Dbf')\n        dbfPromise = await this.fileApi.getFileBlob(dbfFilename)\n        dbfBlob = await (await dbfPromise)?.arrayBuffer()\n      } catch {\n        // no DBF: we will live\n      }\n\n      try {\n        const shpBlob = await (await shpPromise)?.arrayBuffer()\n        if (!shpBlob) return []\n\n        this.statusText = 'Generating shapes...'\n\n        geojson = await shapefile.read(shpBlob, dbfBlob)\n\n        // filter out features that don't have geometry: they can't be mapped\n        geojson.features = geojson.features.filter((f: any) => !!f.geometry)\n        this.statusText = ''\n      } catch (e) {\n        console.error(e)\n        this.$emit('error', `Error loading shapefile ${url}`)\n        return []\n      }\n\n      // geojson.features = geojson.features.slice(0, 10000)\n\n      // See if there is a .prj file with projection information\n      let projection = DEFAULT_PROJECTION\n      const prjFilename = url\n        .replace('.shp', '.prj')\n        .replace('.SHP', '.PRJ')\n        .replace('.Shp', '.Prj')\n      try {\n        projection = await this.fileApi.getFileText(prjFilename)\n      } catch (e) {\n        console.error('' + e)\n        // lol we can live without a projection right? ;-O\n      }\n\n      // Allow user to override .PRJ projection with YAML config\n      const guessCRS = this.vizDetails.projection || Coords.guessProjection(projection)\n\n      console.log({ guessCRS })\n      // then, reproject if we have a .prj file\n      if (guessCRS) {\n        this.statusText = 'Projecting coordinates...'\n        await this.$nextTick()\n        geojson = reproject.toWgs84(geojson, guessCRS, Coords.allEPSGs)\n        this.statusText = ''\n      }\n\n      function getFirstPoint(thing: any): any[] {\n        if (Array.isArray(thing[0])) return getFirstPoint(thing[0])\n        else return [thing[0], thing[1]]\n      }\n\n      // check if we have lon/lat\n      const firstPoint = getFirstPoint(geojson.features[0].geometry.coordinates)\n      if (Math.abs(firstPoint[0]) > 180 || Math.abs(firstPoint[1]) > 90) {\n        // this ain't lon/lat\n        const msg = `Coordinates not lon/lat. Try adding projection to YAML, or provide ${prjFilename.substring(\n          1 + prjFilename.lastIndexOf('/')\n        )}`\n        this.$emit('error', msg)\n        this.statusText = ''\n        return []\n      }\n\n      // if (this.needsInitialMapExtent && !this.$store.state.viewState.latitude) {\n      if (true) {\n        // if we don't have a user-specified map center/zoom, focus on the shapefile itself\n\n        const long = []\n        const lat = []\n        for (let i = 0; i < geojson.features.length; i += 128) {\n          const firstPoint = getFirstPoint(geojson.features[i].geometry.coordinates)\n          long.push(firstPoint[0])\n          lat.push(firstPoint[1])\n        }\n        const longitude = long.reduce((x, y) => x + y) / long.length\n        const latitude = lat.reduce((x, y) => x + y) / lat.length\n\n        this.$store.commit('setMapCamera', {\n          longitude,\n          latitude,\n          bearing: 0,\n          pitch: 0,\n          zoom: 9,\n          center: [longitude, latitude],\n          initial: true,\n        })\n      }\n\n      this.needsInitialMapExtent = false\n      return geojson.features as any[]\n    },\n\n    async loadDatasets() {\n      const keys = Object.keys(this.vizDetails.datasets)\n      for (const key of keys) {\n        // don't reload datasets we already loaded\n        if (key in this.datasets) continue\n\n        await this.loadDataset(key)\n      }\n    },\n\n    async loadDataset(datasetKey: string) {\n      try {\n        if (!datasetKey) return\n\n        // dataset could be  { dataset: myfile.csv }\n        //               or  { dataset: { file: myfile.csv, join: TAZ }}\n        const datasetFilename =\n          'string' === typeof this.config.datasets[datasetKey]\n            ? this.config.datasets[datasetKey]\n            : this.config.datasets[datasetKey].file\n\n        this.statusText = `Loading dataset ${datasetFilename} ...`\n\n        await this.$nextTick()\n\n        let loaderConfig = { dataset: datasetFilename }\n        if ('string' !== typeof this.config.datasets[datasetKey]) {\n          loaderConfig = Object.assign(loaderConfig, this.config.datasets[datasetKey])\n        }\n\n        // save the filename and key for later lookups\n        this.datasetKeyToFilename[datasetKey] = datasetFilename\n\n        const dataset = await this.myDataManager.getDataset(loaderConfig)\n\n        // figure out join - use \".join\" or first column key\n        const joiner =\n          'string' === typeof this.config.datasets[datasetKey]\n            ? Object.keys(dataset.allRows)[0]\n            : this.config.datasets[datasetKey].join\n\n        const joinColumns = joiner?.split(':') || []\n\n        // if join is oldstyle \"dataCol:FeatureID\" the set the featureCol\n        if (joinColumns.length == 2) this.featureJoinColumn = joinColumns[0]\n        // TODO if join is one column then really we should just ignore it but for now...\n        if (joinColumns.length == 1) joinColumns.push(joinColumns[0])\n\n        // save it!\n        this.datasets[datasetKey] = dataset.allRows\n\n        await this.$nextTick()\n\n        // Set up filters -- there could be some in YAML already\n        this.myDataManager.addFilterListener({ dataset: datasetFilename }, this.processFiltersNow)\n        this.activateFiltersForDataset(datasetKey)\n        // this.handleNewFilters(this.vizDetails.filters)\n      } catch (e) {\n        const msg = '' + e\n        console.error(msg)\n        this.$emit('error', msg)\n      }\n      return []\n    },\n\n    async activateFiltersForDataset(datasetKey: string) {\n      const filters = this.filterDefinitions.filter(f => f.dataset === datasetKey)\n\n      for (const filter of filters) {\n        // if user selected a @categorical, just add it to the thingy\n        if (filter.value == '@categorical') {\n          if (this.filters[filter.column]) {\n            filter.value = this.filters[filter.column].active\n          } else {\n            this.handleUserCreatedNewFilter(`${datasetKey}:${filter.column}`)\n          }\n        } else {\n          // actually filter the data\n          try {\n            await this.myDataManager.setFilter(\n              Object.assign(filter, { dataset: this.datasetKeyToFilename[datasetKey] })\n            )\n          } catch (e) {\n            this.$emit('error', `Filter ${datasetKey}.${filter.column}: ` + e)\n          }\n        }\n      }\n    },\n\n    filterLabel(filter: string) {\n      let label = this.filters[filter].active.join(',').substring(0, 50) || 'Select...'\n      if (label.length === 50) label += '...'\n      return label\n    },\n\n    async handleUserSelectedNewMetric() {\n      // console.log('> handleUserSelectedNewMetric')\n      await this.$nextTick()\n      console.log('METRIC', this.datasetValuesColumn)\n\n      const query = Object.assign({}, this.$route.query)\n      query.display = this.datasetValuesColumn\n      this.$router.replace({ query })\n\n      this.maxValue = this.boundaryDataTable[this.datasetValuesColumn].max || 0\n      // console.log('MAXVALUE', this.maxValue)\n\n      this.vizDetails.display.fill.columnName = this.datasetValuesColumn\n      this.vizDetails = Object.assign({}, this.vizDetails)\n      this.processFiltersNow()\n    },\n\n    handleUserSelectedNewFilters(column: string) {\n      const filter = this.filters[column]\n      const active = filter.active\n\n      this.myDataManager.setFilter({\n        dataset: this.datasetKeyToFilename[filter.dataset], // || datasetFilename,\n        column,\n        invert: false,\n        value: active, // '', // <-- what should this be?\n      })\n\n      // update URL too\n      const queryFilters = Object.assign({}, this.$route.query)\n      for (const filter of Object.entries(this.filters)) {\n        if (filter[1].active.length) {\n          queryFilters[filter[0]] = filter[1].active.join(',')\n        } else {\n          delete queryFilters[filter[0]]\n        }\n      }\n      // only update if query actually changed\n      if (JSON.stringify(this.$route.query) !== JSON.stringify(queryFilters)) {\n        this.$router.replace({ query: queryFilters })\n      }\n    },\n\n    showCircles(show: boolean) {\n      this.useCircles = show\n\n      const query = Object.assign({}, this.$route.query)\n      if (show) query.show = 'dots'\n      else delete query.show\n      this.$router.replace({ query })\n    },\n\n    handleUserCreatedNewFilter(selectedColumn?: string) {\n      const selection = selectedColumn || this.chosenNewFilterColumn\n      const [dataset, column] = selection.split(':')\n\n      let options = [...new Set(this.datasets[dataset][column].values)]\n      this.chosenNewFilterColumn = ''\n\n      if (options.length > 48) {\n        alert(`Column ${column} has too many values to be used as a filter.`)\n        return\n      }\n      this.filters[column] = { column, label: column, options, active: [], dataset }\n    },\n\n    updateChart() {\n      // boundaryDataTable come back as an object of columnName: values[].\n      // We need to make a lookup of the values by ID, and then\n      // insert those values into the boundaries geojson.\n\n      // console.log(this.config)\n      // console.log(this.datasets)\n      if (!this.config.display || !this.config.datasets) return\n\n      let joinShapesBy = 'linkId'\n\n      if (this.config.shapes?.join) joinShapesBy = this.config.shapes.join\n      // throw Error('Need \"join\" property to link shapes to datasets')\n\n      const datasetJoinCol = this.datasetJoinColumn // used to be this.config.display.fill.join\n      if (!datasetJoinCol) {\n        console.error(`No join column ${datasetJoinCol}`)\n        return\n      }\n\n      // value columns should be an array but might not be there yet\n      let valueColumns = this.config.display.fill.values\n      if (!valueColumns) {\n        this.statusText = ''\n        throw Error(`Need to specify column for data values`)\n      }\n\n      // Display values from query param if available, or config, or first option.\n      if (this.$route.query.display) this.config.display.fill.columnName = this.$route.query.display\n      let datasetValuesCol = this.config.display.fill.columnName || valueColumns[0]\n\n      this.datasetValuesColumn = datasetValuesCol\n      // this.datasetValuesColumnOptions = valueColumns\n\n      // this.setupFilters()\n\n      // 1. build the data lookup for each key in the dataset.\n      //    There is often more than one row per key, so we will\n      //    create an array for the group now, and (sum) them in step 2 below\n      const joinCol = this.boundaryDataTable[datasetJoinCol].values\n      const dataValues = this.boundaryDataTable[datasetValuesCol].values\n      const groupLookup = group(zip(joinCol, dataValues), d => d[0]) // group by join key\n\n      let max = 0\n\n      // 2. insert values into geojson\n      for (let idx = 0; idx < this.boundaries.length; idx++) {\n        const boundary = this.boundaries[idx]\n        const centroid = this.centroids[idx]\n\n        // id can be in root of feature, or in properties\n        let lookupValue = boundary[joinShapesBy]\n        if (lookupValue == undefined) lookupValue = boundary.properties[joinShapesBy]\n\n        if (lookupValue === undefined) {\n          this.$emit('error', `Shape is missing property \"${joinShapesBy}\"`)\n        }\n\n        // SUM the values of the second elements of the zips from (1) above\n        const row = groupLookup.get(lookupValue)\n        if (row) {\n          boundary.properties.value = sum(row.map(v => v[1]))\n          max = Math.max(max, boundary.properties.value)\n        } else {\n          boundary.properties.value = 'N/A'\n        }\n\n        // update the centroid too\n        if (centroid) centroid.properties!.value = boundary.properties.value\n      }\n\n      // this.maxValue = max // this.boundaryDataTable[datasetValuesCol].max || 0\n      this.maxValue = this.boundaryDataTable[datasetValuesCol].max || 0\n\n      // // 3. insert values into centroids\n      // this.centroids.forEach(centroid => {\n      //   const centroidId = centroid.properties!.id\n      //   if (!centroidId) return\n\n      //   let row = groupLookup.get(centroidId)\n      //   if (row === undefined) row = groupLookup.get(parseInt(centroidId))\n      //   centroid.properties!.value = row ? sum(row.map(v => v[1])) : 'N/A'\n      // })\n\n      // sort them so big bubbles are below small bubbles\n      this.centroids = this.centroids.sort((a: any, b: any) =>\n        a.properties.value > b.properties.value ? -1 : 1\n      )\n      this.activeColumn = 'value'\n    },\n\n    clearData() {\n      // these lines change the properties of these objects\n      // WITHOUT reassigning them to new objects; this is\n      // essential for the garbage-collection to work properly.\n      // Otherwise we get a 500Mb memory leak on every view :-D\n      this.boundaries = []\n      this.centroids = []\n      this.boundaryDataTable = {}\n      this.boundaryFilters = new Float32Array(0)\n      this.datasets = {}\n      this.dataFillColors = '#888'\n      this.dataLineColors = ''\n      this.dataLineWidths = 1\n      this.dataPointRadii = 5\n      this.dataFillHeights = 0\n      this.dataCalculatedValues = null\n      this.dataCalculatedValueLabel = ''\n      this.bgLayers = {}\n    },\n\n    updateBgLayers() {\n      this.bgLayers = { ...this.bgLayers }\n    },\n\n    async loadBackgroundLayers() {\n      this.bgLayers = {}\n\n      if (!this.vizDetails.backgroundLayers) {\n        this.vizDetails.backgroundLayers = {}\n        return\n      }\n\n      for (const layerName of Object.keys(this.vizDetails.backgroundLayers)) {\n        try {\n          console.log('LOADING', layerName)\n          const layerDetails = this.vizDetails.backgroundLayers[layerName]\n\n          if (!layerDetails.shapes) continue\n\n          let features = [] as any[]\n          try {\n            // load boundaries ---\n            const filename = layerDetails.shapes\n            if (filename.startsWith('http'))\n              features = (await fetch(filename).then(async r => await r.json())).features\n            else if (filename.toLocaleLowerCase().endsWith('.shp'))\n              features = await this.loadShapefileFeatures(filename)\n            else\n              features = (await this.fileApi.getFileJson(`${this.subfolder}/${filename}`)).features\n          } catch (e) {\n            console.error('' + e)\n          }\n\n          // Fill colors ---\n          let colors = null as any\n          if (layerDetails.fill && !layerDetails.fill.startsWith('#')) {\n            const whichScale = layerDetails.fill.startsWith('scheme')\n              ? layerDetails.fill\n              : `interpolate${layerDetails.fill}`\n            // @ts-ignore\n            const scale = d3ScaleChromatic[whichScale]\n            if (scale) {\n              const ramp = scaleSequential(scale)\n              colors = Array.from({ length: features.length }, (_, i) => {\n                const c = rgb(ramp(i / features.length - 1))\n                return [c.r, c.g, c.b]\n              })\n            }\n          }\n\n          for (let i = 0; i < features.length; i++) {\n            const feature = features[i]\n            let __fill__ = [64, 64, 192]\n            if (layerDetails.fill) {\n              if (layerDetails.fill.startsWith('#')) {\n                __fill__ = buildRGBfromHexCodes([layerDetails.fill])[0]\n              } else if (colors) {\n                __fill__ = colors[i]\n              }\n            }\n            feature.properties.__fill__ = __fill__\n          }\n\n          // Text labels ---\n          if (layerDetails.label) {\n            const labels = [] as any\n            for (const feature of features) {\n              const centroid = turf.centerOfMass(feature)\n              if (!centroid.properties) centroid.properties = {}\n              centroid.properties.label = feature.properties[layerDetails.label]\n              labels.push(centroid)\n            }\n            features = features.concat(labels)\n          }\n\n          // borders ---\n          const borderColor = layerDetails.borderColor\n            ? buildRGBfromHexCodes([layerDetails.borderColor])[0]\n            : [255, 255, 255]\n          const borderWidth = 'borderWidth' in layerDetails ? parseInt(layerDetails.borderWidth) : 0\n          const opacity = layerDetails.opacity || 0.25\n\n          let visible = true\n          if ('visible' in layerDetails) visible = layerDetails.visible\n          let onTop = false\n          if ('onTop' in layerDetails) onTop = !!layerDetails.onTop\n\n          console.log('FINAL FEATURES', features)\n\n          const details = {\n            features,\n            opacity,\n            borderWidth,\n            borderColor,\n            visible,\n            onTop,\n          }\n          this.bgLayers[layerName] = details\n        } catch (e) {\n          console.error('' + e)\n        }\n      }\n      this.redraw += 1\n    },\n  },\n\n  async mounted() {\n    try {\n      // EMBED MODE?\n      this.setEmbeddedMode()\n\n      this.clearData()\n\n      await this.getVizDetails()\n\n      if (this.vizDetails.center && typeof this.vizDetails.center === 'string') {\n        this.vizDetails.center = this.vizDetails.center\n          //@ts-ignore\n          .split(',')\n          .map((coord: any) => parseFloat(coord))\n        this.config.center = this.config.center.split(',').map((coord: any) => parseFloat(coord))\n      }\n\n      this.buildThumbnail()\n      if (this.thumbnail) return\n\n      this.buildOldJoinLookups()\n\n      this.filterDefinitions = this.parseFilterDefinitions(this.vizDetails.filters)\n\n      this.setupLogoMover()\n\n      if (this.needsInitialMapExtent && this.vizDetails.center) {\n        this.$store.commit('setMapCamera', {\n          center: this.vizDetails.center,\n          zoom: this.vizDetails.zoom || 9,\n          bearing: this.vizDetails.bearing || 0,\n          pitch: this.vizDetails.pitch || 0,\n          longitude: this.vizDetails.center ? this.vizDetails.center[0] : 0,\n          latitude: this.vizDetails.center ? this.vizDetails.center[1] : 0,\n          initial: true,\n        })\n        this.needsInitialMapExtent = false\n      }\n\n      this.expColors = this.config.display?.fill?.exponentColors\n      this.dataFillColors = globalStore.state.isDarkMode ? '#44445580' : '#dddddd80'\n\n      // convert values to arrays as needed\n      if (!this.config.display.fill) this.config.display.fill = {}\n\n      if (this.config.display?.fill?.values) {\n        this.config.display.fill.values = this.convertCommasToArray(this.config.display.fill.values)\n      }\n\n      // load the boundaries first, then the dataset.\n      // Need boundaries first so we can build the lookups!\n      await this.loadBoundaries()\n      this.filterShapesNow()\n\n      this.isLoaded = true\n      this.$emit('isLoaded')\n\n      await this.loadDatasets()\n\n      // Check URL query parameters\n\n      this.datasets = Object.assign({}, this.datasets)\n      this.config.datasets = JSON.parse(JSON.stringify(this.datasets))\n      this.vizDetails = Object.assign({}, this.vizDetails)\n\n      this.honorQueryParameters()\n\n      this.statusText = ''\n\n      // Ask for shapes feature ID if it's not obvious/specified already\n      this.featureJoinColumn = await this.figureOutFeatureIdColumn()\n\n      this.loadBackgroundLayers()\n    } catch (e) {\n      this.$emit('error', '' + e)\n      this.statusText = ''\n      this.$emit('isLoaded')\n    }\n  },\n\n  beforeDestroy() {\n    // MUST delete the React view handles to prevent gigantic memory leaks!\n    delete REACT_VIEW_HANDLES[this.layerId]\n\n    if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n      REACT_VIEW_HANDLES[1000 + this.layerId]([])\n      delete REACT_VIEW_HANDLES[1000 + this.layerId]\n    }\n\n    this.clearData()\n    this.legendStore.clear()\n    this.resizer?.disconnect()\n\n    this.myDataManager.removeFilterListener(this.config, this.processFiltersNow)\n    // this.myDataManager.clearCache()\n    this.$store.commit('setFullScreen', false)\n  },\n})\n\nexport default MyComponent\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n.shapefile-viewer {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.main-layout {\n  display: grid;\n  // one unit, full height/width. Layers will go on top:\n  grid-template-rows: 1fr;\n  grid-template-columns: 1fr auto auto;\n  min-height: $thumbnailHeight;\n  height: 100%;\n}\n\n.map-layout.hide-thumbnail {\n  background: unset;\n  z-index: 0;\n}\n\n.area-map {\n  grid-row: 1 / 2;\n  grid-column: 1 / 2;\n  background-color: var(--bgBold);\n  position: relative;\n}\n\n.map-layers {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.dragger {\n  grid-row: 1 / 2;\n  grid-column: 2 / 3;\n  width: 0.5rem;\n  background-color: var(--bgCardFrame);\n  user-select: none;\n}\n\n.dragger:hover,\n.dragger:active {\n  background-color: var(--sliderThumb);\n  transition: background-color 0.3s ease;\n  transition-delay: 0.2s;\n  cursor: ew-resize;\n}\n\n.new-rightside-info-panel {\n  grid-row: 1 / 2;\n  grid-column: 3 / 4;\n  display: flex;\n  flex-direction: column;\n  background-color: var(--bgCardFrame);\n  position: relative;\n\n  .legend-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    display: flex;\n    flex-direction: column;\n    background-color: var(--bgCardFrame);\n\n    .description {\n      margin-top: 0.5rem;\n    }\n  }\n\n  .tooltip-html {\n    font-size: 0.8rem;\n    padding: 0.25rem;\n    text-align: left;\n    background-color: var(--bgCardFrame);\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    border-top: 1px solid #88888880;\n  }\n}\n\n.config-bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-direction: row;\n  margin: 0.5rem;\n  padding: 0.25rem 0rem 0.5rem 0.5rem;\n  background-color: var(--bgPanel);\n  z-index: 9;\n  opacity: 0.93;\n  input.slider {\n    margin: auto 0 0.5rem auto;\n    width: 8rem;\n  }\n\n  .map-type-buttons {\n    margin: auto 0 0 0.5rem;\n  }\n\n  .img-button {\n    margin: 0 0rem -5px 0.5rem;\n    height: 2.3rem;\n    width: 2.3rem;\n    border: var(--borderThin);\n    border-radius: 4px;\n  }\n  .img-button:hover {\n    border: 2px solid var(--linkHover);\n  }\n}\n\n.config-bar.is-disabled {\n  pointer-events: none;\n  opacity: 0.5;\n}\n\n.bglayer-section {\n  display: flex;\n  flex-direction: column;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-color: var(--bgPanel);\n  width: min-content;\n}\n\n.filter {\n  margin-right: 0.5rem;\n  display: flex;\n  flex-direction: column;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.filter p {\n  margin: -0.25rem 0 0 0;\n  font-weight: bold;\n}\n\n.title-panel {\n  position: absolute;\n  top: 0;\n  left: 0;\n  padding: 0 1rem 0.25rem 2rem;\n  background-color: var(--bgPanel);\n  filter: $filterShadow;\n  z-index: 2;\n}\n\n.status-bar {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  z-index: 200;\n  background-color: var(--bgPanel2);\n  padding: 1rem 1rem;\n  font-size: 1.1rem;\n  margin-bottom: 6px;\n  border: 1px solid var(--);\n}\n\n.right {\n  margin-left: auto;\n}\n\n.details-panel {\n  position: absolute;\n  bottom: 0;\n  right: 20rem;\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n  margin: 0.5rem;\n  font-size: 0.8rem;\n  color: var(--bold);\n  opacity: 0.95;\n  max-height: 75%;\n  overflow-x: hidden;\n  overflow-y: auto;\n  white-space: nowrap;\n}\n\n.simple-checkbox {\n  padding: 0.25rem;\n}\n\n.simple-checkbox:hover {\n  color: unset;\n}\n</style>\n"],"names":["isHighSurrogate","codePoint","isLowSurrogate","truncate","getLength","string","byteLength","charLength","curByteLength","segment","i","browser","prevCodePoint","require$$0","require$$1","illegalRe","controlRe","reservedRe","windowsReservedRe","windowsTrailingRe","sanitize","input","replacement","sanitized","sanitizeFilename","options","output","Component","viewId","fillColors","lineColors","lineWidths","fillHeights","opacity","pointRadii","screenshot","redraw","featureFilter","cbTooltip","bgLayers","handleClickEvent","highlightedLinkIndex","features","setFeatures","useState","viewState","setViewState","globalStore","screenshotCount","setScreenshot","_mapRef","useRef","REACT_VIEW_HANDLES","fullCopy","feature","f","isTakingScreenshot","cbFillColor","color","rgb","o","isStroked","cbLineColor","_","cbLineWidth","cbPointRadius","cbFillHeight","handleViewState","view","handleClick","event","getTooltip","object","index","backgroundLayers","onTopLayers","name","layerDetails","bgLayer","GeoJsonLayer","d","mainLayer","GeojsonOffsetLayer","OFFSET_DIRECTION","DataFilterExtension","deckInstance","React","DeckGL","e","isDragging","isHovering","screenshots","_a","StaticMap","MAPBOX_TOKEN","MyComponent","defineComponent","BackgroundMapOnTop","LegendBox","GeojsonLayer","ModalIdColumnPicker","VizConfigurator","ZoomButtons","DrawingTool","LegendStore","DashboardDataManager","HTTPFileSystem","svnProject","a","filename","Sanitize","p","tooltips","deltaX","deckmap","logo","right","datasetId","data","shapeFilters","isLTGT","filter","spec","conditional","v","numericString","fullSpecification","dataColumnValues","checkFilterValue","value","precision","printValue","forceUpdate","PRECISION","propList","label","cLabel","datasetProps","featureTips","tipKey","tipValue","columns","_b","tip","featureProps","column","html","actualValue","includeElement","filterValue","filterDefs","filters","filterSpecs","id","dataset","filterDefinition","datasetKeys","firstDatasetKey","firstDataset","columnNames","queryFilters","text","thing","emptyState","ycfg","title","oldJoinFieldPerDataset","join","colon","shapeJoinField","section","details","blob","buffer","readBlob","base64","arrayBufferToBase64","config","YAML","err","message","vizes","props","layers","layer","key","dataTable","datasetFilename","dataJoinColumn","lookupColumn","DataType","lookupValues","boundaryOffsets","featureOffset","relevantTips","joinColumn","boundaryLookupColumnValues","oldFilters","deletedFilter","dot","query","newDefinitions","datasetKey","columnName","key1","dataset1","key2","dataset2","relative","lookup1","lookup2","dataCol1","dataCol2","normalColumn","normalLookup","ramp","_c","_d","_e","rgbArray","legend","calculatedValues","ColorWidthSymbologizer","currentDefinition","keys","fillOrFilteredDataTable","isFillColorDefinition","isFilterTable","filteredRows","selectedDataset","dataColumn","colorOrFilteredDataTable","isColorDefinition","result","lineWidth","variableConstantWidth","width","array","height","heights","normalizedValues","angledView","radiusOptions","radius","click","x","y","featureDataset","availableColumns","resolve","reject","boundaryProperties","datasetName","filteredDataTable","columnId","row","lookups","hideBoundary","joinText","boundaryIndex","path","network","rows","avro","schema","numLinks","crs","needsProjection","linkID","fromOffset","toOffset","coordFrom","coordTo","Coords","boundaries","offset","shapeConfig","featureProperties","r","hasNoLines","hasNoPolygons","hasPoints","b","properties","fullError","avroTable","colName","values","type","modeLookup","allowedModes","centerLong","centerLat","numCoords","numFeatures","idx","centroid","turf.centerOfMass","idField","count","url","shpPromise","dbfPromise","dbfBlob","geojson","dbfFilename","shpBlob","shapefile.read","projection","DEFAULT_PROJECTION","prjFilename","guessCRS","reproject","getFirstPoint","firstPoint","msg","long","lat","longitude","latitude","loaderConfig","joiner","joinColumns","active","show","selectedColumn","selection","joinShapesBy","datasetJoinCol","valueColumns","datasetValuesCol","joinCol","dataValues","groupLookup","group","zip","max","boundary","lookupValue","sum","layerName","colors","whichScale","scale","d3ScaleChromatic","scaleSequential","c","__fill__","buildRGBfromHexCodes","labels","borderColor","borderWidth","visible","onTop","coord"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}