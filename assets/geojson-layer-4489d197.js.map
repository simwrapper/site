{"version":3,"file":"geojson-layer-4489d197.js","sources":["../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js","../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js","../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","../../node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","../../node_modules/earcut/src/earcut.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","../../node_modules/@deck.gl/layers/dist/esm/utils.js","../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js","../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js","../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js","../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js","../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js"],"sourcesContent":["export default \"#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n\";\n//# sourceMappingURL=lights.glsl.js.map","import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map","export default \"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\";\n//# sourceMappingURL=phong-lighting.glsl.js.map","import { lights } from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {\n    ambient = 0.35,\n    diffuse = 0.6,\n    shininess = 32,\n    specularColor = [30, 30, 30]\n  } = material;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {\n    material\n  } = opts;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n//# sourceMappingURL=phong-lighting.js.map","import { equals } from '@math.gl/core';\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n//# sourceMappingURL=polygon-utils.js.map","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","import earcut from 'earcut';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\nconst windingOptions = {\n  isClosed: true\n};\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nexport function getPositions(polygon) {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\nexport function getHoleIndices(polygon) {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\nfunction isNested(polygon) {\n  return Array.isArray(polygon[0]);\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  const positions = [];\n  const holeIndices = [];\n\n  if ('positions' in polygon) {\n    const {\n      positions: srcPositions,\n      holeIndices: srcHoleIndices\n    } = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions,\n        holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (!isNested(polygon)) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n      holeIndices.push(targetIndex);\n    }\n\n    holeIndices.pop();\n    return {\n      positions,\n      holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\nexport function getSurfaceIndices(polygon, positionSize, preproject) {\n  let holeIndices = getHoleIndices(polygon);\n\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n\n  if (preproject) {\n    const n = positions.length;\n    positions = positions.slice();\n    const p = [];\n\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}\n//# sourceMappingURL=polygon.js.map","import * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n\n      return normalizedPolygon;\n    }\n\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n\n      return size;\n    }\n\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n\n    if (!target || !polygon) {\n      return;\n    }\n\n    let i = indexStart;\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n\n    if (!positions || !polygon) {\n      return;\n    }\n\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n\n}\n\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n//# sourceMappingURL=polygon-tesselator.js.map","export default \"\\nattribute vec2 vertexPositions;\\nattribute float vertexValid;\\n\\nuniform bool extruded;\\nuniform bool isWireframe;\\nuniform float elevationScale;\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\n\\nstruct PolygonProps {\\n  vec4 fillColors;\\n  vec4 lineColors;\\n  vec3 positions;\\n  vec3 nextPositions;\\n  vec3 pickingColors;\\n  vec3 positions64Low;\\n  vec3 nextPositions64Low;\\n  float elevations;\\n};\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvoid calculatePosition(PolygonProps props) {\\n#ifdef IS_SIDE_VERTEX\\n  if(vertexValid < 0.5){\\n    gl_Position = vec4(0.);\\n    return;\\n  }\\n#endif\\n\\n  vec3 pos;\\n  vec3 pos64Low;\\n  vec3 normal;\\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\\n\\n  geometry.worldPosition = props.positions;\\n  geometry.worldPositionAlt = props.nextPositions;\\n  geometry.pickingColor = props.pickingColors;\\n\\n#ifdef IS_SIDE_VERTEX\\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\\n#else\\n  pos = props.positions;\\n  pos64Low = props.positions64Low;\\n#endif\\n\\n  if (extruded) {\\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\\n  }\\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\\n\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  if (extruded) {\\n  #ifdef IS_SIDE_VERTEX\\n    normal = vec3(\\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\\n      0.0);\\n    normal = project_offset_normal(normal);\\n  #else\\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\\n  #endif\\n    geometry.normal = normal;\\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\\n    vColor = vec4(lightColor, colors.a * opacity);\\n  } else {\\n    vColor = vec4(colors.rgb, colors.a * opacity);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=solid-polygon-layer-vertex-main.glsl.js.map","import main from './solid-polygon-layer-vertex-main.glsl';\nexport default \"#define SHADER_NAME solid-polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\nattribute float elevations;\\nattribute vec4 fillColors;\\nattribute vec4 lineColors;\\nattribute vec3 pickingColors;\\n\\n\".concat(main, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = positions;\\n  props.positions64Low = positions64Low;\\n  props.elevations = elevations;\\n  props.fillColors = fillColors;\\n  props.lineColors = lineColors;\\n  props.pickingColors = pickingColors;\\n\\n  calculatePosition(props);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-vertex-top.glsl.js.map","import main from './solid-polygon-layer-vertex-main.glsl';\nexport default \"#define SHADER_NAME solid-polygon-layer-vertex-shader-side\\n#define IS_SIDE_VERTEX\\n\\n\\nattribute vec3 instancePositions;\\nattribute vec3 nextPositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec3 nextPositions64Low;\\nattribute float instanceElevations;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\n\".concat(main, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  #if RING_WINDING_ORDER_CW == 1\\n    props.positions = instancePositions;\\n    props.positions64Low = instancePositions64Low;\\n    props.nextPositions = nextPositions;\\n    props.nextPositions64Low = nextPositions64Low;\\n  #else\\n    props.positions = nextPositions;\\n    props.positions64Low = nextPositions64Low;\\n    props.nextPositions = instancePositions;\\n    props.nextPositions64Low = instancePositions64Low;\\n  #endif\\n  props.elevations = instanceElevations;\\n  props.fillColors = instanceFillColors;\\n  props.lineColors = instanceLineColors;\\n  props.pickingColors = instancePickingColors;\\n\\n  calculatePosition(props);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-vertex-side.glsl.js.map","export default \"#define SHADER_NAME solid-polygon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=solid-polygon-layer-fragment.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry, hasFeatures, FEATURES } from '@luma.gl/core';\nimport PolygonTesselator from './polygon-tesselator';\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nexport default class SolidPolygonLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const {\n      gl,\n      viewport\n    } = this.context;\n    let {\n      coordinateSystem\n    } = this.props;\n\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat.bind(viewport),\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n    attributeManager.remove(['instancePickingColors']);\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: this.calculateIndices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: 5121,\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      extruded,\n      filled,\n      wireframe,\n      elevationScale\n    } = this.props;\n    const {\n      topModel,\n      sideModel,\n      polygonTesselator\n    } = this.state;\n    const renderUniforms = { ...uniforms,\n      extruded: Boolean(extruded),\n      elevationScale\n    };\n\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n\n      if (wireframe) {\n        sideModel.setDrawMode(3);\n        sideModel.setUniforms({\n          isWireframe: true\n        }).draw();\n      }\n\n      if (filled) {\n        sideModel.setDrawMode(6);\n        sideModel.setUniforms({\n          isWireframe: false\n        }).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    this.updateGeometry(updateParams);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = updateParams;\n    const attributeManager = this.getAttributeManager();\n    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      var _this$state$models;\n\n      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach(model => model.delete());\n      this.setState(this._getModels(this.context.gl));\n      attributeManager.invalidateAll();\n    }\n  }\n\n  updateGeometry({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n    if (geometryConfigChanged) {\n      const {\n        polygonTesselator\n      } = this.state;\n\n      if (polygonTesselator.instanceCount) return\n\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n\n  _getModels(gl) {\n    const {\n      id,\n      filled,\n      extruded\n    } = this.props;\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n      topModel = new Model(gl, { ...shaders,\n        id: \"\".concat(id, \"-top\"),\n        drawMode: 4,\n        attributes: {\n          vertexPositions: new Float32Array([0, 1])\n        },\n        uniforms: {\n          isWireframe: false,\n          isSideVertex: false\n        },\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n\n    if (extruded) {\n      sideModel = new Model(gl, { ...this.getShaders('side'),\n        id: \"\".concat(id, \"-side\"),\n        geometry: new Geometry({\n          drawMode: 1,\n          vertexCount: 4,\n          attributes: {\n            vertexPositions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        instanceCount: 0,\n        isInstanced: 1\n      });\n      sideModel.userData.excludeAttributes = {\n        indices: true\n      };\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  calculateIndices(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  calculatePositions(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n\n}\n\n_defineProperty(SolidPolygonLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(SolidPolygonLayer, \"layerName\", 'SolidPolygonLayer');\n//# sourceMappingURL=solid-polygon-layer.js.map","export function replaceInRange({\n  data,\n  getIndex,\n  dataRange,\n  replace\n}) {\n  const {\n    startRow = 0,\n    endRow = Infinity\n  } = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;\n\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n\n  if (endChunk) {\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n//# sourceMappingURL=utils.js.map","export function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: { ...data.properties[propertiesIndex]\n    }\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n//# sourceMappingURL=geojson-binary.js.map","import IconLayer from '../icon-layer/icon-layer';\nimport ScatterplotLayer from '../scatterplot-layer/scatterplot-layer';\nimport TextLayer from '../text-layer/text-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nexport const POINT_LAYER = {\n  circle: {\n    type: ScatterplotLayer,\n    props: {\n      filled: 'filled',\n      stroked: 'stroked',\n      lineWidthMaxPixels: 'lineWidthMaxPixels',\n      lineWidthMinPixels: 'lineWidthMinPixels',\n      lineWidthScale: 'lineWidthScale',\n      lineWidthUnits: 'lineWidthUnits',\n      pointRadiusMaxPixels: 'radiusMaxPixels',\n      pointRadiusMinPixels: 'radiusMinPixels',\n      pointRadiusScale: 'radiusScale',\n      pointRadiusUnits: 'radiusUnits',\n      pointAntialiasing: 'antialiasing',\n      pointBillboard: 'billboard',\n      getFillColor: 'getFillColor',\n      getLineColor: 'getLineColor',\n      getLineWidth: 'getLineWidth',\n      getPointRadius: 'getRadius'\n    }\n  },\n  icon: {\n    type: IconLayer,\n    props: {\n      iconAtlas: 'iconAtlas',\n      iconMapping: 'iconMapping',\n      iconSizeMaxPixels: 'sizeMaxPixels',\n      iconSizeMinPixels: 'sizeMinPixels',\n      iconSizeScale: 'sizeScale',\n      iconSizeUnits: 'sizeUnits',\n      iconAlphaCutoff: 'alphaCutoff',\n      iconBillboard: 'billboard',\n      getIcon: 'getIcon',\n      getIconAngle: 'getAngle',\n      getIconColor: 'getColor',\n      getIconPixelOffset: 'getPixelOffset',\n      getIconSize: 'getSize'\n    }\n  },\n  text: {\n    type: TextLayer,\n    props: {\n      textSizeMaxPixels: 'sizeMaxPixels',\n      textSizeMinPixels: 'sizeMinPixels',\n      textSizeScale: 'sizeScale',\n      textSizeUnits: 'sizeUnits',\n      textBackground: 'background',\n      textBackgroundPadding: 'backgroundPadding',\n      textFontFamily: 'fontFamily',\n      textFontWeight: 'fontWeight',\n      textLineHeight: 'lineHeight',\n      textMaxWidth: 'maxWidth',\n      textOutlineColor: 'outlineColor',\n      textOutlineWidth: 'outlineWidth',\n      textWordBreak: 'wordBreak',\n      textCharacterSet: 'characterSet',\n      textBillboard: 'billboard',\n      textFontSettings: 'fontSettings',\n      getText: 'getText',\n      getTextAngle: 'getAngle',\n      getTextColor: 'getColor',\n      getTextPixelOffset: 'getPixelOffset',\n      getTextSize: 'getSize',\n      getTextAnchor: 'getTextAnchor',\n      getTextAlignmentBaseline: 'getAlignmentBaseline',\n      getTextBackgroundColor: 'getBackgroundColor',\n      getTextBorderColor: 'getBorderColor',\n      getTextBorderWidth: 'getBorderWidth'\n    }\n  }\n};\nexport const LINE_LAYER = {\n  type: PathLayer,\n  props: {\n    lineWidthUnits: 'widthUnits',\n    lineWidthScale: 'widthScale',\n    lineWidthMinPixels: 'widthMinPixels',\n    lineWidthMaxPixels: 'widthMaxPixels',\n    lineJointRounded: 'jointRounded',\n    lineCapRounded: 'capRounded',\n    lineMiterLimit: 'miterLimit',\n    lineBillboard: 'billboard',\n    getLineColor: 'getColor',\n    getLineWidth: 'getWidth'\n  }\n};\nexport const POLYGON_LAYER = {\n  type: SolidPolygonLayer,\n  props: {\n    extruded: 'extruded',\n    filled: 'filled',\n    wireframe: 'wireframe',\n    elevationScale: 'elevationScale',\n    material: 'material',\n    getElevation: 'getElevation',\n    getFillColor: 'getFillColor',\n    getLineColor: 'getLineColor'\n  }\n};\nexport function getDefaultProps({\n  type,\n  props\n}) {\n  const result = {};\n\n  for (const key in props) {\n    result[key] = type.defaultProps[props[key]];\n  }\n\n  return result;\n}\nexport function forwardProps(layer, mapping) {\n  const {\n    transitions,\n    updateTriggers\n  } = layer.props;\n  const result = {\n    updateTriggers: {},\n    transitions: transitions && {\n      getPosition: transitions.geometry\n    }\n  };\n\n  for (const sourceKey in mapping) {\n    const targetKey = mapping[sourceKey];\n    let value = layer.props[sourceKey];\n\n    if (sourceKey.startsWith('get')) {\n      value = layer.getSubLayerAccessor(value);\n      result.updateTriggers[targetKey] = updateTriggers[sourceKey];\n\n      if (transitions) {\n        result.transitions[targetKey] = transitions[sourceKey];\n      }\n    }\n\n    result[targetKey] = value;\n  }\n\n  return result;\n}\n//# sourceMappingURL=sub-layer-map.js.map","import { log } from '@deck.gl/core';\nexport function getGeojsonFeatures(geojson) {\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      return [geojson];\n\n    case 'FeatureCollection':\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n\n    default:\n      return [{\n        geometry: geojson\n      }];\n  }\n}\nexport function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {\n    startRow = 0,\n    endRow = features.length\n  } = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n    const {\n      geometry\n    } = feature;\n\n    if (!geometry) {\n      continue;\n    }\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {\n        geometries\n      } = geometry;\n\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {\n    type,\n    coordinates\n  } = geometry;\n  const {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  } = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    log.warn(\"\".concat(type, \" coordinates are malformed\"))();\n    return;\n  }\n\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Point',\n            coordinates: point\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'LineString':\n      lineFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n\n    case 'MultiLineString':\n      coordinates.forEach(path => {\n        lineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'Polygon':\n      polygonFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'MultiPolygon':\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Polygon',\n            coordinates: polygon\n          }\n        }, sourceFeature, sourceFeatureIndex));\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(wrapFeature({\n            geometry: {\n              type: 'LineString',\n              coordinates: path\n            }\n          }, sourceFeature, sourceFeatureIndex));\n        });\n      });\n      break;\n\n    default:\n  }\n}\n\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\nexport function validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n  log.assert(nestLevel, \"Unknown GeoJSON type \".concat(type));\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n//# sourceMappingURL=geojson.js.map","import { calculatePickingColors } from './geojson-binary';\n\nfunction createEmptyLayerProps() {\n  return {\n    points: {},\n    lines: {},\n    polygons: {},\n    polygonsOutline: {}\n  };\n}\n\nfunction getCoordinates(f) {\n  return f.geometry.coordinates;\n}\n\nexport function createLayerPropsFromFeatures(features, featuresDiff) {\n  const layerProps = createEmptyLayerProps();\n  const {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  } = features;\n  layerProps.points.data = pointFeatures;\n\n  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);\n\n  layerProps.points.getPosition = getCoordinates;\n  layerProps.lines.data = lineFeatures;\n\n  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);\n\n  layerProps.lines.getPath = getCoordinates;\n  layerProps.polygons.data = polygonFeatures;\n\n  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);\n\n  layerProps.polygons.getPolygon = getCoordinates;\n  layerProps.polygonsOutline.data = polygonOutlineFeatures;\n\n  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);\n\n  layerProps.polygonsOutline.getPath = getCoordinates;\n  return layerProps;\n}\nexport function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {\n  const layerProps = createEmptyLayerProps();\n  const {\n    points,\n    lines,\n    polygons\n  } = geojsonBinary;\n  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);\n  layerProps.points.data = {\n    length: points.positions.value.length / points.positions.size,\n    attributes: { ...points.attributes,\n      getPosition: points.positions,\n      instancePickingColors: {\n        size: 3,\n        value: customPickingColors.points\n      }\n    },\n    properties: points.properties,\n    numericProps: points.numericProps,\n    featureIds: points.featureIds\n  };\n  layerProps.lines.data = {\n    length: lines.pathIndices.value.length - 1,\n    startIndices: lines.pathIndices.value,\n    attributes: { ...lines.attributes,\n      getPath: lines.positions,\n      instancePickingColors: {\n        size: 3,\n        value: customPickingColors.lines\n      }\n    },\n    properties: lines.properties,\n    numericProps: lines.numericProps,\n    featureIds: lines.featureIds\n  };\n  layerProps.lines._pathType = 'open';\n  layerProps.polygons.data = {\n    length: polygons.polygonIndices.value.length - 1,\n    startIndices: polygons.polygonIndices.value,\n    attributes: { ...polygons.attributes,\n      getPolygon: polygons.positions,\n      pickingColors: {\n        size: 3,\n        value: customPickingColors.polygons\n      }\n    },\n    properties: polygons.properties,\n    numericProps: polygons.numericProps,\n    featureIds: polygons.featureIds\n  };\n  layerProps.polygons._normalize = false;\n\n  if (polygons.triangles) {\n    layerProps.polygons.data.attributes.indices = polygons.triangles.value;\n  }\n\n  layerProps.polygonsOutline.data = {\n    length: polygons.primitivePolygonIndices.value.length - 1,\n    startIndices: polygons.primitivePolygonIndices.value,\n    attributes: { ...polygons.attributes,\n      getPath: polygons.positions,\n      instancePickingColors: {\n        size: 3,\n        value: customPickingColors.polygons\n      }\n    },\n    properties: polygons.properties,\n    numericProps: polygons.numericProps,\n    featureIds: polygons.featureIds\n  };\n  layerProps.polygonsOutline._pathType = 'open';\n  return layerProps;\n}\n//# sourceMappingURL=geojson-layer-props.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer } from '@deck.gl/core';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from './sub-layer-map';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nconst defaultProps = { ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: f => f.properties.icon\n  },\n  getText: {\n    type: 'accessor',\n    value: f => f.properties.text\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n};\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n\n    const {\n      data\n    } = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n    this.setState({\n      binary\n    });\n\n    if (binary) {\n      this._updateStateBinary({\n        props,\n        changeFlags\n      });\n    } else {\n      this._updateStateJSON({\n        props,\n        changeFlags\n      });\n    }\n  }\n\n  _updateStateBinary({\n    props,\n    changeFlags\n  }) {\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({\n      layerProps\n    });\n  }\n\n  _updateStateJSON({\n    props,\n    changeFlags\n  }) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(replaceInRange({\n            data: newFeatures[key],\n            getIndex: f => f.__source.index,\n            dataRange,\n            replace: partialFeatures[key]\n          }));\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index,\n      sourceLayer\n    } = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(\"\".concat(this.id, \"-\").concat(ft, \"-\")));\n\n    if (index >= 0 && sourceLayer.id.startsWith(\"\".concat(this.id, \"-points-text\")) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    const pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n    const sourceIsPoints = info.featureType === 'points';\n\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  _renderPolygonLayer() {\n    const {\n      extruded,\n      wireframe\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const id = 'polygons-fill';\n    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      const useLineColor = extruded && wireframe;\n\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n        id,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygons);\n    }\n\n    return null;\n  }\n\n  _renderLineLayers() {\n    const {\n      extruded,\n      stroked\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n        id: polygonStrokeLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n        id: lineStringsLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.lines)];\n    }\n\n    return null;\n  }\n\n  _renderPointLayers() {\n    const {\n      pointType\n    } = this.props;\n    const {\n      layerProps,\n      binary\n    } = this.state;\n    let {\n      highlightedObjectIndex\n    } = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);\n    }\n\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n\n    for (const type of types) {\n      const id = \"points-\".concat(type);\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          const {\n            instancePickingColors,\n            ...rest\n          } = pointsLayerProps.data.attributes;\n          pointsLayerProps = { ...pointsLayerProps,\n            data: { ...pointsLayerProps.data,\n              attributes: rest\n            }\n          };\n        }\n\n        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers,\n          highlightedObjectIndex\n        }), pointsLayerProps));\n      }\n    }\n\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {\n      extruded\n    } = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n\n    const lineLayers = this._renderLineLayers();\n\n    const pointLayers = this._renderPointLayers();\n\n    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {\n      binary\n    } = this.state;\n\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {\n        data,\n        index\n      } = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n\n}\n\n_defineProperty(GeoJsonLayer, \"layerName\", 'GeoJsonLayer');\n\n_defineProperty(GeoJsonLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=geojson-layer.js.map"],"names":["lightingShader$1","INITIAL_MODULE_OPTIONS","convertColor","color","intensity","component","getLightSourceUniforms","_ref","ambientLight","pointLights","directionalLights","lightSourceUniforms","pointLight","index","directionalLight","getUniforms","opts","lightSources","light","lights","lightingShader","getMaterialUniforms","material","ambient","diffuse","shininess","specularColor","x","gouraudLighting","phongLighting","WINDING","modifyPolygonWindingDirection","points","direction","options","getPolygonWindingDirection","reversePolygon","getPolygonSignedArea","start","end","dim","area","i","j","size","numPoints","numSwaps","b1","b2","tmp","earcutModule","earcut","data","holeIndices","hasHoles","outerLen","outerNode","linkedList","triangles","minX","minY","maxX","maxY","y","invSize","eliminateHoles","earcutLinked","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","p","again","ear","pass","indexCurve","stop","prev","next","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangle","minZ","zOrder","maxZ","n","intersects","locallyInside","isValidDiagonal","splitPolygon","queue","len","list","getLeftmost","compareX","eliminateHole","hole","bridge","findHoleBridge","bridgeReverse","hx","hy","qx","m","mx","my","tanMin","tan","sectorContainsSector","sortLinked","q","e","tail","numMerges","pSize","qSize","inSize","leftmost","px","py","intersectsPolygon","middleInside","r","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","num","inside","a2","Node","an","bp","polygonArea","trianglesArea","sum","result","holeIndex","d","OUTER_POLYGON_WINDING","HOLE_POLYGON_WINDING","windingOptions","validate","polygon","getPositions","getHoleIndices","isNested","isSimple","isNestedRingClosed","simplePolygon","p0","isFlatRingClosed","positions","startIndex","endIndex","copyNestedRing","target","targetStartIndex","windingDirection","targetIndex","copyFlatRing","srcStartIndex","srcEndIndex","srcLength","normalize","positionSize","srcPositions","srcHoleIndices","polygonIndex","getSurfaceIndices","preproject","positionIndex","xy","PolygonTesselator","Tesselator","fp64","IndexType","attributeName","attributes","externalIndices","normalizedPolygon","Polygon.normalize","cutPolygonByGrid","Polygon.getPositions","Polygon.getHoleIndices","cutPolygonByMercatorBounds","isCut","subPolygon","buffer","context","geometrySize","geometryIndex","offset","indexStart","indexStarts","typedArrayManager","indices","Polygon.getSurfaceIndices","vertexStart","polygonPositions","z","vertexValid","main","vsTop","vsSide","fs","DEFAULT_COLOR","defaultProps","f","ATTRIBUTE_TRANSITION","value","chunk","SolidPolygonLayer","Layer","args","_defineProperty","type","project32","picking","gl","viewport","coordinateSystem","COORDINATE_SYSTEM","hasFeatures","FEATURES","attributeManager","noAlloc","object","params","info","objectIndex","uniforms","extruded","filled","wireframe","elevationScale","topModel","sideModel","polygonTesselator","renderUniforms","updateParams","props","oldProps","changeFlags","_this$state$models","model","buffers","id","shaders","Model","Geometry","attribute","replaceInRange","getIndex","dataRange","replace","startRow","endRow","count","replaceStart","replaceEnd","row","endChunk","binaryToFeatureForAccesor","featureIndex","getPropertiesForIndex","propertiesIndex","numericPropsIndex","feature","prop","calculatePickingColors","geojsonBinary","encodePickingColor","pickingColors","key","featureIds","pickingColor","POINT_LAYER","ScatterplotLayer","IconLayer","TextLayer","LINE_LAYER","PathLayer","POLYGON_LAYER","getDefaultProps","forwardProps","layer","mapping","transitions","updateTriggers","sourceKey","targetKey","getGeojsonFeatures","geojson","log","separateGeojsonFeatures","features","wrapFeature","separated","geometry","geometries","subGeometry","separateGeometry","sourceFeature","sourceFeatureIndex","coordinates","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","validateGeometry","point","path","COORDINATE_NEST_LEVEL","nestLevel","createEmptyLayerProps","getCoordinates","createLayerPropsFromFeatures","featuresDiff","layerProps","createLayerPropsFromBinary","lines","polygons","customPickingColors","FEATURE_TYPES","GeoJsonLayer","CompositeLayer","binary","newFeatures","oldFeatures","partialFeatures","sourceLayer","ft","pointLayerIdPrefix","sourceIsPoints","PolygonFillLayer","forwardedProps","useLineColor","stroked","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","LineStringsLayer","pointType","highlightedObjectIndex","types","pointLayers","PointLayerMapping","PointsLayer","pointsLayerProps","instancePickingColors","rest","polygonFillLayer","lineLayers","accessor"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}