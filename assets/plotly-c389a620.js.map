{"version":3,"file":"plotly-c389a620.js","sources":["../../src/plugins/plotly/PlotlyDiagram.vue","../../src/dash-panels/plotly.vue"],"sourcesContent":["<template lang=\"pug\">\n.mycomponent(:class=\"{'is-thumbnail': thumbnail}\")\n\n  VuePlotly.myplot(\n    :data=\"traces\"\n    :layout=\"layout\"\n    :options=\"options\"\n    :id=\"id\"\n  )\n\n</template>\n\n<script lang=\"ts\">\nconst i18n = {\n  messages: {\n    en: { total: 'total', showChanges: 'Only show changes' },\n    de: { total: 'Insgesamt', showChanges: 'Nur Ã„nderungen zeigen' },\n  },\n}\n\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nimport yaml from 'yaml'\n\nimport globalStore from '@/store'\nimport VuePlotly from '@/components/VuePlotly.vue'\nimport HTTPFileSystem from '@/js/HTTPFileSystem'\nimport DashboardDataManager from '@/js/DashboardDataManager'\nimport { getColorRampHexCodes } from '@/js/ColorsAndWidths'\nimport { mergeTypedArrays } from '@/js/util'\nimport {\n  FileSystemConfig,\n  UI_FONT,\n  BG_COLOR_DASHBOARD,\n  BG_COLOR_PLOTLY_FACETS,\n  DataTable,\n  DataSet,\n  DataTableColumn,\n} from '@/Globals'\n\ninterface Layout {\n  [key: string]: any\n}\n\nconst MyComponent = defineComponent({\n  name: 'PlotlyPlugin',\n  components: { VuePlotly },\n  i18n,\n  props: {\n    root: { type: String, required: true },\n    subfolder: { type: String, required: true },\n    config: { type: Object as any },\n    datamanager: { type: Object as PropType<DashboardDataManager> },\n    resize: Object as any,\n    thumbnail: Boolean,\n    yamlConfig: String,\n  },\n\n  data() {\n    return {\n      globalState: globalStore.state,\n      vizDetails: { title: '', description: '' } as any,\n      loadingText: '',\n      jsonChart: {} as any,\n      id: `plotly-id-${Math.floor(1e12 * Math.random())}` as any,\n      traces: [] as any[],\n      prevWidth: -1,\n      prevHeight: -1,\n      attributeColorMap: new Map(),\n      colorway: [\n        '#1f77b4', // muted blue\n        '#ff7f0e', // safety orange\n        '#2ca02c', // cooked asparagus green\n        '#d62728', // brick red\n        '#9467bd', // muted purple\n        '#8c564b', // chestnut brown\n        '#e377c2', // raspberry yogurt pink\n        '#7f7f7f', // middle gray\n        '#bcbd22', // curry yellow-green\n        '#17becf',\n      ],\n      // DataManager might be passed in from the dashboard; or we might be\n      // in single-view mode, in which case we need to create one for ourselves\n      myDataManager: this.datamanager || new DashboardDataManager(this.root, this.subfolder),\n      // Plotly layout\n      layout: {\n        margin: { t: 8, b: 0, l: 50, r: 0, pad: 2 },\n        font: {\n          color: '#444444',\n          family: UI_FONT,\n        },\n        xaxis: {\n          automargin: true,\n          autorange: true,\n          range: [0, 100], // Just some default values. The correct values are calculated later in the code (in setFixedAxis()). Only used for interactive plotly plots with a slider\n          title: { text: '', standoff: 12 },\n          animate: true,\n        },\n        yaxis: {\n          automargin: true,\n          autorange: true,\n          range: [0, 100], // see this.layout.xaxis.range...\n          title: { text: '', standoff: 16 },\n          animate: true,\n          rangemode: 'tozero',\n        },\n        yaxis2: {\n          automargin: true,\n          autorange: true,\n          range: [0, 100], // see this.layout.xaxis.range...\n          title: { text: '', standoff: 16 },\n          animate: true,\n          rangemode: 'tozero',\n          matches: 'y',\n          anchor: 'x2',\n        },\n        legend: {\n          orientation: 'v',\n          x: 1,\n          y: 1,\n        },\n        grid: { rows: 1, columns: 1 },\n      } as Layout,\n      // Plotly options\n      options: {\n        displaylogo: false,\n        responsive: true,\n        modeBarButtonsToRemove: [\n          'pan2d',\n          'zoom2d',\n          'select2d',\n          'lasso2d',\n          'zoomIn2d',\n          'zoomOut2d',\n          'autoScale2d',\n          'hoverClosestCartesian',\n          'hoverCompareCartesian',\n          'resetScale2d',\n          'toggleSpikelines',\n          'resetViewMapbox',\n        ],\n        toImageButtonOptions: {\n          format: 'png', // one of png, svg, jpeg, webp\n          filename: 'chart',\n          width: null,\n          height: null,\n        },\n      },\n      minXValue: Number.POSITIVE_INFINITY,\n      minYValue: Number.POSITIVE_INFINITY,\n      maxXValue: Number.NEGATIVE_INFINITY,\n      maxYValue: Number.NEGATIVE_INFINITY,\n      isUsingFacets: false,\n    }\n  },\n\n  computed: {\n    fileApi(): HTTPFileSystem {\n      return new HTTPFileSystem(this.fileSystem, globalStore)\n    },\n\n    fileSystem(): FileSystemConfig {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === this.root\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n  },\n\n  watch: {\n    'globalState.resizeEvents'() {\n      this.changeDimensions({})\n    },\n    resize(event: any) {\n      this.changeDimensions(event)\n    },\n    'globalState.isDarkMode'() {\n      this.updateTheme()\n    },\n  },\n\n  async mounted() {\n    this.updateTheme()\n    await this.getVizDetails()\n    // only continue if we are on a real page and not the file browser\n    if (this.thumbnail) return\n\n    try {\n      if (this.vizDetails.datasets) await this.prepareData()\n      if (this.vizDetails.traces) this.traces = this.vizDetails.traces\n\n      // merge user-supplied layout with SimWrapper layout defaults\n      if (this.vizDetails.layout) this.mergeLayouts()\n\n      if (this.vizDetails.fixedRatio) {\n        this.vizDetails.layout.xaxis = Object.assign(this.vizDetails.layout.xaxis, {\n          constrain: 'domain',\n        })\n        this.vizDetails.layout.yaxis = Object.assign(this.vizDetails.layout.yaxis, {\n          constrain: 'domain',\n          scaleanchor: 'x',\n          scaleration: 1,\n        })\n      }\n\n      // Backwards compatiblity with the older \"dropdownMenu\" option\n      if (this.vizDetails.dropdownMenu) this.vizDetails.interactive = 'dropdown'\n      // create interactive elements\n      if (this.vizDetails.interactive) this.createMenus(this.vizDetails.interactive)\n      // calculates the axis if the plot is interactive and has a slider\n      if (this.vizDetails.interactive && this.config.interactive === 'slider') this.setFixedAxis()\n    } catch (err) {\n      const e = err as any\n      console.error({ e })\n      this.$emit('error', '' + e)\n      this.loadingText = '' + e\n    }\n    this.updateTheme()\n    window.addEventListener('resize', this.changeDimensions)\n    this.layout.margin = { r: 0, t: 8, b: 0, l: 50, pad: 2 }\n    this.createFacets()\n\n    // Fix: If two x axes are used, the x-axis labels are not displayed correctly.\n    if (Array.isArray(this.traces[0].x[0])) {\n      this.layout.xaxis.autotickangles = [0, 90]\n    }\n  },\n\n  beforeDestroy() {\n    window.removeEventListener('resize', this.changeDimensions)\n  },\n\n  methods: {\n    /**\n     * Calculates the axis ranges for the x-axis and y-axis based on the data in the 'traces' array.\n     * It iterates through each trace and updates the 'maxXValue', 'maxYValue', 'minYValue', and 'minXValue'\n     * based on the maximum and minimum values found in the 'x' and 'y' arrays of each trace.\n     */\n    setFixedAxis() {\n      for (let i = 0; i < this.traces.length; i++) {\n        // Calculated the min and max value for the x- any y-axis for each trace\n        const yAxisMin = Math.min(...this.traces[i].y)\n        const yAxisMax = Math.max(...this.traces[i].y)\n        const xAxisMin = Math.min(...this.traces[i].x)\n        const xAxisMax = Math.max(...this.traces[i].x)\n\n        // Update the 'maxXValue' if the maximum value in the 'x' array of the current trace is greater than the current 'maxXValue'.\n        if (xAxisMax >= this.maxXValue) this.maxXValue = xAxisMax\n\n        // Update the 'maxYValue' if the maximum value in the 'y' array of the current trace is greater than the current 'maxYValue'.\n        if (yAxisMax >= this.maxYValue) this.maxYValue = yAxisMax\n\n        // Update the 'minYValue' if the minimum value in the 'y' array of the current trace is less than the current 'minYValue'.\n        if (yAxisMin <= this.minYValue) this.minYValue = yAxisMin\n\n        // Update the 'minXValue' if the minimum value in the 'x' array of the current trace is less than the current 'minXValue'.\n        if (xAxisMin <= this.minXValue) this.minXValue = xAxisMin\n      }\n\n      // Set the x-axis and y-axis ranges in the layout based on the calculated 'minXValue', 'maxXValue', 'minYValue', and 'maxYValue'.\n      this.layout.xaxis.range = [this.minXValue, this.maxXValue]\n      this.layout.yaxis.range = [this.minYValue, this.maxYValue]\n\n      // Set the autorange option to false, range is now calculated and fix\n      this.layout.xaxis.autorange = false\n      this.layout.yaxis.autorange = false\n\n      // Uncomment the following lines to log the chart title and axis ranges to the console for debugging purposes.\n      // console.log(this.$props.config.title)\n      // console.log(\n      //   this.vizDetails.description +\n      //     ': x-axis: [' +\n      //     this.minXValue +\n      //     ',' +\n      //     this.maxXValue +\n      //     '], y-axis: [' +\n      //     this.minYValue +\n      //     ',' +\n      //     this.maxYValue +\n      //     ']'\n      // )\n    },\n    changeDimensions(dim: any) {\n      if (dim?.height && dim?.width) {\n        if (dim.height !== this.prevHeight || dim.width !== this.prevWidth) {\n          this.prevHeight = dim.height\n          this.prevWidth = dim.width\n          this.layout = Object.assign({}, this.layout, dim)\n        }\n      }\n    },\n\n    mergeLayouts() {\n      const mergedLayout = { ...this.vizDetails.layout }\n\n      // TODO: only if the y axis title is set, the margin to the left needs to be little bit larger\n\n      // we always want to use SimWrapper defaults for these:\n      mergedLayout.margin = this.layout.margin\n      mergedLayout.font = this.layout.font\n      mergedLayout.legend = this.layout.legend\n\n      // we never want these:\n      delete mergedLayout.height\n      delete mergedLayout.width\n\n      // be selective about these:\n      if (mergedLayout.xaxis) {\n        mergedLayout.xaxis.automargin = true\n        mergedLayout.xaxis.autorange = true\n        mergedLayout.xaxis.animate = true\n        if (!mergedLayout.xaxis.title) mergedLayout.xaxis.title = this.layout.xaxis.title\n      } else {\n        mergedLayout.xaxis = this.layout.xaxis\n      }\n\n      if (mergedLayout.yaxis) {\n        mergedLayout.yaxis.automargin = true\n        mergedLayout.yaxis.autorange = true\n        mergedLayout.yaxis.animate = true\n\n        // bug #357: scatterplots fail if rangemode is set\n        if (!this.traces.find(a => a?.type == 'scatter')) {\n          if (!mergedLayout.yaxis.rangemode) mergedLayout.yaxis.rangemode = 'tozero'\n        }\n        if (!mergedLayout.yaxis.title) mergedLayout.yaxis.title = this.layout.yaxis.title\n      } else {\n        mergedLayout.yaxis = this.layout.yaxis\n      }\n\n      if (mergedLayout.yaxis2) {\n        mergedLayout.yaxis2.automargin = true\n        mergedLayout.yaxis2.autorange = true\n        mergedLayout.yaxis2.animate = true\n        if (!mergedLayout.yaxis2.rangemode) mergedLayout.yaxis2.rangemode = 'tozero'\n        if (!mergedLayout.yaxis2.title) mergedLayout.yaxis2.title = this.layout.yaxis2.title\n      } else {\n        mergedLayout.yaxis2 = this.layout.yaxis2\n      }\n\n      this.layout = mergedLayout\n    },\n\n    // This method checks if facet_col and/or facet_row are defined in the traces\n    createFacets() {\n      if (this.traces[0].facet_col == undefined && this.traces[0].facet_row == undefined) return\n\n      // Set different bg colors for facet plots to seperate them from each other\n      this.isUsingFacets = true\n      this.updateTheme()\n\n      let facet_col = [] as any[]\n      let facet_row = [] as any[]\n\n      if (this.traces[0].facet_col != undefined)\n        facet_col = this.traces[0].facet_col.filter(\n          (element: any, index: any) => this.traces[0].facet_col.indexOf(element) === index\n        )\n      if (this.traces[0].facet_row != undefined)\n        facet_row = this.traces[0].facet_row.filter(\n          (element: any, index: any) => this.traces[0].facet_row.indexOf(element) === index\n        )\n\n      this.groupTracesByFacets(facet_col, facet_row)\n\n      // If the plot is interactive, the traces are displayed in one plot so the grid is set to 1x1\n      if (this.vizDetails.interactive == 'dropdown') {\n        this.layout.grid = { rows: 1, columns: 1 }\n        this.createMenus(this.vizDetails.interactive)\n      }\n    },\n    // If facet_col and/or facet_row are defined in the traces, this method groups the traces by the facets\n    groupTracesByFacets(facet_col: any[], facet_row: any[]) {\n      const yAxisTitle = this.layout.yaxis.title\n      const xAxisTitle = this.layout.xaxis.title\n      const result = []\n      let numRows = facet_row.length\n      let numCols = facet_col.length\n\n      if (numRows == 0) numRows = 1\n      if (numCols == 0) numCols = 1\n\n      // Create facet traces if there are multiple rows but only one column\n      if (facet_col.length == 0) {\n        result.push(\n          ...this.groupTracesByFacetsForOneColumnOrRow(\n            numRows,\n            yAxisTitle,\n            facet_row,\n            'y',\n            'facet_row'\n          )\n        )\n      } else if (facet_row.length == 0) {\n        result.push(\n          ...this.groupTracesByFacetsForOneColumnOrRow(\n            numCols,\n            xAxisTitle,\n            facet_col,\n            'x',\n            'facet_col'\n          )\n        )\n      } else {\n        result.push(\n          ...this.groupTracesByFacetsColumnsAndRows(\n            numCols,\n            numRows,\n            facet_col,\n            facet_row,\n            xAxisTitle,\n            yAxisTitle\n          )\n        )\n      }\n\n      this.layout.margin = { t: 10, b: 20, l: 60, r: 60, pad: 2 }\n      this.layout.grid = { rows: numRows, columns: numCols }\n      this.traces = result\n    },\n\n    assignColor(filterTrace: any) {\n      if (this.attributeColorMap.has(filterTrace.legendgroup)) {\n        return this.attributeColorMap.get(filterTrace.legendgroup)\n      } else {\n        const colorIndex = this.attributeColorMap.size % this.colorway.length\n        const color = this.colorway[colorIndex]\n        this.attributeColorMap.set(filterTrace.legendgroup, color)\n        return color\n      }\n    },\n\n    // If only one column or one row is defined in the traces, this method groups the traces by the facet\n    groupTracesByFacetsColumnsAndRows(\n      numberOfColumns: number,\n      numberOfRows: number,\n      facet_col: any[],\n      facet_row: any[],\n      xAxisTitle: string,\n      yAxisTitle: string\n    ) {\n      const result = []\n      for (let i = 0; i < numberOfRows; i++) {\n        for (let j = 0; j < numberOfColumns; j++) {\n          const row = facet_row[i]\n          const col = facet_col[j]\n          const filteredTraces = []\n\n          for (const trace of this.traces) {\n            const filteredX = []\n            const filteredY = []\n\n            for (let l = 0; l < trace.facet_row.length; l++) {\n              if (trace.facet_row[l] === row && trace.facet_col[l] === col) {\n                filteredX.push(trace.x[l])\n                filteredY.push(trace.y[l])\n              }\n            }\n\n            const filterTrace = {\n              ...trace,\n              x: filteredX,\n              y: filteredY,\n              xaxis: i > 0 ? 'x' + (i + 1) : 'x',\n              yaxis: j > 0 ? 'y' + (j + 1) : 'y',\n            }\n\n            delete filterTrace.facet_row\n            delete filterTrace.facet_col\n\n            // showlegend\n            filterTrace.showlegend = i === 0 && j === 0\n\n            // legendgroup\n            filterTrace.legendgroup = filterTrace.group_name\n            delete filterTrace.group_name\n\n            // filterTrace.marker.color = '#123456'\n            const color = this.assignColor(filterTrace)\n            filterTrace.marker = {\n              color: color,\n            }\n\n            filteredTraces.push(filterTrace)\n          }\n\n          let xAxisIndex = i === 0 ? 'xaxis' : 'xaxis' + (i + 1)\n          let yAxisIndex = j === 0 ? 'yaxis' : 'yaxis' + (j + 1)\n\n          // Left: Axis Text\n          if (this.layout[yAxisIndex] == undefined) {\n            this.layout[yAxisIndex] = {\n              title: {\n                text:\n                  yAxisTitle +\n                  '<br>' +\n                  this.config.traces[0].facet_row.split('.')[1] +\n                  ' = ' +\n                  facet_row[i],\n              },\n              anchor: 'y',\n              autorange: true,\n            }\n          } else {\n            this.layout[yAxisIndex].title = ''\n            this.layout[yAxisIndex].title = {\n              text:\n                yAxisTitle +\n                '<br>' +\n                this.config.traces[0].facet_row.split('.')[1] +\n                ' = ' +\n                facet_row[i],\n            }\n            this.layout[yAxisIndex].anchor = 'y'\n          }\n\n          // Bottom: Axis Text\n          if (this.layout[xAxisIndex] == undefined) {\n            this.layout[xAxisIndex] = {\n              title: {\n                text:\n                  xAxisTitle +\n                  '<br>' +\n                  this.config.traces[0].facet_col.split('.')[1] +\n                  ' = ' +\n                  facet_col[j],\n              },\n              anchor: 'x',\n              autorange: true,\n            }\n          } else {\n            this.layout[xAxisIndex].title = ''\n            this.layout[xAxisIndex].title = {\n              text:\n                xAxisTitle +\n                '<br>' +\n                this.config.traces[0].facet_col.split('.')[1] +\n                ' = ' +\n                facet_col[j],\n            }\n            this.layout[xAxisIndex].anchor = 'x'\n          }\n          result.push(...filteredTraces)\n        }\n      }\n      return result\n    },\n\n    // THis method groups the traces by the facet if more than one column and one row is defined in the traces\n    groupTracesByFacetsForOneColumnOrRow(\n      numberOfFacets: number,\n      axisTitle: any,\n      facets: any[],\n      axis: string,\n      facetObjectKey: string\n    ) {\n      // Extract text from the axis title\n      if (axisTitle instanceof Object && 'text' in axisTitle) axisTitle = axisTitle.text\n\n      const result = []\n      for (let j = 0; j < numberOfFacets; j++) {\n        const row = facets[j]\n        const filteredTraces = []\n\n        for (const trace of this.traces) {\n          const filteredX = []\n\n          for (let l = 0; l < trace[facetObjectKey].length; l++) {\n            if (trace[facetObjectKey][l] === row) {\n              filteredX.push(trace[axis == 'x' ? 'y' : 'x'][l])\n            }\n          }\n\n          let filterTrace = { ...trace }\n\n          // If the the plot is interactive (e. g. dropdown menu), the traces are displayed in one plot\n          if (this.vizDetails.interactive == 'dropdown' && this.isUsingFacets) {\n            filterTrace = {\n              ...trace,\n              x: axis == 'y' ? filteredX : trace.x,\n              y: axis == 'x' ? filteredX : trace.y,\n              xaxis: axis == 'y',\n              yaxis: axis == 'y',\n            }\n          } else {\n            filterTrace = {\n              ...trace,\n              x: axis == 'y' ? filteredX : trace.x,\n              y: axis == 'x' ? filteredX : trace.y,\n              xaxis: axis == 'y' ? 'x' : j > 0 ? 'x' + (j + 1) : 'x',\n              yaxis: axis == 'y' ? (j > 0 ? 'y' + (j + 1) : 'y') : 'y',\n            }\n          }\n\n          delete filterTrace.facet_row\n          delete filterTrace.facet_col\n\n          // showlegend\n          if (this.vizDetails.interactive == 'dropdown' && this.isUsingFacets) {\n            filterTrace.showlegend = true\n          } else {\n            filterTrace.showlegend = j === 0\n          }\n\n          // legendgroup\n          filterTrace.legendgroup = filterTrace.group_name\n          delete filterTrace.group_name\n          filterTrace.facet_name = row\n\n          const color = this.assignColor(filterTrace)\n          filterTrace.marker = {\n            color: color,\n          }\n\n          filteredTraces.push(filterTrace)\n        }\n\n        let label = this.config.traces[0][facetObjectKey].split('.')[1] + ' = ' + facets[j]\n\n        // Insert an additional line break if the label is presumably too long\n        // This does not known about the actual width of the plot\n        if (numberOfFacets * label.length > 150 && axis == 'x') {\n          const idx = label.indexOf(' = ')\n          label = label.substring(0, idx) + '<br>' + label.substring(idx)\n        }\n\n        // Left: Axis Text\n        const axisIndex = j === 0 ? axis + 'axis' : axis + 'axis' + (j + 1)\n        if (this.layout[axisIndex] == undefined) {\n          this.layout[axisIndex] = {\n            title: {\n              text: axisTitle + (axisTitle ? '<br>' : '') + label,\n            },\n          }\n        } else {\n          if (!this.vizDetails.interactive) {\n            this.layout[axisIndex].title = ''\n            this.layout[axisIndex].title = {\n              text: axisTitle + (axisTitle ? '<br>' : '') + label,\n            }\n            this.layout[axisIndex].anchor = 'y'\n          }\n        }\n\n        result.push(...filteredTraces)\n      }\n      return result\n    },\n\n    createMenus(mode: string) {\n      if (mode == 'none') return\n\n      const buttons: any[] = []\n\n      // index of traces for each group\n      const groups: { [key: string]: number[] } = {}\n\n      const n = Object.values(this.traces).length\n\n      // If the plot is a facetplot the dropdown menu should be created based on the facet_name. otherwise based on the group_name\n      let dropdownLabel = 'group_name'\n      if (this.vizDetails.interactive == 'dropdown' && this.isUsingFacets) {\n        dropdownLabel = 'facet_name'\n      }\n\n      Object.values(this.traces).forEach((tr, idx) => {\n        // restore the indended legend label\n        if ('original_name' in tr) {\n          tr.name = tr.original_name\n        }\n\n        if (!(tr[dropdownLabel] in groups)) groups[tr[dropdownLabel]] = []\n\n        groups[tr[dropdownLabel]].push(idx)\n\n        tr.visible = false\n      })\n\n      Object.entries(groups).forEach(kv => {\n        const [group, ids] = kv\n\n        const arr = new Array(n)\n        arr.fill(false)\n\n        for (const idx of ids as any[]) {\n          arr[idx] = true\n        }\n\n        buttons.push({\n          method: 'update',\n          args: [{ visible: arr }],\n          label: group,\n        })\n      })\n\n      const first = Object.values(groups)[0]\n      for (const idx of first) {\n        this.traces[idx].visible = true\n      }\n\n      const layout: any = this.layout\n\n      if (mode == 'dropdown') {\n        const updatemenus = [\n          {\n            buttons: buttons,\n            y: 1,\n            yanchor: 'top',\n          },\n        ]\n        layout.updatemenus = updatemenus\n      } else if (mode == 'slider') {\n        const sliders = [\n          {\n            pad: { t: 10 },\n            currentvalue: {\n              visible: false,\n              xanchor: 'left',\n              prefix: '',\n            },\n            steps: buttons,\n          },\n        ]\n        layout.sliders = sliders\n      }\n    },\n\n    updateTheme() {\n      const colors = {\n        paper_bgcolor: BG_COLOR_DASHBOARD[this.globalState.colorScheme],\n        plot_bgcolor: this.isUsingFacets\n          ? BG_COLOR_PLOTLY_FACETS[this.globalState.colorScheme]\n          : BG_COLOR_DASHBOARD[this.globalState.colorScheme],\n        font: { color: this.globalState.isDarkMode ? '#cccccc' : '#444444' },\n      }\n      this.layout = Object.assign({}, this.layout, colors)\n    },\n\n    async getVizDetails() {\n      if (this.config) {\n        this.vizDetails = JSON.parse(JSON.stringify(this.config))\n\n        this.$emit('title', this.vizDetails.title || 'Chart')\n        if (this.vizDetails.traces) this.traces = this.vizDetails.traces\n        return\n      }\n\n      // might be a project config:\n      this.loadingText = 'Loading config...'\n      const config = this.yamlConfig ?? ''\n      const filename = config.indexOf('/') > -1 ? config : this.subfolder + '/' + config\n\n      try {\n        const text = await this.fileApi.getFileText(filename)\n        const parsed = yaml.parse(text)\n        this.vizDetails = parsed\n        if (!this.vizDetails.title) this.vizDetails.title = 'Chart'\n        this.$emit('title', this.vizDetails.title)\n      } catch (e) {\n        this.$emit('error', '' + e)\n      }\n    },\n\n    async prepareData(): Promise<any> {\n      await Promise.all(\n        Object.entries(this.vizDetails.datasets).map(kv => {\n          let [key, value] = kv\n\n          // Dataset can be single string or full object\n          if (typeof value === 'string') {\n            value = {\n              file: value,\n            }\n          }\n\n          return this.loadDataset(key, value as DataSet)\n        })\n      )\n\n      if (this.vizDetails.mergeDatasets && Object.values(this.vizDetails.datasets).length > 1) {\n        this.vizDetails.datasets = {\n          dataset: {\n            name: 'dataset',\n            file: 'none',\n            data: this.mergeDatasets(Object.values(this.vizDetails.datasets)),\n          },\n        }\n      }\n\n      const datasets = Object.values(this.vizDetails.datasets) as DataSet[]\n      const traces = [] as any[]\n      const color = this.getColors(this.vizDetails, this.vizDetails.traces.length)\n\n      this.vizDetails.traces.forEach((tr: any, trIdx: number) => {\n        // Grouped traces won't be added without its group\n        let grouped = false\n\n        datasets.forEach((ds: DataSet) => {\n          // This data uses array as name and needs to be split into multiple traces.\n          const name = '$' + ds.name\n\n          if (tr.name?.startsWith(name)) {\n            const ref = tr.name.replace(name + '.', '')\n            const groups = this.groupDataTable(ds.data as DataTable, ref)\n\n            const n = Object.keys(groups).length\n            const c = this.getColors(tr, n)\n\n            Object.keys(groups).forEach((group, idx) => {\n              const copy = JSON.parse(JSON.stringify(tr))\n\n              copy.name = group\n              copy.group_name = group\n              this.recursiveCheckForTemplate(groups[group], copy, name)\n\n              if (c) {\n                if (!('marker' in tr)) copy.marker = {}\n                copy.marker.color = c[idx]\n              }\n              traces.push(copy)\n            })\n\n            grouped = true\n          } else {\n            this.recursiveCheckForTemplate(ds.data as DataTable, tr, name)\n          }\n        })\n\n        if (!grouped) {\n          if (color) {\n            // Assign marker\n            if (!('marker' in tr)) tr.marker = {}\n\n            tr.marker.color = color[trIdx]\n          }\n          traces.push(tr)\n        }\n      })\n\n      this.vizDetails.traces = traces\n    },\n\n    async loadDataset(name: string, ds: DataSet): Promise<DataSet> {\n      this.loadingText = 'Loading datasets...'\n\n      try {\n        const csvData = await this.myDataManager.getDataset(\n          { dataset: ds.file },\n          { highPrecision: true }\n        )\n\n        ds.data = csvData.allRows\n        ds.name = name\n\n        this.vizDetails.datasets[name] = ds\n        this.transformData(ds)\n\n        return ds\n      } catch {\n        this.$emit('error', 'Error loading ' + ds.file)\n        return { file: name }\n      }\n    },\n\n    getColors(conf: any, n: number): null | string[] {\n      if ('colorRamp' in conf) {\n        const ramp = typeof conf.colorRamp === 'string' ? { ramp: conf.colorRamp } : conf.colorRamp\n        // Produce at least two color or strange effects happen\n        return getColorRampHexCodes(ramp, n >= 2 ? n : 2)\n      }\n\n      return null\n    },\n\n    // Transform dataset if requested\n    transformData(ds: DataSet) {\n      if ('pivot' in ds) {\n        this.pivot(\n          ds.name as string,\n          ds.data as DataTable,\n          ds.pivot.exclude,\n          ds.pivot.valuesTo,\n          ds.pivot.namesTo\n        )\n      }\n\n      if ('rename' in ds) {\n        this.renameColumns(ds.data as DataTable, ds.rename, ds.pivot?.namesTo || 'names')\n      }\n\n      if ('normalize' in ds) {\n        this.normalizeColumns(ds.data as DataTable, ds.normalize)\n      }\n\n      if ('aggregate' in ds) {\n        this.aggregateColumns(ds.data as DataTable, ds.aggregate.groupBy, ds.aggregate.target)\n      }\n\n      if ('constant' in ds) {\n        Object.entries(ds.constant!).forEach(kv => {\n          const [column, value] = kv\n\n          const values = new Array(Object.values(ds.data!)[0].values.length)\n          values.fill(value)\n\n          ds.data![column] = {\n            name: column,\n            values: values,\n            type: 1,\n          }\n        })\n      }\n    },\n\n    countOccurrences(array: Float64Array | Float32Array | any[]): { [key: string]: number } {\n      let counts = {} as { [key: string]: number }\n      array.forEach((el: any) => {\n        counts[el] = counts[el] ? counts[el] + 1 : 1\n      })\n\n      return counts\n    },\n\n    // Group data table by values in columnName and generate multiple tables\n    groupDataTable(dataTable: DataTable, columnName: string): { [key: string]: DataTable } {\n      let obj = {} as { [key: string]: DataTable }\n\n      let column = dataTable[columnName]\n\n      let occ = this.countOccurrences(column.values)\n\n      // Copy all columns and initialize as empty\n      Object.entries(occ).forEach(kv => {\n        const [group, n] = kv\n\n        let dt = {} as DataTable\n\n        // Shallow copy each column\n        Object.entries(dataTable).forEach(kv => {\n          const [key, column] = kv\n          dt[key] = { ...column }\n\n          let c = Object.getPrototypeOf(column.values).constructor\n\n          // Construct array of same type\n          dt[key].values = new c(n)\n        })\n\n        obj[group] = dt\n      })\n\n      for (var i = 0; i < dataTable[columnName].values.length; i++) {\n        var group = dataTable[columnName].values[i]\n        let target = obj[group]\n\n        // determine index by subtracting the total for each group\n        let idx = target[columnName].values.length - occ[group]--\n\n        // Copy columns\n        Object.entries(dataTable).forEach(kv => {\n          const [key, column] = kv\n\n          target[key].values[idx] = column.values[i]\n        })\n      }\n\n      return obj\n    },\n\n    // Aggregate columns, currently only sum\n    aggregateColumns(dataTable: DataTable, groupBy: any[], target: string) {\n      const aggr = {} as any\n\n      const n = dataTable[Object.keys(dataTable)[0]].values.length\n\n      for (let i = 0; i < n; i++) {\n        const k = groupBy.reduce((acc, column) => (acc += dataTable[column].values[i]), '')\n\n        if (k in aggr) {\n          aggr[k][target] += dataTable[target].values[i]\n        } else {\n          aggr[k] = Object.fromEntries(groupBy.map(column => [column, dataTable[column].values[i]]))\n          aggr[k][target] = dataTable[target].values[i]\n        }\n      }\n\n      // Remove the unneeded columns\n      Object.keys(dataTable).forEach(column => {\n        if (groupBy.indexOf(column) == -1 && column != target) delete dataTable[column]\n      })\n\n      // Initial empty arrays for final columns\n      const values = Object.fromEntries([...groupBy, target].map(c => [c, []])) as any\n\n      Object.values(aggr).forEach((a: any) => {\n        Object.entries(a).forEach(cv => {\n          values[cv[0]].push(cv[1])\n        })\n      })\n\n      Object.entries(values).forEach(kv => {\n        dataTable[kv[0]].values = kv[1] as any[]\n      })\n    },\n\n    renameColumns(dataTable: DataTable, rename: any, column: string) {\n      // rename columns\n      if (rename && column in dataTable) {\n        const values = dataTable[column].values\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] in rename) {\n            values[i] = rename[values[i]]\n          }\n        }\n      }\n    },\n\n    normalizeColumns(dataTable: DataTable, normalize: any) {\n      // normalize values\n      if (normalize) {\n        const { groupBy, target } = normalize\n\n        const sumMap: { [key: string]: number } = {}\n\n        for (let i = 0; i < dataTable[target].values.length; i++) {\n          let key = ''\n          for (let j = 0; j < groupBy.length; j++) {\n            key += dataTable[groupBy[j]].values[i]\n          }\n\n          if (sumMap[key] === undefined) {\n            sumMap[key] = dataTable[target].values[i]\n          } else {\n            sumMap[key] += dataTable[target].values[i]\n          }\n        }\n\n        for (let i = 0; i < dataTable[target].values.length; i++) {\n          let key = ''\n          for (let j = 0; j < groupBy.length; j++) {\n            key += dataTable[groupBy[j]].values[i]\n          }\n\n          dataTable[target].values[i] /= sumMap[key]\n        }\n      }\n    },\n\n    // Pivot wide to long format\n    pivot(name: string, dataTable: DataTable, exclude: any[], valuesTo: string, namesTo: string) {\n      // Columns to pivot\n      const pivot = Object.keys(dataTable).filter(k => exclude.indexOf(k) == -1)\n\n      exclude.forEach(column => {\n        if (!(column in dataTable)) {\n          this.$emit('error', `Pivot column ${column} not in ${name}`)\n        }\n      })\n\n      // New data entries\n      const columns = Object.fromEntries(exclude.map(c => [c, []]))\n\n      // Pivot target arrays\n      const values = [] as any[]\n      const names = [] as any[]\n\n      const n = dataTable[Object.keys(dataTable)[0]].values.length\n\n      for (let i = 0; i < n; i++) {\n        pivot.forEach(c => {\n          exclude.forEach(c => columns[c].push(dataTable[c].values[i]))\n          names.push(c)\n          values.push(dataTable[c].values[i])\n        })\n      }\n\n      exclude.forEach(c => {\n        dataTable[c].values = columns[c]\n      })\n      dataTable[valuesTo] = { name: valuesTo, values: values } as DataTableColumn\n      dataTable[namesTo] = { name: namesTo, values: names } as DataTableColumn\n    },\n\n    mergeDatasets(datasets: DataSet[]): DataTable {\n      const data = {} as DataTable\n      const first = datasets[0].data!\n\n      Object.keys(first).forEach((column: string) => {\n        const mapped = datasets.map(ds => {\n          if (!(column in ds.data!)) {\n            this.$emit('error', `Merged dataset ${ds.name} does not contain column ${column}`)\n          }\n\n          return ds.data![column].values\n        })\n\n        // Need to distinguish primitive arrays and standard ones\n        let values\n        if (\n          first[column].values instanceof Float32Array ||\n          first[column].values instanceof Float64Array\n        )\n          values = mergeTypedArrays(mapped as Array<any>[])\n        else values = mapped.flat()\n\n        data[column] = {\n          name: column,\n          type: first[column].type,\n          values: values,\n        }\n      })\n\n      return data\n    },\n\n    recursiveCheckForTemplate(dataTable: DataTable, object: any, template: string) {\n      Object.entries(object).forEach(kv => {\n        const [key, value] = kv\n        if (typeof value === 'string') {\n          // string stuff\n          if (value.includes(template)) {\n            const column = value.substring(value.indexOf('.') + 1)\n            if (column in dataTable) {\n              // Merge two columns into a multi index\n              if (this.vizDetails.multiIndex && column in this.vizDetails.multiIndex) {\n                // This creates a tuples of two arrays that has special handling in plotly\n                object[key] = [\n                  dataTable[column].values,\n                  dataTable[this.vizDetails.multiIndex[column]].values,\n                ]\n              }\n              // Normal way to add values into the column\n              else object[key] = dataTable[column].values\n            } else {\n              this.$emit('error', `Column \"${column}\" not in ${Object.keys(dataTable)}`)\n            }\n          }\n        } else if (Array.isArray(value)) {\n          // array stuff\n          if (typeof value[0] == 'object') {\n            value.forEach(v => this.recursiveCheckForTemplate(dataTable, v, template))\n          }\n        } else if (typeof value == 'object') {\n          this.recursiveCheckForTemplate(dataTable, value, template)\n        }\n      })\n    },\n  },\n})\n\nexport default MyComponent\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.mycomponent {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  // margin: 1rem;\n}\n\n.mycomponent.is-thumbnail {\n  padding-top: 0;\n  height: $thumbnailHeight;\n}\n\n.myplot {\n  height: 100%;\n  width: 100%;\n  flex: 1;\n  margin: 0 auto;\n}\n\n.myplot.is-thumbnail {\n  padding: 0rem 0rem;\n  margin: 0 0;\n}\n</style>\n","<template lang=\"pug\">\nplotly-diagram.plotly-panel(\n  :root=\"fileSystemConfig.slug\"\n  :subfolder=\"subfolder\"\n  :config=\"config\"\n  :thumbnail=\"false\"\n  :resize=\"resizeEvent\"\n  @error=\"$emit('error', $event)\"\n)\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nimport { FileSystemConfig } from '@/Globals'\nimport PlotlyDiagram from '@/plugins/plotly/PlotlyDiagram.vue'\n\nexport default defineComponent({\n  name: 'PlotlyDiagramPanel',\n  components: { PlotlyDiagram },\n\n  data: () => {\n    return {\n      resizeEvent: {} as any,\n    }\n  },\n\n  props: {\n    fileSystemConfig: { type: Object as PropType<FileSystemConfig>, required: true },\n    subfolder: { type: String, required: true },\n    config: { type: Object, required: true },\n    cardId: String,\n  },\n  mounted() {\n    this.$emit('isLoaded')\n    this.$emit('dimension-resizer', { id: this.cardId, resizer: this.changeDimensions })\n  },\n  methods: {\n    changeDimensions(event: any) {\n      this.resizeEvent = event\n    },\n  },\n})\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.plotly-panel {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  // background-color: cyan;\n}\n</style>\n"],"names":["i18n","MyComponent","defineComponent","VuePlotly","globalStore","DashboardDataManager","UI_FONT","HTTPFileSystem","svnProject","a","event","err","i","yAxisMin","yAxisMax","xAxisMin","xAxisMax","dim","mergedLayout","facet_col","facet_row","element","index","yAxisTitle","xAxisTitle","result","numRows","numCols","filterTrace","colorIndex","color","numberOfColumns","numberOfRows","j","row","col","filteredTraces","trace","filteredX","filteredY","l","xAxisIndex","yAxisIndex","numberOfFacets","axisTitle","facets","axis","facetObjectKey","label","idx","axisIndex","mode","buttons","groups","n","dropdownLabel","tr","kv","group","ids","arr","first","layout","updatemenus","sliders","colors","BG_COLOR_DASHBOARD","BG_COLOR_PLOTLY_FACETS","config","filename","text","parsed","yaml","e","key","value","datasets","traces","trIdx","grouped","ds","name","_a","ref","c","copy","csvData","conf","ramp","getColorRampHexCodes","column","values","array","counts","el","dataTable","columnName","obj","occ","dt","target","groupBy","aggr","k","acc","cv","rename","normalize","sumMap","exclude","valuesTo","namesTo","pivot","columns","names","data","mapped","mergeTypedArrays","object","template","v","_sfc_main","PlotlyDiagram"],"mappings":"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"}