{"version":3,"file":"LegendColors-103b9dc7.js","sources":["../../node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js","../../node_modules/@deck.gl/extensions/dist/esm/path-style/path-style.js","../../src/components/LegendColors.tsx"],"sourcesContent":["export const dashShaders = {\n  inject: {\n    'vs:#decl': \"\\nattribute vec2 instanceDashArrays;\\nattribute float instanceDashOffsets;\\nvarying vec2 vDashArray;\\nvarying float vDashOffset;\\n\",\n    'vs:#main-end': \"\\nvDashArray = instanceDashArrays;\\nvDashOffset = instanceDashOffsets / width.x;\\n\",\n    'fs:#decl': \"\\nuniform float dashAlignMode;\\nuniform float capType;\\nuniform bool dashGapPickable;\\nvarying vec2 vDashArray;\\nvarying float vDashOffset;\\n\\nfloat round(float x) {\\n  return floor(x + 0.5);\\n}\\n\",\n    'fs:#main-start': \"\\n  float solidLength = vDashArray.x;\\n  float gapLength = vDashArray.y;\\n  float unitLength = solidLength + gapLength;\\n\\n  float offset;\\n\\n  if (unitLength > 0.0) {\\n    if (dashAlignMode == 0.0) {\\n      offset = vDashOffset;\\n    } else {\\n      unitLength = vPathLength / round(vPathLength / unitLength);\\n      offset = solidLength / 2.0;\\n    }\\n\\n    float unitOffset = mod(clamp(vPathPosition.y, 0.0, vPathLength) + offset, unitLength);\\n\\n    if (gapLength > 0.0 && unitOffset > solidLength) {\\n      if (capType <= 0.5) {\\n        if (!(dashGapPickable && picking_uActive)) {\\n          discard;\\n        }\\n      } else {\\n        // caps are rounded, test the distance to solid ends\\n        float distToEnd = length(vec2(\\n          min(unitOffset - solidLength, unitLength - unitOffset),\\n          vPathPosition.x\\n        ));\\n        if (distToEnd > 1.0) {\\n          if (!(dashGapPickable && picking_uActive)) {\\n            discard;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\"\n  }\n};\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': \"\\nattribute float instanceOffsets;\\n\",\n    'vs:DECKGL_FILTER_SIZE': \"\\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\\n  size *= offsetWidth;\\n\",\n    'vCornerOffset = offsetVec;': \"\\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\\n  vec2 offsetCenter = -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;\\n  vCornerOffset = vCornerOffset * offsetWidth - offsetCenter;\\n\",\n    'fs:#main-start': \"\\n  float isInside;\\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\\n  if (isInside == 0.0) {\\n    discard;\\n  }\\n\"\n  }\n};\n//# sourceMappingURL=shaders.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { dashShaders, offsetShaders } from './shaders.glsl';\nimport { dist } from 'gl-matrix/vec3';\nconst defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false,\n  dashGapPickable: false\n};\nexport default class PathStyleExtension extends LayerExtension {\n  constructor({\n    dash = false,\n    offset = false,\n    highPrecisionDash = false\n  } = {}) {\n    super({\n      dash: dash || highPrecisionDash,\n      offset,\n      highPrecisionDash\n    });\n  }\n\n  isEnabled(layer) {\n    return 'pathTesselator' in layer.state;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    let result = {};\n\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager || !extension.isEnabled(this)) {\n      return;\n    }\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        }\n      });\n    }\n\n    if (extension.opts.highPrecisionDash) {\n      attributeManager.addInstanced({\n        instanceDashOffsets: {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        }\n      });\n    }\n\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {\n          size: 1,\n          accessor: 'getOffset'\n        }\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n    let p;\n    let prevP;\n\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n\n    return result;\n  }\n\n}\n\n_defineProperty(PathStyleExtension, \"defaultProps\", defaultProps);\n\n_defineProperty(PathStyleExtension, \"extensionName\", 'PathStyleExtension');\n//# sourceMappingURL=path-style.js.map","import { LegendItem } from '@/Globals'\nimport React from 'react'\n\nexport default function Component(props: {\n  title: string\n  description?: string\n  values: number[]\n  items: LegendItem[]\n}) {\n  const listItems = props.items.map(item => (\n    <li key={item.value + item.value[0]}>\n      <div\n        style={{\n          width: '100%',\n          height: `${Math.max(1, 3.0 * (1 * item.value - 1) + 3)}px`,\n          backgroundColor: `rgb(${item.color})`,\n        }}\n      ></div>\n      {item.label && <div style={{ marginBottom: '0.5rem' }}>{item.label}</div>}\n    </li>\n  ))\n\n  return (\n    <div>\n      <h4\n        style={{\n          textAlign: 'left',\n          fontWeight: 'bold',\n          marginBottom: '0.5rem',\n          fontSize: '0.8rem',\n        }}\n      >\n        {props.title}\n      </h4>\n      <p>{props.description}</p>\n      <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>{listItems}</ul>\n    </div>\n  )\n}\n"],"names":["dashShaders","offsetShaders","defaultProps","PathStyleExtension","LayerExtension","dash","offset","highPrecisionDash","layer","extension","result","mergeShaders","context","attributeManager","params","uniforms","path","positionSize","isNested","geometrySize","p","prevP","i","dist","_defineProperty","Component","props","listItems","item","React"],"mappings":"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","x_google_ignoreList":[0,1]}