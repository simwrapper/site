{"version":3,"file":"PathTraceLayer-1880ad72.js","sources":["../../node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","../../src/components/PlaybackControls.vue","../../src/layers/moving-icons/icon-layer.glsl.vert?raw","../../src/layers/moving-icons/icon-layer.glsl.frag?raw","../../src/layers/moving-icons/icon-manager.ts","../../src/layers/moving-icons/moving-icons-layer.ts","../../src/layers/PathTraceLayer.ts"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { projectPosition } from '../../shaderlib/project/project-functions';\nimport { COORDINATE_SYSTEM } from '../../lib/constants';\nconst DEFAULT_LIGHT_COLOR = [255, 255, 255];\nconst DEFAULT_LIGHT_INTENSITY = 1.0;\nconst DEFAULT_ATTENUATION = [0, 0, 1];\nconst DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];\nlet idCount = 0;\nexport class PointLight {\n  constructor(props = {}) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"color\", void 0);\n\n    _defineProperty(this, \"intensity\", void 0);\n\n    _defineProperty(this, \"type\", 'point');\n\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"attenuation\", void 0);\n\n    _defineProperty(this, \"projectedLight\", void 0);\n\n    const {\n      color = DEFAULT_LIGHT_COLOR\n    } = props;\n    const {\n      intensity = DEFAULT_LIGHT_INTENSITY\n    } = props;\n    const {\n      position = DEFAULT_LIGHT_POSITION\n    } = props;\n    this.id = props.id || \"point-\".concat(idCount++);\n    this.color = color;\n    this.intensity = intensity;\n    this.type = 'point';\n    this.position = position;\n    this.attenuation = getAttenuation(props);\n    this.projectedLight = { ...this\n    };\n  }\n\n  getProjectedLight({\n    layer\n  }) {\n    const {\n      projectedLight\n    } = this;\n    const viewport = layer.context.viewport;\n    const {\n      coordinateSystem,\n      coordinateOrigin\n    } = layer.props;\n    const position = projectPosition(this.position, {\n      viewport,\n      coordinateSystem,\n      coordinateOrigin,\n      fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,\n      fromCoordinateOrigin: [0, 0, 0]\n    });\n    projectedLight.color = this.color;\n    projectedLight.intensity = this.intensity;\n    projectedLight.position = position;\n    return projectedLight;\n  }\n\n}\n\nfunction getAttenuation(props) {\n  if (props.attenuation) {\n    return props.attenuation;\n  }\n\n  if ('intensity' in props) {\n    return [0, 0, props.intensity || 0];\n  }\n\n  return DEFAULT_ATTENUATION;\n}\n//# sourceMappingURL=point-light.js.map","<template lang=\"pug\">\n.slider-thingy\n  b-slider.slider(\n    v-model=\"sliderValue\"\n    v-bind=\"sliderOptions\"\n    size=\"is-large\"\n    @dragging=\"dragging\"\n    @dragstart=\"dragStart\"\n    @dragend=\"dragEnd\")\n\n  .buttons\n    .playpause(@click='toggleSimulation')\n      i.button-icon.fa.fa-1x.fa-pause(v-if=\"isRunning\")\n      i.button-icon.fa.fa-1x.fa-play(v-else)\n\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport * as timeConvert from 'convert-seconds'\n\nexport default defineComponent({\n  name: 'PlaybackControls',\n  props: {\n    isRunning: { type: Boolean, required: true },\n    timeStart: { type: Number, required: true },\n    timeEnd: { type: Number, required: true },\n    currentTime: { type: Number, required: true },\n  },\n  data: () => {\n    return {\n      pauseWhileDragging: false,\n      sliderValue: 0,\n      sliderOptions: {\n        min: 0,\n        max: 1000000,\n        clickable: false,\n        duration: 0,\n        lazy: true,\n        tooltip: true,\n        'tooltip-placement': 'top',\n      } as any,\n    }\n  },\n  mounted() {\n    this.sliderOptions['custom-formatter'] = (v: number) => {\n      return this.convertSecondsToClockTimeMinutes(v)\n    }\n    window.addEventListener('keyup', this.onKeyPressed)\n  },\n\n  beforeDestroy() {\n    window.removeEventListener('keyup', this.onKeyPressed)\n  },\n  watch: {\n    currentTime() {\n      this.sliderValue =\n        (1000000.0 * (this.currentTime - this.timeStart)) / (this.timeEnd - this.timeStart)\n    },\n  },\n\n  methods: {\n    toggleSimulation() {\n      this.$emit('click')\n    },\n\n    convertSecondsToClockTimeMinutes(index: number) {\n      const seconds = this.getSecondsFromSlider(index)\n\n      try {\n        const hms = timeConvert(seconds)\n        const minutes = ('00' + hms.minutes).slice(-2)\n        return `${hms.hours}:${minutes}`\n      } catch (e) {\n        return '00:00'\n      }\n    },\n\n    dragStart() {\n      if (this.isRunning) {\n        this.pauseWhileDragging = true\n        this.$emit('click')\n      }\n    },\n\n    dragEnd() {\n      if (this.pauseWhileDragging) this.$emit('click')\n      this.pauseWhileDragging = false\n    },\n\n    dragging(value: number) {\n      this.$emit('time', this.getSecondsFromSlider(value))\n    },\n\n    onKeyPressed(ev: KeyboardEvent) {\n      if (ev.code === 'Space') this.toggleSimulation()\n    },\n\n    getSecondsFromSlider(value: number) {\n      let seconds = ((this.timeEnd - this.timeStart) * value) / 1000000.0\n      if (seconds === this.timeEnd) seconds = this.timeEnd - 1\n      return seconds\n    },\n  },\n})\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.slider-thingy {\n  display: flex;\n  flex-direction: row;\n  z-index: 1;\n}\n\n.slider {\n  margin: auto 0;\n  flex: 1;\n  font-weight: bold;\n}\n\n.buttons {\n  margin: 0 0 0 2rem;\n}\n\n.playpause {\n  width: 3rem;\n  height: 3rem;\n  border-radius: 50%;\n  color: white;\n  background-color: $themeColor;\n  display: flex;\n  text-align: center;\n  // box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.25);\n  cursor: pointer;\n  pointer-events: auto;\n}\n\n.playpause:hover {\n  background-color: #39a8f1;\n  border: 2px solid white;\n}\n\n.button-icon {\n  margin: auto auto;\n}\n\n@media only screen and (max-width: 640px) {\n  .slider-thingy {\n    display: flex;\n    flex-direction: row;\n  }\n\n  .slider {\n    flex: 1;\n    margin: auto 0rem;\n  }\n\n  .buttons {\n    margin: 0.25rem 0 0 2rem;\n  }\n}\n</style>\n","export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\n//\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME icon-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceSizes;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec4 instanceIconFrames;\\nattribute float instanceColorModes;\\nattribute vec2 instanceOffsets;\\nattribute vec2 instancePixelOffset;\\n\\nuniform float sizeScale;\\nuniform vec2 iconsTextureDim;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform bool billboard;\\n\\nuniform float currentTime;\\n\\nuniform vec2 iconStillOffsets;\\nuniform vec4 iconStillFrames;\\n\\nattribute float instanceTimestamps;\\nattribute float instanceTimestampsNext;\\nattribute vec2 instanceStartPositions;\\nattribute vec2 instanceEndPositions;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\nvarying float vPercentComplete;\\n\\n// ------------------------------------------------------------------\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle_radian) {\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvec3 interpolate(in vec3 point1, in vec3 point2, in float timestepFraction) {\\n    if (timestepFraction <= 0.0) {\\n        return point1;\\n    } else if (timestepFraction >= 1.0 ) {\\n        return point2;\\n    } else {\\n        vec3 direction = point2 - point1;\\n        return point1 + (direction * timestepFraction);\\n    }\\n}\\n\\nvoid main(void) {\\n\\n  // Calculate progress:\\n  // Skip everything else if this vertex is outside the time window\\n  if (currentTime < instanceTimestamps) {\\n    vPercentComplete = -1.0;\\n    return;\\n  } else if (currentTime > instanceTimestampsNext) {\\n    vPercentComplete = -1.0;\\n    return;\\n  } else {\\n    vPercentComplete = (currentTime - instanceTimestamps) /\\n                       (instanceTimestampsNext - instanceTimestamps);\\n  }\\n\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vec3 startPosition = vec3(instanceStartPositions, 5.0);\\n  vec3 endPosition = vec3(instanceEndPositions, 5.0);\\n\\n  // are we stationary/still\\n  bool still = (instanceStartPositions == instanceEndPositions);\\n\\n  // geometry.uv = positions;\\n  // uv = positions;\\n\\n  // this could be the problem right here;\\n  vec2 iconSize = still ? iconStillFrames.zw : instanceIconFrames.zw;\\n  // convert size in meters to pixels, then scaled and clamp\\n  // project meters to pixels and clamp to limits\\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale),\\n    sizeMinPixels, sizeMaxPixels\\n  );\\n\\n  // scale icon height to match instanceSize\\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\\n\\n  // // figure out angle based on motion direction\\n  float angle = 0.0;\\n  if (!still) {\\n    vec3 direction = normalize(endPosition - startPosition);\\n    angle = atan( direction.y / direction.x);\\n    if (direction.x < 0.0) angle = angle - PI;\\n  }\\n\\n  // scale and rotate vertex in \\\"pixel\\\" value and convert back to fraction in clipspace\\n  vec2 pixelOffset = positions / 2.0 * iconSize + (still ? iconStillOffsets : instanceOffsets);\\n  pixelOffset = rotate_by_angle(pixelOffset, angle) * instanceScale;\\n  pixelOffset += instancePixelOffset;\\n  pixelOffset.y *= -1.0;\\n\\n  vec3 newPosition = interpolate(startPosition, endPosition, vPercentComplete);\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), vec3(0.0), geometry.position);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), offset_common, geometry.position);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  vec2 upperleft = (still ? iconStillFrames.xy : instanceIconFrames.xy);\\n\\n  vTextureCoords = mix(\\n    upperleft,\\n    upperleft + iconSize,\\n    (positions.xy + 1.0) / 2.0\\n  ) / iconsTextureDim;\\n\\n  vColor = instanceColors;\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n\\n  vColorMode = instanceColorModes;\\n}\\n\"","export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\n//\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME icon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float opacity;\\nuniform sampler2D iconsTexture;\\nuniform float alphaCutoff;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nuniform float currentTime;\\nvarying float vPercentComplete;\\n\\nvoid main(void) {\\n\\n  if (vPercentComplete == -1.0) discard;\\n\\n  geometry.uv = uv;\\n\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\n\\n  // if colorMode == 0, use pixel color from the texture\\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\\n  // Take the global opacity and the alpha from vColor into account for the alpha component\\n  float a = texColor.a * opacity * vColor.a;\\n\\n  if (a < alphaCutoff) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vec4(color, a);\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\"","// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\n//\n/* global document */\nimport GL from '@luma.gl/constants'\nimport { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core'\nimport { ImageLoader } from '@loaders.gl/images'\nimport { load } from '@loaders.gl/core'\nimport { createIterable } from '@deck.gl/core'\n\nconst DEFAULT_CANVAS_WIDTH = 1024\nconst DEFAULT_BUFFER = 4\n\nconst noop = () => {}\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n}\n\nfunction nextPowOfTwo(number: number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)))\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx: any, imageData: any, width: any, height: any) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData\n  }\n\n  ctx.canvas.height = height\n  ctx.canvas.width = width\n\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height)\n\n  return ctx.canvas\n}\n\nfunction getIconId(icon: any) {\n  return icon && (icon.id || icon.url)\n}\n\n// resize texture without losing original data\nfunction resizeTexture(gl: any, texture: any, width: any, height: any) {\n  const oldWidth = texture.width\n  const oldHeight = texture.height\n\n  const newTexture = cloneTextureFrom(texture, { width, height })\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight,\n  })\n\n  texture.delete()\n  return newTexture\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping: any, columns: any, yOffset: any) {\n  for (let i = 0; i < columns.length; i++) {\n    const { icon, xOffset } = columns[i]\n    const id = getIconId(icon)\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset,\n    }\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\n * @param buffer {Number} add buffer to the right and bottom side of the image\n * @param xOffset {Number} right position of last icon in old mapping\n * @param yOffset {Number} top position in last icon in old mapping\n * @param rowHeight {Number} rowHeight of the last icon's row\n * @param canvasWidth {Number} max width of canvas\n * @param mapping {object} old mapping\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth,\n}: any) {\n  let columns = []\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i]\n    const id = getIconId(icon)\n\n    if (!mapping[id]) {\n      const { height, width } = icon\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset)\n\n        xOffset = 0\n        yOffset = rowHeight + yOffset + buffer\n        rowHeight = 0\n        columns = []\n      }\n\n      columns.push({\n        icon,\n        xOffset,\n      })\n\n      xOffset = xOffset + width + buffer\n      rowHeight = Math.max(rowHeight, height)\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset)\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer),\n  }\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data: any, getIcon: any, cachedIcons: any) {\n  if (!data || !getIcon) {\n    return null\n  }\n\n  cachedIcons = cachedIcons || {}\n  const icons = {} as any\n  const { iterable, objectInfo } = createIterable(data)\n  for (const object of iterable) {\n    objectInfo.index++\n    const icon = getIcon(object, objectInfo)\n    const id = getIconId(icon)\n\n    if (!icon) {\n      throw new Error('Icon is missing.')\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.')\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index }\n    }\n  }\n  return icons\n}\n\nexport default class IconManager {\n  gl: any\n  onUpdate: () => void\n  onError: (e: any) => any\n  _loadOptions: any\n  _getIcon: any\n  _texture: any\n  _externalTexture: any\n  _mapping: any\n  _pendingCount: number\n  _autoPacking: boolean\n  _xOffset: number\n  _yOffset: number\n  _rowHeight: number\n  _buffer: number\n  _canvasWidth: number\n  _canvasHeight: number\n  _canvas: any\n\n  constructor(\n    gl: any,\n    {\n      onUpdate = noop, // notify IconLayer when icon texture update\n      onError = noop,\n    }\n  ) {\n    this.gl = gl\n    this.onUpdate = onUpdate\n    this.onError = onError\n\n    // load options used for loading images\n    this._loadOptions = null\n    this._getIcon = null\n\n    this._texture = null\n    this._externalTexture = null\n    this._mapping = {}\n    // count of pending requests to fetch icons\n    this._pendingCount = 0\n\n    this._autoPacking = false\n\n    // internal props used when autoPacking applied\n    // right position of last icon\n    this._xOffset = 0\n    // top position of last icon\n    this._yOffset = 0\n    this._rowHeight = 0\n    this._buffer = DEFAULT_BUFFER\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH\n    this._canvasHeight = 0\n    this._canvas = null\n  }\n\n  finalize() {\n    this._texture?.delete()\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture\n  }\n\n  getIconMapping(icon: any) {\n    const id = this._autoPacking ? getIconId(icon) : icon\n    return this._mapping[id] || {}\n  }\n\n  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon }: any) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking\n    }\n\n    if (getIcon) {\n      this._getIcon = getIcon\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping\n    }\n\n    if (iconAtlas) {\n      this._updateIconAtlas(iconAtlas)\n    }\n\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n      this._canvas = this._canvas || document.createElement('canvas')\n\n      this._updateAutoPacking(data)\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0\n  }\n\n  _updateIconAtlas(iconAtlas: any) {\n    this._texture?.delete()\n    this._texture = null\n    this._externalTexture = iconAtlas\n    this.onUpdate()\n  }\n\n  _updateAutoPacking(data: any) {\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {})\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset,\n      })\n\n      this._rowHeight = rowHeight\n      this._mapping = mapping\n      this._xOffset = xOffset\n      this._yOffset = yOffset\n      this._canvasHeight = canvasHeight\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\n        })\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight)\n      }\n\n      this.onUpdate()\n\n      // load images\n      this._loadIcons(icons)\n    }\n  }\n\n  _loadIcons(icons: any) {\n    const ctx = this._canvas.getContext('2d')\n\n    for (const icon of icons) {\n      this._pendingCount++\n      load(icon.url, ImageLoader, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon)\n          const { x, y, width, height } = this._mapping[id]\n\n          const data = resizeImage(ctx, imageData, width, height)\n\n          this._texture.setSubImageData({\n            data,\n            x,\n            y,\n            width,\n            height,\n          })\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap()\n\n          this.onUpdate()\n        })\n        .catch(error => {\n          this.onError({\n            url: icon.url,\n            source: icon.source,\n            sourceIndex: icon.sourceIndex,\n            loadOptions: this._loadOptions,\n            error,\n          })\n        })\n        .finally(() => {\n          this._pendingCount--\n        })\n    }\n  }\n}\n","// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\n//\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { Layer, project32, picking, log } from '@deck.gl/core'\nimport GL from '@luma.gl/constants'\nimport { Model, Geometry } from '@luma.gl/core'\n\nimport vertShader from './icon-layer.glsl.vert?raw'\nimport fragShader from './icon-layer.glsl.frag?raw'\n\nimport IconManager from './icon-manager'\n\nconst DEFAULT_COLOR = [0, 0, 0, 255]\n\nconst defaultProps = {\n  iconAtlas: { type: 'image', value: null, async: true },\n  iconMapping: { type: 'object', value: {}, async: true },\n  sizeScale: { type: 'number', value: 1, min: 0 },\n  billboard: false,\n  sizeUnits: 'pixels',\n  sizeMinPixels: { type: 'number', min: 0, value: 0 }, //  min point radius in pixels\n  sizeMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER }, // max point radius in pixels\n  alphaCutoff: { type: 'number', value: 0.05, min: 0, max: 1 },\n  iconStill: { type: 'object', value: null },\n\n  getIcon: { type: 'accessor', value: (x: any) => x.icon },\n  getColor: { type: 'accessor', value: DEFAULT_COLOR },\n  getSize: { type: 'accessor', value: 1 },\n  getAngle: { type: 'accessor', value: 0 },\n  getPixelOffset: { type: 'accessor', value: [0, 0] },\n\n  getPathStart: { type: 'accessor', value: null },\n  getPathEnd: { type: 'accessor', value: null },\n  getTimeStart: { type: 'accessor', value: null },\n  getTimeEnd: { type: 'accessor', value: null },\n  currentTime: { type: 'number', value: 0 },\n\n  pickable: { type: 'boolean', value: true },\n  onIconError: { type: 'function', value: null, compare: false, optional: true },\n}\n\nexport default class IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({ vs: vertShader, fs: fragShader, modules: [project32, picking] })\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this) as any,\n      }),\n    }\n\n    const attributeManager = this.getAttributeManager()\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceTimestamps: {\n        size: 1,\n        accessor: 'getTimeStart',\n      },\n      instanceTimestampsNext: {\n        size: 1,\n        accessor: 'getTimeEnd',\n      },\n      instanceStartPositions: {\n        size: 2,\n        accessor: 'getPathStart',\n      },\n      instanceEndPositions: {\n        size: 2,\n        accessor: 'getPathEnd',\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1,\n      },\n      instanceOffsets: { size: 2, accessor: 'getIcon', transform: this.getInstanceOffset },\n      instanceIconFrames: { size: 4, accessor: 'getIcon', transform: this.getInstanceIconFrame },\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode,\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle',\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset',\n      },\n    })\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState({ oldProps, props, changeFlags }: any) {\n    super.updateState({ props, oldProps, changeFlags })\n\n    const attributeManager = this.getAttributeManager()\n    const { iconAtlas, iconMapping, data, getIcon } = props\n    const { iconManager } = this.state\n\n    iconManager.setProps({ loadOptions: props.loadOptions })\n\n    let iconMappingChanged = false\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas')\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconAtlas !== props.iconAtlas) {\n        iconManager.setProps({ iconAtlas, autoPacking: false })\n      }\n\n      if (oldProps.iconMapping !== props.iconMapping) {\n        iconManager.setProps({ iconMapping })\n        iconMappingChanged = true\n      }\n    } else {\n      // otherwise, use autoPacking\n      iconManager.setProps({ autoPacking: true })\n    }\n\n    // handle data changed\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      iconManager.setProps({ data, getIcon })\n    }\n\n    if (iconMappingChanged) {\n      attributeManager.invalidate('instanceOffsets')\n      attributeManager.invalidate('instanceIconFrames')\n      attributeManager.invalidate('instanceColorModes')\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const { gl } = this.context\n      this.state.model?.delete()\n      this.state.model = this._getModel(gl)\n      attributeManager.invalidateAll()\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded\n  }\n\n  finalizeState() {\n    super.finalizeState()\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize()\n  }\n\n  draw({ uniforms }: any) {\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff,\n      currentTime,\n      iconStill,\n      pickable,\n    } = this.props\n\n    const { iconManager } = this.state\n    const { viewport } = this.context\n\n    const iconsTexture = iconManager.getTexture()\n    if (iconsTexture) {\n      this.state.model\n        .setUniforms(uniforms)\n        .setUniforms({\n          iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeScale: sizeScale * (sizeUnits === 'pixels' ? viewport.metersPerPixel : 1),\n          sizeMinPixels,\n          sizeMaxPixels,\n          billboard,\n          alphaCutoff,\n          currentTime,\n          pickable,\n          iconStillOffsets: this.getInstanceOffset(iconStill),\n          iconStillFrames: this.getInstanceIconFrame(iconStill),\n        })\n        .draw()\n    }\n  }\n\n  _getModel(gl: any) {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1]\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          // The size must be explicitly passed here otherwise luma.gl\n          // will default to assuming that positions are 3D (x,y,z)\n          positions: {\n            size: 2,\n            value: new Float32Array(positions),\n          },\n        },\n      }),\n      isInstanced: true,\n    })\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw()\n  }\n\n  _onError(evt: any) {\n    const { onIconError } = this.getCurrentLayer().props\n    if (onIconError) {\n      onIconError(evt)\n    } else {\n      log.error(evt.error)()\n    }\n  }\n\n  getInstanceOffset(icon: any) {\n    const rect = this.state.iconManager.getIconMapping(icon)\n    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0]\n  }\n\n  getInstanceColorMode(icon: any) {\n    const mapping = this.state.iconManager.getIconMapping(icon)\n    return mapping.mask ? 1 : 0\n  }\n\n  getInstanceIconFrame(icon: any) {\n    const rect = this.state.iconManager.getIconMapping(icon)\n    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0]\n  }\n}\n\nIconLayer.layerName = 'FlatIconLayer'\nIconLayer.defaultProps = defaultProps\n","import { LineLayer } from '@deck.gl/layers'\n\nconst defaultProps = {\n  currentTime: { type: 'number', value: 0, min: 0 },\n  getTimeStart: { type: 'accessor', value: null },\n  getTimeEnd: { type: 'accessor', value: null },\n  searchFlag: { type: 'number', value: 0 },\n}\n\nexport default class PathTraceLayer extends LineLayer {\n  getShaders() {\n    const shaders = super.getShaders()\n    shaders.inject = {\n      // Timestamp of the vertex\n      'vs:#decl': `\\\n        attribute float timeStart;\n        attribute float timeEnd;\n        uniform float currentTime;\n        uniform float searchFlag;\n        varying float vTime;\n      `,\n      'vs:#main-start': `\\\n        if (searchFlag == 1.0) {\n          vTime = 999.0;\n        } else if(timeStart > currentTime || timeEnd < currentTime ) {\n          vTime = -1.0;\n          return;\n        } else {\n          float nearBeginning = currentTime - timeStart;\n          float nearEnd = timeEnd - currentTime;\n          vTime = min(nearBeginning, nearEnd);\n        }\n      `,\n      'fs:#decl': `\\\n        uniform float currentTime;\n        varying float vTime;\n        uniform float searchFlag;\n      `,\n      'fs:#main-start': `\\\n        if (searchFlag == 0.0 && vTime == -1.0 ) discard;\n      `,\n      // fade the traces in and out\n      'fs:DECKGL_FILTER_COLOR': `\\\n        if (searchFlag == 0.0 && vTime <= 10.0) color.a *= (vTime / 10.0);\n      `,\n    }\n    return shaders\n  }\n\n  initializeState(params: any) {\n    super.initializeState(params)\n\n    const attributeManager = this.getAttributeManager()\n    attributeManager.addInstanced({\n      timeStart: { size: 1, accessor: 'getTimeStart' },\n      timeEnd: { size: 1, accessor: 'getTimeEnd' },\n    })\n  }\n\n  draw(params: any) {\n    const { currentTime, searchFlag } = this.props\n\n    params.uniforms = Object.assign({}, params.uniforms, {\n      currentTime,\n      searchFlag,\n    })\n\n    super.draw(params)\n  }\n}\n\nPathTraceLayer.layerName = 'PathTraceLayer'\nPathTraceLayer.defaultProps = defaultProps\n"],"names":["DEFAULT_LIGHT_COLOR","DEFAULT_LIGHT_INTENSITY","DEFAULT_ATTENUATION","DEFAULT_LIGHT_POSITION","idCount","PointLight","props","_defineProperty","color","intensity","position","getAttenuation","layer","projectedLight","viewport","coordinateSystem","coordinateOrigin","projectPosition","COORDINATE_SYSTEM","_sfc_main","defineComponent","v","index","seconds","hms","timeConvert","minutes","value","ev","vertShader","fragShader","DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","GL","nextPowOfTwo","number","resizeImage","ctx","imageData","width","height","getIconId","icon","resizeTexture","gl","texture","oldWidth","oldHeight","newTexture","cloneTextureFrom","copyToTexture","buildRowMapping","mapping","columns","yOffset","i","xOffset","id","buildMapping","icons","buffer","rowHeight","canvasWidth","getDiffIcons","data","getIcon","cachedIcons","iterable","objectInfo","createIterable","object","IconManager","onUpdate","onError","__publicField","_a","loadOptions","autoPacking","iconAtlas","iconMapping","canvasHeight","Texture2D","load","ImageLoader","x","y","error","DEFAULT_COLOR","defaultProps","IconLayer","Layer","project32","picking","oldProps","changeFlags","attributeManager","iconManager","iconMappingChanged","uniforms","sizeScale","sizeMinPixels","sizeMaxPixels","sizeUnits","billboard","alphaCutoff","currentTime","iconStill","pickable","iconsTexture","positions","Model","Geometry","evt","onIconError","log","rect","PathTraceLayer","LineLayer","shaders","params","searchFlag"],"mappings":"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","x_google_ignoreList":[0]}