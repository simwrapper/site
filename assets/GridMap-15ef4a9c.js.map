{"version":3,"file":"GridMap-15ef4a9c.js","sources":["../../node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","../../node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","../../src/components/TimeSliderV2.vue","../../src/plugins/grid-map/GridLayer.tsx","../../src/plugins/grid-map/GridMap.vue"],"sourcesContent":["import Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\nconst CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);\nconst CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);\nconst CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);\nconst CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\nconst ATTRIBUTES = {\n  POSITION: {\n    size: 3,\n    value: new Float32Array(CUBE_POSITIONS)\n  },\n  NORMAL: {\n    size: 3,\n    value: new Float32Array(CUBE_NORMALS)\n  },\n  TEXCOORD_0: {\n    size: 2,\n    value: new Float32Array(CUBE_TEX_COORDS)\n  }\n};\nexport default class CubeGeometry extends Geometry {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = uid('cube-geometry')\n    } = props;\n    super({ ...props,\n      id,\n      indices: {\n        size: 1,\n        value: new Uint16Array(CUBE_INDICES)\n      },\n      attributes: { ...ATTRIBUTES,\n        ...props.attributes\n      }\n    });\n  }\n\n}\n//# sourceMappingURL=cube-geometry.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CubeGeometry } from '@luma.gl/core';\nimport { UNIT } from '@deck.gl/core';\nimport ColumnLayer from './column-layer';\nconst defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    value: [1, 1]\n  }\n};\nexport default class GridCellLayer extends ColumnLayer {\n  getGeometry(diskResolution) {\n    return new CubeGeometry();\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      elevationScale,\n      extruded,\n      offset,\n      coverage,\n      cellSize,\n      angle,\n      radiusUnits\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      radius: cellSize / 2,\n      radiusUnits: UNIT[radiusUnits],\n      angle,\n      offset,\n      extruded,\n      coverage,\n      elevationScale,\n      edgeDistance: 1,\n      isWireframe: false\n    }).draw();\n  }\n\n}\n\n_defineProperty(GridCellLayer, \"layerName\", 'GridCellLayer');\n\n_defineProperty(GridCellLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=grid-cell-layer.js.map","<template lang=\"pug\">\n.time-slider-component(v-if=\"hasNonZeroTimeRange\" :id=\"`id-${id}`\")\n  .label-area\n    p.p1 {{ state.labels[0] }}\n    p.p2(v-show=\"state.labels[1] !== undefined\") &nbsp;-&nbsp;{{ state.labels[1] }}\n\n  .slider-area\n    button.button.play-button(size=\"is-small\" type=\"is-link\"\n      @click=\"updateAnimation\"\n      ) {{ isAnimating ? '|&nbsp;|' : '>' }}\n\n    .time-slider-dragger(ref=\"slider\" @mousemove=\"dragging\")\n      .active-region(:style=\"calculateActiveMargins\"\n        @mousedown=\"dragStart\" @mouseup.stop=\"dragEnd\" @mousemove.stop=\"dragging\"\n      )\n\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nconst GRAB_HANDLE_WIDTH = 6\n\nenum DRAGTYPE {\n  SLIDE,\n  START,\n  END,\n}\n\nexport default defineComponent({\n  name: 'TimeSliderV2',\n  props: {\n    range: { type: Array as PropType<number[]>, required: true },\n    allTimes: [] as any[],\n  },\n  data: () => {\n    return {\n      state: {\n        componentWidth: 0,\n        dragStartX: 0,\n        dragType: DRAGTYPE.SLIDE,\n        isDragging: false,\n        isSetupComplete: false,\n        leftPosition: 0,\n        rightPosition: 1,\n        datasetRange: [0, 86400],\n        labels: ['', ''],\n        animationElapsedTime: 0,\n        startTime: 0,\n        timeFilter: [0, 3599],\n        animator: null as any,\n        timeLabels: [0, 1] as any[],\n        currentTime: 0 as number,\n      },\n      id: 'id-' + Math.floor(1e12 * Math.random()),\n      resizer: null as ResizeObserver | null,\n      ANIMATE_SPEED: 5,\n      isAnimating: false,\n    }\n  },\n  computed: {\n    // Calculate the total time span of the dataset.\n    fullDatasetTimeSpan(): number {\n      return this.state.datasetRange[1] - this.state.datasetRange[0] + this.allTimes[0]\n    },\n\n    // Calculate the extent from the left to the right position of the slider.\n    extentLeftToRight(): number {\n      return this.state.rightPosition - this.state.leftPosition\n    },\n\n    // Check if the time range is non-zero by comparing start and finish points.\n    hasNonZeroTimeRange(): boolean {\n      // Return false if the start and finish of the range are identical.\n      return !!this.fullDatasetTimeSpan\n    },\n\n    // Calculate the margins for the active region of the slider.\n    calculateActiveMargins(): any {\n      const usableWidth = this.state.componentWidth - 2 * GRAB_HANDLE_WIDTH\n      const marginLeft = Math.floor(usableWidth * this.state.leftPosition)\n      const marginRight = Math.floor(usableWidth * (1.0 - this.state.rightPosition))\n\n      return {\n        marginLeft: `${marginLeft}px`,\n        marginRight: `${marginRight}px`,\n      }\n    },\n  },\n\n  mounted() {\n    // Add zero values to the beginning of the 'allTimes' array to set the time values correctly.\n    this.allTimes.unshift(0)\n    this.range[0] = 0\n\n    // Initialize component dimensions, initial values, and set up the resizer.\n    this.getDimensions()\n    this.setupInitialValues()\n    this.setupResizer()\n\n    // Add event listeners for mouseup and mousemove when the component is mounted.\n    window.addEventListener('mouseup', this.dragEnd)\n    window.addEventListener('mousemove', this.dragging)\n  },\n\n  beforeDestroy() {\n    // Remove event listeners for mouseup and mousemove before the component is destroyed.\n    window.removeEventListener('mouseup', this.dragEnd)\n    window.removeEventListener('mousemove', this.dragging)\n\n    // Cancel the animation frame if it's active to prevent memory leaks.\n    if (this.state.animator) window.cancelAnimationFrame(this.state.animator)\n  },\n\n  watch: {\n    // Watch for changes in 'state.currentTime' and trigger 'updateExtent' when it changes.\n    'state.currentTime'() {\n      this.updateExtent()\n    },\n\n    // Watch for changes in 'labels' and trigger 'updateLabels'.\n    labels() {\n      this.updateLabels()\n    },\n\n    // Watch for changes in 'state.leftPosition' and 'state.rightPosition', and call 'emitValues' to emit updated values.\n    'state.leftPosition'() {\n      this.emitValues()\n    },\n    'state.rightPosition'() {\n      this.emitValues()\n    },\n\n    // 'isAnimating'() {\n    //   this.updateAnimation();\n    // },\n  },\n\n  methods: {\n    /**\n     * Toggles the animation state and initiates or stops the animation loop accordingly.\n     */\n    updateAnimation() {\n      this.isAnimating = !this.isAnimating\n\n      if (this.isAnimating) {\n        // Calculate animation elapsed time and start time to control the animation.\n        this.state.animationElapsedTime = this.state.timeFilter[0] - this.range[0]\n        this.state.startTime = Date.now() - this.state.animationElapsedTime / this.ANIMATE_SPEED\n\n        // Initiate the animation loop.\n        this.animate()\n      }\n    },\n\n    /**\n     * Finds the index of the lower value in the sorted array 'this.allTimes' between which the given parameter lies.\n     *\n     * @param parameter - The value to search for to find the index in the 'this.allTimes' array.\n     * @returns The index of the lower value in the 'this.allTimes' array between which the given parameter lies.\n     *          If the parameter is smaller than the first entry in the array, -1 is returned.\n     */\n    findIndexLessThanOrEqualTo(parameter: number): number {\n      let left = 0\n      let right = this.allTimes.length - 1\n      let result = 0\n\n      while (left <= right) {\n        const mid = Math.floor((left + right) / 2)\n\n        if (this.allTimes[mid] === parameter) {\n          return mid\n        }\n\n        if (this.allTimes[mid] <= parameter) {\n          result = mid\n          left = mid + 1\n        } else {\n          right = mid - 1\n        }\n      }\n      return result\n    },\n\n    /**\n     * Controls the animation loop to update the current time and time filter.\n     * This method calculates the animation progress and updates the relevant state variables.\n     */\n    animate() {\n      if (!this.isAnimating) return\n\n      // Calculate animation elapsed time based on elapsed real-time and animation speed.\n      this.state.animationElapsedTime = this.ANIMATE_SPEED * (Date.now() - this.state.startTime)\n\n      // Calculate the current animation clock time.\n      const animationClockTime = this.state.animationElapsedTime + this.range[0]\n\n      // Update the current time based on the animation clock time.\n      this.state.currentTime = this.findIndexLessThanOrEqualTo(animationClockTime)\n\n      // Check if animation has reached the end of the range.\n      if (animationClockTime > this.range[1] + this.allTimes[0]) {\n        // Restart the animation if it exceeds the range.\n        this.state.startTime = Date.now()\n        this.state.animationElapsedTime = 0\n      }\n\n      // Update the time filter based on the current time.\n      this.state.timeFilter = [\n        this.allTimes[this.state.currentTime],\n        this.allTimes[this.state.currentTime + 1] == undefined\n          ? 0\n          : this.allTimes[this.state.currentTime + 1],\n      ]\n\n      // Request the next animation frame to continue the loop.\n      this.state.animator = window.requestAnimationFrame(this.animate)\n    },\n\n    /**\n     * Sets up a ResizeObserver to monitor changes in component dimensions.\n     * This method attempts to create a ResizeObserver and attach it to the component's DOM element.\n     */\n    setupResizer() {\n      try {\n        // Create a ResizeObserver instance and observe the component's DOM element.\n        this.resizer = new ResizeObserver(this.getDimensions)\n        const sliderElement = document.getElementById(`id-${this.id}`) as HTMLElement\n        this.resizer.observe(sliderElement)\n      } catch (e) {\n        console.error('' + e)\n      }\n    },\n\n    /**\n     * Calculates and sets the initial values for the component's state.\n     * This method initializes dataset range, time filter, and slider positions.\n     */\n    setupInitialValues() {\n      try {\n        // If 'range' is provided, set dataset range and initial time filter.\n        if (this.range) {\n          this.state.datasetRange = this.range\n          this.state.timeFilter = [this.allTimes[0], this.allTimes[1]]\n        }\n\n        // Check if the full dataset time span is zero.\n        if (this.fullDatasetTimeSpan === 0) {\n          this.state.leftPosition = 0\n          this.state.rightPosition = 1\n        } else {\n          // Calculate and update slider positions based on the dataset range.\n          this.updateExtent()\n        }\n      } catch (e) {\n        console.error('' + e)\n        // Handle potential division by zero.\n      } finally {\n        // Mark the setup as complete.\n        this.state.isSetupComplete = true\n      }\n    },\n\n    /**\n     * Updates the slider positions and time labels based on the current time filter.\n     * This method recalculates and sets the left and right slider positions as well as time labels.\n     */\n    updateExtent() {\n      if (!this.state.timeFilter) return\n\n      // Calculate the left and right slider positions based on the current time filter.\n      this.state.leftPosition =\n        (1 / this.fullDatasetTimeSpan) * (this.allTimes[this.state.currentTime] - this.allTimes[0])\n      this.state.rightPosition =\n        (1 / this.fullDatasetTimeSpan) *\n        (this.allTimes[this.state.currentTime + 1] == undefined\n          ? this.allTimes[this.state.currentTime] + this.allTimes[0]\n          : this.allTimes[this.state.currentTime + 1] - this.allTimes[0])\n\n      // Calculate and set time labels.\n      this.state.timeLabels = [\n        this.convertSecondsToClockTimeMinutes(this.allTimes[this.state.currentTime]),\n        this.convertSecondsToClockTimeMinutes(\n          this.allTimes[this.state.currentTime + 1] == undefined\n            ? this.allTimes[this.state.currentTime] + this.allTimes[0]\n            : this.allTimes[this.state.currentTime + 1]\n        ),\n      ]\n\n      // Update labels and complete the update.\n      this.updateLabels()\n    },\n\n    /**\n     * Updates component labels with time labels if available in the state.\n     */\n    updateLabels() {\n      // If time labels are available in the state, update component labels.\n      if (this.state.timeLabels) this.state.labels = this.state.timeLabels\n    },\n\n    /**\n     * Emits time extent values to the parent component when setup is complete.\n     * This method emits the current time filter values to the parent component.\n     */\n    emitValues() {\n      // Check if setup is complete before emitting time extent values.\n      if (!this.state.isSetupComplete) return\n\n      // Emit the current time filter values to the parent component.\n      this.$emit('timeExtent', this.state.timeFilter)\n    },\n\n    /**\n     * Converts a time value in seconds to a clock-style time format in hours and minutes.\n     *\n     * @param index - The time value in seconds to be converted.\n     * @returns A formatted string in the 'hh:mm' clock time format.\n     */\n    convertSecondsToClockTimeMinutes(index: number) {\n      const h = Math.floor(index / 3600)\n      const m = Math.floor((index - h * 3600) / 60)\n\n      // Calculate seconds separately.\n      const s = index - h * 3600 - m * 60\n\n      // Create an object to represent hours, minutes, and seconds.\n      const hms = { h: `${h}`, m: `${m}`.padStart(2, '0'), s: `${s}`.padStart(2, '0') }\n\n      // Return the formatted clock time string.\n      return `${hms.h}:${hms.m}`\n    },\n\n    // Calculates the width of the element\n    getDimensions() {\n      //@ts-ignore - ref doesn't know about clientWidth\n      this.state.componentWidth = this.$refs.slider?.clientWidth || 0\n    },\n\n    /**\n     * Initiates a dragging operation when a mouse click event occurs.\n     *\n     * @param e - The MouseEvent object containing event details.\n     * @emits drag - Emits a 'drag' event to notify parent components of the drag operation.\n     */\n    dragStart(e: MouseEvent) {\n      // Set the 'isDragging' flag to true to indicate a drag operation.\n      this.state.isDragging = true\n\n      // Store the initial mouse position when dragging starts.\n      this.state.dragStartX = e.clientX\n\n      // Calculate various dimensions and update the drag type based on mouse position.\n      const usableWidth = this.state.componentWidth - 2 * GRAB_HANDLE_WIDTH\n      const marginLeft = Math.floor(usableWidth * this.state.leftPosition)\n      const marginRight = Math.floor(usableWidth * (1.0 - this.state.rightPosition))\n\n      // Calculate the width of the time duration area within the slider.\n      const durationWidth =\n        this.state.componentWidth - marginRight - marginLeft - 2 * GRAB_HANDLE_WIDTH\n\n      // Determine the drag type based on the mouse position within the duration area.\n      if (e.offsetX >= 0 && e.offsetX < durationWidth) this.state.dragType = DRAGTYPE.SLIDE\n      else if (e.offsetX < 0) this.state.dragType = DRAGTYPE.START\n      else if (e.offsetX > durationWidth) this.state.dragType = DRAGTYPE.END\n    },\n\n    /**\n     * Handles dragging operations based on mouse movement during dragging.\n     *\n     * @param e - The MouseEvent object containing event details.\n     */\n    dragging(e: MouseEvent) {\n      if (!this.state.isDragging) return\n\n      // Calculate the horizontal movement distance (deltaX) of the mouse.\n      const deltaX = e.clientX - this.state.dragStartX\n      const usableWidth = this.state.componentWidth - 2 * GRAB_HANDLE_WIDTH\n\n      // Check the type of drag operation and update positions accordingly.\n      if (DRAGTYPE.SLIDE == this.state.dragType) {\n        const currentExtent = this.extentLeftToRight\n        let newLeft = (usableWidth * this.state.leftPosition + deltaX) / usableWidth\n        let newRight = newLeft + currentExtent\n\n        // Ensure the draggable window does not exceed the slider's boundaries.\n        if (newLeft < 0) {\n          newLeft = 0\n          newRight = currentExtent\n        }\n\n        if (newRight > 1) {\n          newRight = 1\n          newLeft = newRight - currentExtent\n        }\n\n        this.state.leftPosition = newLeft\n        this.state.rightPosition = newRight\n\n        this.updateLabels()\n        this.updateData()\n\n        this.state.dragStartX = e.clientX\n        return\n      }\n    },\n\n    /**\n     * Handles the end of a dragging operation, resetting the dragging state.\n     *\n     * @param e - The event object associated with the drag end event.\n     */\n    dragEnd(e: MouseEvent) {\n      const newStartTime = this.findIndexLessThanOrEqualTo(\n        this.state.leftPosition * this.fullDatasetTimeSpan + this.allTimes[0]\n      )\n\n      this.state.leftPosition =\n        (1 / this.fullDatasetTimeSpan) * (this.allTimes[newStartTime] - this.allTimes[0])\n      this.state.rightPosition =\n        (1 / this.fullDatasetTimeSpan) *\n        (this.allTimes[newStartTime + 1] == undefined\n          ? this.allTimes[newStartTime] + this.allTimes[0]\n          : this.allTimes[newStartTime + 1] - this.allTimes[0])\n\n      this.state.timeFilter = [\n        this.allTimes[newStartTime] - this.allTimes[0],\n        this.allTimes[newStartTime + 1] == undefined\n          ? this.allTimes[newStartTime] + this.allTimes[0]\n          : this.allTimes[newStartTime + 1] - this.allTimes[0],\n      ]\n\n      this.state.isDragging = false\n    },\n\n    updateData() {\n      const newStartTime = this.findIndexLessThanOrEqualTo(\n        this.state.leftPosition * this.fullDatasetTimeSpan + this.allTimes[0]\n      )\n\n      const newEndTime =\n        this.findIndexLessThanOrEqualTo(\n          this.state.leftPosition * this.fullDatasetTimeSpan + this.allTimes[0]\n        ) + 1\n\n      // Calculate and set time labels.\n      this.state.timeLabels = [\n        this.convertSecondsToClockTimeMinutes(this.allTimes[newStartTime]),\n        this.convertSecondsToClockTimeMinutes(this.allTimes[newEndTime]),\n      ]\n\n      this.state.timeFilter = [this.allTimes[newStartTime], this.allTimes[newEndTime]]\n    },\n  },\n})\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.time-slider-component {\n  display: flex;\n  flex-direction: column;\n}\n\n.slider-area {\n  background-color: var(--bgPanel);\n  padding: 1rem 1rem;\n  display: flex;\n  flex-direction: row;\n}\n\n.time-slider-dragger {\n  user-select: none;\n  height: 1.5rem;\n  background-color: #66669933;\n  border-radius: 4px;\n  max-width: 100%;\n  flex: 1;\n  overflow: hidden;\n}\n\n.active-region {\n  cursor: ew-resize;\n  color: white;\n  background-color: var(--sliderThumb);\n  height: 100%;\n  border-radius: 4px;\n  border-left: 6px solid var(--linkHover);\n  border-right: 6px solid var(--linkHover);\n  font-size: 1rem;\n  line-height: 0.6rem;\n}\n\n.label-area {\n  margin: 0 0;\n  font-size: 1.3rem;\n  font-weight: bold;\n  display: flex;\n  flex-direction: row;\n  margin-right: auto;\n}\n\n.p1 {\n  padding: 0 0;\n  padding-left: 1rem;\n  background-color: var(--bgPanel);\n}\n\n.p2 {\n  padding: 0 0;\n  padding-right: 1rem;\n  background-color: var(--bgPanel);\n}\n\n.play-button {\n  width: 2.4rem;\n  height: 1.5rem;\n  margin-right: 1rem;\n  font-weight: bold;\n  font-size: 0.8rem;\n  line-height: 0.8rem;\n  padding: 0 0;\n}\n</style>\n","import React, { useState } from 'react'\nimport DeckGL from '@deck.gl/react'\nimport { StaticMap } from 'react-map-gl'\nimport { GridCellLayer } from '@deck.gl/layers'\nimport colormap from 'colormap'\n\nimport globalStore from '@/store' // Import global state management store.\nimport { MAPBOX_TOKEN, REACT_VIEW_HANDLES } from '@/Globals' // Import constants and configurations.\n\nimport { CompleteMapData } from './GridMap.vue' // Import data types.\n\ntype TooltipStyle = {\n  color: string\n  backgroundColor: string\n}\n\ntype Tooltip = {\n  html: string\n  style: TooltipStyle\n} | null\n\n// LAYER --------------------------------------------------------\nexport default function Layer({\n  viewId = 0 as number,\n  colorRamp = 'Viridis' as String,\n  dark = false as Boolean,\n  data = {} as CompleteMapData,\n  currentTimeIndex = 0 as number,\n  // extrude = true as Boolean,\n  mapIsIndependent = false as Boolean,\n  maxHeight = 200 as Number,\n  cellSize = 200 as Number,\n  opacity = 0.7 as Number,\n  upperPercentile = 100 as Number,\n}) {\n  // manage SimWrapper centralized viewState - for linked maps\n  const [viewState, setViewState] = useState(globalStore.state.viewState)\n\n  // Handle view state changes\n  REACT_VIEW_HANDLES[viewId] = (view: any) => {\n    if (view) {\n      setViewState(view)\n    } else {\n      setViewState(globalStore.state.viewState)\n    }\n  }\n\n  // Function to handle view state changes\n  function handleViewState(view: any) {\n    // Make shure that latitude and longitude exist in the view object\n    if (!view || typeof view.latitude !== 'number' || typeof view.longitude !== 'number') {\n      return\n    }\n\n    // If the view does not have a center, initialize it to [0, 0]\n    if (!view.center) {\n      view.center = [0, 0]\n    }\n\n    // Set the center based on longitude and latitude\n    view.center[0] = view.longitude\n    view.center[1] = view.latitude\n\n    // Update the view state\n    setViewState(view)\n\n    // Update the global map camera position if it's not independent\n    if (!mapIsIndependent) {\n      globalStore.commit('setMapCamera', view)\n    }\n  }\n\n  function getTooltip(object: any): Tooltip {\n    if (!object?.coordinate) return null\n\n    const currentData = data.mapData[currentTimeIndex]?.values\n    if (!currentData || !currentData[object.index]) return null\n\n    const [lng, lat] = object.coordinate // Koordinaten (Längengrad, Breitengrad)\n    const rawValue = currentData[object.index]\n    const value = rawValue / (data.scaledFactor as number)\n    const roundedValue = Number(value.toFixed(6))\n    const unit = data.unit\n\n    const latDisplay = Number.isFinite(lat) ? lat.toFixed(4) : ''\n    const lngDisplay = Number.isFinite(lng) ? lng.toFixed(4) : ''\n\n    const tooltipHtml = `<b>${roundedValue} ${unit}</b><br/>${latDisplay} / ${lngDisplay}`\n    const tooltipStyle: TooltipStyle = dark\n      ? { color: '#ccc', backgroundColor: '#2a3c4f' }\n      : { color: '#223', backgroundColor: 'white' }\n\n    return {\n      html: tooltipHtml,\n      style: tooltipStyle,\n    }\n  }\n\n  // Generate colors for data visualization using the specified color ramp\n  const colors = colormap({\n    colormap: colorRamp,\n    nshades: 10,\n    format: 'rba',\n    alpha: 1,\n  }).map((c: number[]) => [c[0], c[1], c[2], 255])\n\n  const layers = [\n    new GridCellLayer({\n      id: 'gridlayer',\n      data: {\n        length: data.mapData[currentTimeIndex].length,\n        attributes: {\n          getPosition: { value: data.mapData[currentTimeIndex].centroid, size: 2 },\n          getFillColor: { value: data.mapData[currentTimeIndex].colorData, size: 3 },\n          getElevation: { value: data.mapData[currentTimeIndex].values, size: 1 },\n        },\n      },\n      colorRange: dark ? colors.slice(1) : colors.reverse().slice(1),\n      coverage: 1,\n      autoHighlight: true,\n      elevationRange: [0, maxHeight],\n      elevationScale: maxHeight,\n      pickable: true,\n      opacity,\n      cellSize,\n      upperPercentile,\n      material: false,\n      transitions: {\n        elevationScale: { type: 'interpolation', duration: 50 },\n        // opacity: { type: 'interpolation', duration: 50 },\n      },\n      parameters: {\n        // fixes the z-fighting problem but makes some issues with the opacity...\n        // depthTest: false,\n      },\n    }),\n  ]\n\n  // Render the Deck.gl map component with specified props\n  return (\n    <DeckGL\n      layers={layers}\n      controller={true}\n      useDevicePixels={false}\n      viewState={viewState}\n      getTooltip={getTooltip}\n      onViewStateChange={(e: any) => handleViewState(e.viewState)}\n    >\n      {/* @ts-ignore */}\n      <StaticMap\n        mapStyle={globalStore.getters.mapStyle}\n        preventStyleDiffing={true}\n        mapboxApiAccessToken={MAPBOX_TOKEN}\n      />\n    </DeckGL>\n  )\n}\n","<template lang=\"pug\">\n.xy-hexagons(:class=\"{'hide-thumbnail': !thumbnail}\" oncontextmenu=\"return false\" :id=\"`id-${id}`\")\n\n      grid-layer(\n        v-if=\"!thumbnail && isLoaded\"\n        v-bind=\"mapProps\"\n      )\n\n      zoom-buttons(v-if=\"!thumbnail && isLoaded\" corner=\"bottom\")\n\n      .top-right\n        .gui-config(:id=\"configId\")\n\n      time-slider.time-slider-area(v-if=\"isLoaded\"\n        :range=\"timeRange\"\n        :allTimes=\"allTimes\"\n        @timeExtent=\"handleTimeSliderValues\"\n      )\n\n      .message(v-if=\"!thumbnail && myState.statusMessage\")\n        p.status-message {{ myState.statusMessage }}\n\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nimport GUI from 'lil-gui'\nimport { ToggleButton } from 'vue-js-toggle-button'\nimport YAML from 'yaml'\nimport colormap from 'colormap'\nimport { hexToRgb, getColorRampHexCodes, Ramp } from '@/js/ColorsAndWidths'\n\nimport util from '@/js/util'\nimport globalStore from '@/store'\nimport { REACT_VIEW_HANDLES } from '@/Globals'\nimport HTTPFileSystem from '@/js/HTTPFileSystem'\nimport Coords from '@/js/Coords'\nimport DashboardDataManager from '@/js/DashboardDataManager'\nimport CollapsiblePanel from '@/components/CollapsiblePanel.vue'\nimport DrawingTool from '@/components/DrawingTool/DrawingTool.vue'\nimport ZoomButtons from '@/components/ZoomButtons.vue'\nimport TimeSlider from '@/components/TimeSliderV2.vue'\n\nimport GridLayer from './GridLayer'\nimport { ColorScheme, FileSystemConfig, Status } from '@/Globals'\nimport avro from '@/js/avro'\n\n// interface for each time object inside the mapData Array\nexport interface MapData {\n  time: Number\n  colorData: Uint8Array\n  values: Float32Array\n  centroid: Float32Array\n  numberOfFilledColors?: Number\n  numberOfFilledValues?: Number\n  numberOfFilledCentroids?: Number\n  length: Number\n}\n\nexport interface CompleteMapData {\n  mapData: MapData[]\n  scaledFactor: Number\n  unit: String\n}\n\ninterface VizDetail {\n  colorRamp: any\n  title: string\n  description?: string\n  file: string\n  projection: any\n  thumbnail?: string\n  elements?: string\n  cellSize: number\n  maxHeight: number\n  userColorRamp: string\n  opacity: number\n  center: any\n  zoom: number\n  mapIsIndependent?: boolean\n  breakpoints?: string\n  valueColumn: string\n  unit: string\n}\n\ninterface GuiConfig {\n  buckets: number\n  exponent: number\n  radius: number\n  opacity: number\n  height: number\n  'color ramp': string\n  colorRamps: String[]\n  flip: Boolean\n  steps: number\n}\n\ninterface StandaloneYAMLconfig {\n  title: String\n  description: String\n  file: String\n  projection: String\n  thumbnail: String\n  cellSize: number\n  opacity: number\n  maxHeight: number\n  userColorRamp: string\n  center: number[]\n  zoom: number\n  mapIsIndependent: boolean\n}\n\ninterface MapProps {\n  viewId: string\n  colorRamp: String\n  coverage: number\n  dark: boolean\n  data: CompleteMapData\n  currentTimeIndex: number | undefined\n  mapIsIndependent: boolean | undefined\n  maxHeight: number\n  userColorRamp: string\n  cellSize: number\n  opacity: number\n  upperPercentile: number\n}\n\nconst i18n = {\n  messages: {\n    en: {\n      loading: 'Loading data...',\n      sorting: 'Sorting into bins...',\n      aggregate: 'Summary',\n      maxHeight: '3D Height',\n      showDetails: 'Show Details',\n      selection: 'Selection',\n      areas: 'Areas',\n      count: 'Count',\n    },\n    de: {\n      loading: 'Dateien laden...',\n      sorting: 'Sortieren...',\n      aggregate: 'Daten',\n      maxHeight: '3-D Höhe',\n      showDetails: 'Details anzeigen',\n      selection: 'Ausgewählt',\n      areas: 'Orte',\n      count: 'Anzahl',\n    },\n  },\n}\n\nconst GridMap = defineComponent({\n  name: 'GridMapPlugin',\n  i18n,\n  components: {\n    CollapsiblePanel,\n    DrawingTool,\n    GridLayer,\n    ToggleButton,\n    ZoomButtons,\n    TimeSlider,\n  },\n\n  props: {\n    root: { type: String, required: true },\n    subfolder: { type: String, required: true },\n    yamlConfig: String,\n    config: Object,\n    thumbnail: Boolean,\n    datamanager: { type: Object as PropType<DashboardDataManager> },\n  },\n\n  data() {\n    const colorRamps = ['Inferno', 'Magma', 'Viridis', 'Greens', 'Reds', 'RdYlGn', 'greenRed']\n    return {\n      id: `id-${Math.floor(1e12 * Math.random())}` as any,\n      standaloneYAMLconfig: {\n        title: '',\n        description: '',\n        file: '',\n        projection: '',\n        thumbnail: '',\n        cellSize: 250,\n        opacity: 0.7,\n        maxHeight: 0,\n        userColorRamp: 'Viridis',\n        center: null as any,\n        zoom: 9,\n        mapIsIndependent: false,\n      } as StandaloneYAMLconfig,\n      colorRamps,\n      columnLookup: [] as number[],\n      gzipWorker: null as Worker | null,\n      colorRamp: colorRamps[0] as String,\n      globalState: globalStore.state,\n      vizDetails: {\n        title: '',\n        description: '',\n        file: '',\n        projection: '',\n        thumbnail: '',\n        cellSize: 250,\n        opacity: 0.7,\n        maxHeight: 0,\n        userColorRamp: 'virdis',\n        center: null as any,\n        zoom: 9,\n        breakpoints: null as any,\n        valueColumn: 'value',\n        unit: '',\n      } as VizDetail,\n      myState: {\n        statusMessage: '',\n        subfolder: '',\n        yamlConfig: '',\n        thumbnail: false,\n      },\n      data: null as any,\n      selectedTimeData: [] as any[],\n      allTimePeriodes: [] as any[],\n      colors: colormap({\n        colormap: 'Viridis',\n        nshades: 10,\n        format: 'rba',\n        alpha: 1,\n      }).map((c: number[]) => [c[0], c[1], c[2], 255]) as Uint8Array[],\n      currentTime: [0, 0] as Number[],\n      timeToIndex: new Map<Number, number>(),\n      guiConfig: {\n        buckets: 10,\n        exponent: 4,\n        radius: 150,\n        opacity: 1,\n        height: 100,\n        'color ramp': 'Viridis',\n        colorRamps: colorRamps,\n        flip: false,\n        steps: 10,\n      } as GuiConfig,\n      configId: `gui-config-${Math.floor(1e12 * Math.random())}` as string,\n      guiController: null as GUI | null,\n      minRadius: 50 as number,\n      maxRadius: 300 as number,\n      radiusStep: 5 as number,\n      isLoaded: false as boolean,\n      thumbnailUrl: \"url('assets/thumbnail.jpg') no-repeat;\" as string,\n      resizer: null as ResizeObserver | null,\n      timeRange: [Infinity, -Infinity] as Number[],\n      allTimes: [] as number[],\n      // DataManager might be passed in from the dashboard; or we might be\n      // in single-view mode, in which case we need to create one for ourselves\n      myDataManager: this.datamanager || new DashboardDataManager(this.root, this.subfolder),\n    }\n  },\n  computed: {\n    fileApi(): HTTPFileSystem {\n      return new HTTPFileSystem(this.fileSystem, globalStore)\n    },\n    fileSystem(): FileSystemConfig {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === this.root\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n\n    urlThumbnail(): any {\n      return this.thumbnailUrl\n    },\n\n    mapProps(): MapProps {\n      return {\n        viewId: this.id,\n        colorRamp: this.colorRamp,\n        coverage: 0.65,\n        dark: this.$store.state.isDarkMode,\n        data: this.data,\n        currentTimeIndex: this.timeToIndex.get(this.currentTime[0]),\n        mapIsIndependent: this.vizDetails.mapIsIndependent,\n        maxHeight: this.guiConfig.height,\n        userColorRamp: this.guiConfig['color ramp'],\n        cellSize: this.guiConfig.radius,\n        opacity: this.guiConfig.opacity,\n        upperPercentile: 100,\n      }\n    },\n    textColor(): any {\n      const lightmode = {\n        text: '#3498db',\n        bg: '#eeeef480',\n      }\n\n      const darkmode = {\n        text: 'white',\n        bg: '#181518aa',\n      }\n\n      return this.$store.state.colorScheme === ColorScheme.DarkMode ? darkmode : lightmode\n    },\n  },\n  watch: {\n    '$store.state.viewState'() {\n      if (this.vizDetails.mapIsIndependent) return\n      if (REACT_VIEW_HANDLES[this.id]) REACT_VIEW_HANDLES[this.id]()\n    },\n  },\n  methods: {\n    /**\n     * Selects a color based on the given value.\n     * @param {number} value - The value influencing color selection (0-100).\n     * @returns {number[]} - An RGBA color array [R, G, B, A].\n     */\n    pickColor(value: number): number[] | Uint8Array {\n      // Error handling: If the value is outside the valid range, return a default color.\n      if (value < 0 || value > 100) {\n        console.warn('Invalid value for pickColor: Value should be between 0 and 100.')\n        return [0, 0, 0, 0] // Default color (transparent)\n      }\n\n      // Check if the colorRamp is fixed and if the length of the breakpoints array is equal to the length of the fixedColors array minus one.\n      if (\n        this.vizDetails.colorRamp.breakpoints &&\n        this.vizDetails.colorRamp.breakpoints.length ==\n          this.vizDetails.colorRamp.fixedColors.length - 1\n      ) {\n        // If the value is within the range of the colorRamp, return the corresponding color.\n        for (let i = 0; i < this.vizDetails.colorRamp.breakpoints.length - 1; i++) {\n          if (\n            value > this.vizDetails.colorRamp.breakpoints[i] &&\n            value <= this.vizDetails.colorRamp.breakpoints[i + 1]\n          ) {\n            return hexToRgb(this.vizDetails.colorRamp.fixedColors[i + 1])\n          }\n        }\n\n        // If the value is below the first breakpoint, return the first color.\n        if (value < this.vizDetails.colorRamp.breakpoints[0]) {\n          return hexToRgb(this.vizDetails.colorRamp.fixedColors[0])\n        }\n\n        // If the value is above the last breakpoint, return the last color.\n        if (\n          value >=\n          this.vizDetails.colorRamp.breakpoints[this.vizDetails.colorRamp.breakpoints.length - 1]\n        ) {\n          return hexToRgb(\n            this.vizDetails.colorRamp.fixedColors[this.vizDetails.colorRamp.fixedColors.length - 1]\n          )\n        }\n\n        return new Uint8Array([255, 255, 255, 255])\n      } else {\n        // Calculate the index based on the value and the number of colors in the array.\n        const index = Math.floor((value / 100) * (this.colors.length - 1))\n\n        // Return the selected color.\n        return this.colors[index]\n      }\n    },\n\n    async solveProjection() {\n      console.log('solveProjection')\n      if (this.thumbnail) return\n\n      console.log('WHAT PROJECTION:')\n\n      try {\n        const text = await this.fileApi.getFileText(\n          this.myState.subfolder + '/' + this.myState.yamlConfig\n        )\n        this.vizDetails = YAML.parse(text)\n      } catch (e) {\n        console.error(e)\n      }\n    },\n\n    async getVizDetails() {\n      if (this.config) {\n        this.validateYAML()\n        this.vizDetails = Object.assign({ colorRamp: '' }, this.config) as VizDetail\n        this.setRadiusAndHeight()\n        this.setCustomGuiConfig()\n        return\n      }\n\n      const hasYaml = new RegExp('.*(yml|yaml)$').test(this.myState.yamlConfig)\n\n      if (hasYaml) {\n        await this.loadStandaloneYAMLConfig()\n      } else {\n        this.loadOutputTripsConfig()\n      }\n    },\n\n    loadOutputTripsConfig() {\n      let projection = '' // 'EPSG:31468' // 'EPSG:25832', // 'EPSG:31468', // TODO: fix\n      if (!this.myState.thumbnail) {\n        projection = prompt('Enter projection: e.g. \"EPSG:31468\"') || 'EPSG:31468'\n        if (!!parseInt(projection, 10)) projection = 'EPSG:' + projection\n      }\n      this.vizDetails = {\n        title: 'Output Trips',\n        description: this.myState.yamlConfig,\n        file: this.myState.yamlConfig,\n        projection,\n        cellSize: this.vizDetails.cellSize,\n        colorRamp: this.vizDetails.colorRamp,\n        opacity: this.vizDetails.opacity,\n        maxHeight: this.vizDetails.maxHeight,\n        userColorRamp: this.vizDetails.userColorRamp,\n        center: this.vizDetails.center,\n        zoom: this.vizDetails.zoom,\n        valueColumn: this.vizDetails.valueColumn,\n        unit: this.vizDetails.unit,\n      }\n      this.$emit('title', this.vizDetails.title)\n      this.solveProjection()\n      return\n    },\n\n    // TODO: Set default values for color attributes\n    setRadiusAndHeight() {\n      if (!this.vizDetails.cellSize) {\n        Vue.set(this.vizDetails, 'cellSize', 250)\n      }\n\n      if (!this.vizDetails.maxHeight) {\n        Vue.set(this.vizDetails, 'maxHeight', 0)\n      }\n\n      if (!this.vizDetails.opacity) {\n        Vue.set(this.vizDetails, 'opacity', 0.7)\n      }\n    },\n\n    async loadStandaloneYAMLConfig() {\n      try {\n        // Determine the full filename, handling cases where yamlConfig might include '/'\n        const filename = this.myState.yamlConfig.includes('/')\n          ? this.myState.yamlConfig\n          : `${this.myState.subfolder}/${this.myState.yamlConfig}`\n\n        // Load the YAML file and store it in standaloneYAMLconfig\n        const text = await this.fileApi.getFileText(filename)\n        this.standaloneYAMLconfig = YAML.parse(text)\n\n        // YAML file validation\n        this.validateYAML()\n\n        // Set visualization details\n        this.setVizDetails()\n      } catch (err) {\n        // Show error message in the Warning/Error Panel\n        const errorMessage = `File not found: ${this.myState.subfolder}/${this.myState.yamlConfig}`\n        this.$emit('error', errorMessage)\n      }\n    },\n\n    validateYAML() {\n      const hasYaml = new RegExp('.*(yml|yaml)$').test(this.myState.yamlConfig)\n      let configuration = {} as any\n\n      if (hasYaml) {\n        console.log('has yaml')\n        configuration = this.standaloneYAMLconfig\n      } else {\n        console.log('no yaml')\n        configuration = this.config\n      }\n\n      if (configuration.cellSize == 0) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `Radius is out of the recommended range`,\n          desc: 'Radius can not be zero, preset value used instead. ',\n        })\n      }\n\n      if (configuration.opacity <= 0 || configuration.opacity > 1) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `Opacity set to zero`,\n          desc: 'Opacity levels should be between 0 and 1. ',\n        })\n      }\n\n      if (configuration.zoom < 5 || configuration.zoom > 20) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `Zoom is out of the recommended range `,\n          desc: 'Zoom levels should be between 5 and 20. ',\n        })\n      }\n\n      if (configuration.maxHeight < 0) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `maxHeight is out of the recommended range `,\n          desc: 'maxHeight should be greater than 0',\n        })\n      }\n\n      // TODO: Add warnings for color attributes\n    },\n\n    setVizDetails() {\n      this.vizDetails = Object.assign({}, this.vizDetails, this.standaloneYAMLconfig)\n\n      this.setRadiusAndHeight()\n\n      const t = this.vizDetails.title ? this.vizDetails.title : 'Grid Map'\n      this.$emit('title', t)\n    },\n\n    async buildThumbnail() {\n      if (this.thumbnail && this.vizDetails.thumbnail) {\n        try {\n          const blob = await this.fileApi.getFileBlob(\n            this.myState.subfolder + '/' + this.vizDetails.thumbnail\n          )\n          const buffer = await blob.arrayBuffer()\n          const base64 = util.arrayBufferToBase64(buffer)\n          if (base64)\n            this.thumbnailUrl = `center / cover no-repeat url(data:image/png;base64,${base64})`\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n\n    setMapCenter() {\n      // If user gave us the center, use it\n      if (this.vizDetails.center) {\n        if (typeof this.vizDetails.center == 'string') {\n          this.vizDetails.center = this.vizDetails.center.split(',').map(Number)\n        }\n\n        const view = {\n          longitude: this.vizDetails.center[0],\n          latitude: this.vizDetails.center[1],\n          bearing: 10,\n          pitch: 0,\n          zoom: this.vizDetails.zoom || 10, // use 10 default if we don't have a zoom\n          jump: true, // move the map no matter what\n          center: [this.vizDetails.center[0], this.vizDetails.center[1]],\n        }\n\n        // bounce our map\n        if (REACT_VIEW_HANDLES[this.id]) REACT_VIEW_HANDLES[this.id](view)\n\n        // Sets the map to the specified data\n        this.$store.commit('setMapCamera', view)\n\n        return\n      }\n    },\n\n    async loadAndPrepareData() {\n      if (this.vizDetails.file.indexOf('.avro') > -1) {\n        return await this.loadAndPrepareAvroData()\n      } else {\n        return await this.loadAndPrepareCSVData()\n      }\n    },\n\n    async loadAndPrepareAvroData() {\n      const filename = `${this.subfolder}/${this.vizDetails.file}`\n      const blob = await this.fileApi.getFileBlob(filename)\n\n      const records: any[] = await new Promise((resolve, reject) => {\n        const rows = [] as any[]\n        avro\n          .createBlobDecoder(blob)\n          .on('metadata', (schema: any) => {\n            // console.log(schema)\n          })\n          .on('data', (row: any) => {\n            rows.push(row)\n          })\n          .on('end', () => {\n            resolve(rows)\n          })\n      })\n\n      // console.log({ records })\n\n      // Store the min and max value to calculate the scale factor\n      let minValue = Number.POSITIVE_INFINITY\n      let maxValue = Number.NEGATIVE_INFINITY\n\n      const record = records[0]\n\n      this.allTimes = record.timestamps\n      this.allTimes = this.allTimes.sort((n1, n2) => n1 - n2)\n      this.timeRange[0] = this.allTimes[0]\n      this.timeRange[1] = this.allTimes[this.allTimes.length - 1]\n\n      const tableName = Object.keys(record.data)[0]\n      const dataValues: number[] = record.data[tableName]\n\n      // console.log({ allTimes: this.allTimes, timeRange: this.timeRange, tableName, dataValues })\n\n      // calc scale\n      for (const value of dataValues) maxValue = Math.max(maxValue, value)\n      const scaleFactor = 100 / maxValue\n\n      // console.log({ scaleFactor })\n\n      if (this.vizDetails.unit == undefined) {\n        this.vizDetails.unit = ''\n      }\n\n      const finalData = {\n        mapData: [] as MapData[],\n        scaledFactor: scaleFactor as Number,\n        unit: this.vizDetails.unit,\n      } as CompleteMapData\n\n      const x = record.xCoords\n      const y = record.yCoords\n      const numPoints = x.length * y.length\n\n      // Load CRS/projection from Avro file if exists\n      if (record.crs) this.vizDetails.projection = record.crs\n\n      // User must provide projection\n      if (!this.vizDetails.projection) {\n        const msg = 'No coordinate projection. Add \"projection: EPSG:xxxx\" to config'\n        this.$emit('error', msg)\n        // throw Error(msg)\n      }\n\n      // Build x/y-coordinates (just once - always the same)\n      const centroid = new Float32Array(numPoints * 2)\n      let offset = 0\n      for (let ix = 0; ix < x.length; ix++) {\n        for (let iy = 0; iy < y.length; iy++) {\n          let wgs84 = [x[ix], y[iy]]\n          wgs84 = Coords.toLngLat(this.vizDetails.projection, wgs84)\n          centroid[offset] = wgs84[0]\n          centroid[offset + 1] = wgs84[1]\n          offset += 2\n        }\n      }\n      // map all times to their index and create a mapData object for each time\n      this.allTimes.forEach((time, index) => {\n        this.timeToIndex.set(time, index)\n\n        finalData.mapData.push({\n          length: numPoints,\n          time: time,\n          centroid,\n          values: new Float32Array(numPoints),\n          colorData: new Uint8Array(numPoints * 3),\n        })\n      })\n\n      // Loop through the data and create the data object for the map\n      for (let timeIndex = 0; timeIndex < this.allTimes.length; timeIndex++) {\n        console.log('time', timeIndex)\n        for (let i = 0; i < numPoints; i++) {\n          const offset = timeIndex * numPoints + i\n          const value = scaleFactor * dataValues[offset]\n          const colors = this.pickColor(value)\n\n          // add final values to the mapData\n          finalData.mapData[timeIndex].values[i] = value\n          for (let j = 0; j < 3; j++) {\n            finalData.mapData[timeIndex].colorData[i * 3 + j] = colors[j]\n          }\n        }\n      }\n\n      this.myState.statusMessage = ''\n      return finalData\n    },\n\n    async loadAndPrepareCSVData() {\n      const config = { dataset: this.vizDetails.file }\n      let csv = {} as any\n      try {\n        csv = await this.myDataManager.getDataset(config)\n      } catch (e) {\n        this.$emit('error', '' + e) // `Error loading ${this.vizDetails.file}: File missing? CSV Too large?`)\n      }\n\n      // The datamanager doesn't return the comments...\n      if (csv.comments && csv.comments.length) {\n        csv.comments.forEach((comment: string) => {\n          if (comment.indexOf('EPSG') > -1) {\n            const projection = comment.substring(comment.lastIndexOf('EPSG')).trim()\n            if (projection) this.vizDetails.projection = projection\n          }\n        })\n      }\n\n      // Store the min and max value to calculate the scale factor\n      let minValue = Number.POSITIVE_INFINITY\n      let maxValue = Number.NEGATIVE_INFINITY\n\n      // console.log('csv: ', csv.allRows)\n      // console.log('valueColumn: ', this.vizDetails.valueColumn)\n      // console.log('csv:', { csv })\n\n      if (this.vizDetails.valueColumn == undefined) {\n        this.vizDetails.valueColumn = 'value'\n      }\n\n      if (this.vizDetails.unit == undefined) {\n        this.vizDetails.unit = ''\n      }\n\n      // This for loop collects all the data that's used by\n      for (let i = 0; i < csv.allRows[this.vizDetails.valueColumn].values.length; i++) {\n        // Stores all times to calculate the range and the timeBinSize\n        if (!this.allTimes.includes(csv.allRows.time.values[i]))\n          this.allTimes.push(csv.allRows.time.values[i])\n\n        // calculate the min and max value\n        if (csv.allRows[this.vizDetails.valueColumn].values[i] < minValue)\n          minValue = csv.allRows[this.vizDetails.valueColumn].values[i]\n        if (csv.allRows[this.vizDetails.valueColumn].values[i] > maxValue)\n          maxValue = csv.allRows[this.vizDetails.valueColumn].values[i]\n\n        // Store all different times\n        if (!this.allTimes.includes(csv.allRows.time.values[i]))\n          this.allTimes.push(csv.allRows.time.values[i])\n      }\n\n      this.allTimes = this.allTimes.sort((n1, n2) => n1 - n2)\n\n      this.timeRange[0] = Math.min.apply(Math, this.allTimes)\n      this.timeRange[1] = Math.max.apply(Math, this.allTimes)\n\n      // Count elements per time\n      const numberOfElementsPerTime = Math.ceil(\n        csv.allRows[this.vizDetails.valueColumn].values.length / this.allTimes.length\n      )\n\n      // scaleFactor\n      const scaleFactor = 100 / maxValue\n\n      const finalData = {\n        mapData: [] as MapData[],\n        scaledFactor: scaleFactor as Number,\n        unit: this.vizDetails.unit,\n      } as CompleteMapData\n\n      // map all times to their index and create a mapData object for each time\n      this.allTimes.forEach((time, index) => {\n        this.timeToIndex.set(time, index)\n\n        finalData.mapData.push({\n          time: time,\n          values: new Float32Array(numberOfElementsPerTime),\n          centroid: new Float32Array(numberOfElementsPerTime * 2),\n          colorData: new Uint8Array(numberOfElementsPerTime * 3),\n          numberOfFilledValues: 0,\n          numberOfFilledCentroids: 0,\n          numberOfFilledColors: 0,\n          length: numberOfElementsPerTime,\n        })\n      })\n\n      // User must provide projection\n      if (!this.vizDetails.projection) {\n        const msg = 'No coordinate projection. Add \"projection: EPSG:xxxx\" to config'\n        this.$emit('error', msg)\n        throw Error(msg)\n      }\n\n      // Loop through the data and create the data object for the map\n      for (let i = 0; i < csv.allRows[this.vizDetails.valueColumn].values.length; i++) {\n        // index for the time\n        const index = this.timeToIndex.get(csv.allRows.time.values[i]) as number\n\n        const value = scaleFactor * csv.allRows[this.vizDetails.valueColumn].values[i]\n        const colors = this.pickColor(value)\n\n        // Save index for next position in the array\n        const lastValueIndex = finalData.mapData[index].numberOfFilledValues as number\n        const lastColorIndex = finalData.mapData[index].numberOfFilledColors as number\n        const lastCentroidIndex = finalData.mapData[index].numberOfFilledCentroids as number\n\n        // Save the value\n        finalData.mapData[index].values[lastValueIndex] = value\n\n        // Loop through the colors and add them to the mapData\n        for (let j = 0; j < 3; j++) {\n          finalData.mapData[index].colorData[lastColorIndex + j] = colors[j]\n        }\n\n        // Convert coordinates\n        let wgs84 = [csv.allRows.x.values[i], csv.allRows.y.values[i]]\n\n        if (this.vizDetails.projection !== 'EPSG:4326') {\n          wgs84 = Coords.toLngLat(this.vizDetails.projection, [\n            csv.allRows.x.values[i],\n            csv.allRows.y.values[i],\n          ])\n        }\n\n        // Add centroids to the mapData\n        finalData.mapData[index].centroid[lastCentroidIndex] = wgs84[0]\n        finalData.mapData[index].centroid[lastCentroidIndex + 1] = wgs84[1]\n\n        // Update the number of values for time array in the mapData\n        finalData.mapData[index].numberOfFilledValues = lastValueIndex + 1\n        finalData.mapData[index].numberOfFilledCentroids = lastCentroidIndex + 2\n        finalData.mapData[index].numberOfFilledColors = lastColorIndex + 3\n      }\n\n      // Clean data (delete numberOfFilledXXXX)\n      Array.from(this.allTimes.keys()).forEach((index: number) => {\n        delete finalData.mapData[index].numberOfFilledValues\n        delete finalData.mapData[index].numberOfFilledCentroids\n        delete finalData.mapData[index].numberOfFilledColors\n      })\n\n      this.myState.statusMessage = ''\n      return finalData\n    },\n\n    resolveProjection() {\n      if (this.vizDetails.projection === 'EPSG:4326') return\n\n      for (let i = 0; i < this.data.length; i++) {\n        const wgs84 = Coords.toLngLat(this.vizDetails.projection, this.data[i].centroid)\n        this.data[i].centroid = wgs84\n      }\n    },\n\n    handleTimeSliderValues(timeValues: any[]) {\n      this.currentTime = timeValues\n      this.selectedTimeData = []\n\n      for (let i = 0; i < this.data.length; i++) {\n        if (this.data[i].time == timeValues[0]) {\n          this.selectedTimeData.push(this.data[i])\n        }\n      }\n    },\n\n    setupGui() {\n      this.guiController = new GUI({\n        title: 'Settings',\n        injectStyles: true,\n        width: 200,\n        container: document.getElementById(this.configId) || undefined,\n      })\n\n      const config = this.guiController // .addFolder('Colors')\n      config.add(this.guiConfig, 'radius', this.minRadius, this.maxRadius, this.radiusStep)\n      config.add(this.guiConfig, 'opacity', 0, 1, 0.1)\n      config.add(this.guiConfig, 'height', 0, 250, 5)\n\n      // Remove color ramp selector if the colorRamp is fixed\n      if (this.vizDetails.colorRamp) {\n        // let's make sure details user provided make sense\n        if (\n          this.vizDetails.colorRamp.breakpoints &&\n          this.vizDetails.colorRamp.fixedColors &&\n          this.vizDetails.colorRamp.breakpoints.length !==\n            this.vizDetails.colorRamp.fixedColors.length - 1\n        ) {\n          this.$emit('error', 'Color ramp breakpoints and fixedColors do not have correct lengths')\n        }\n        return\n      }\n\n      const colors = config.addFolder('colors')\n      colors.add(this.guiConfig, 'color ramp', this.guiConfig.colorRamps).onChange(this.setColors)\n      colors.add(this.guiConfig, 'flip').onChange(this.setColors)\n      this.setColors()\n    },\n\n    setColors() {\n      if (!this.data) return\n\n      const ramp = {\n        ramp: this.guiConfig['color ramp'],\n        // style: Style.sequential,\n      } as Ramp\n\n      console.log('Ramp: ', this.guiConfig['color ramp'])\n      console.log('n: ', this.guiConfig.steps)\n      const color = getColorRampHexCodes(ramp, this.guiConfig.steps)\n\n      if (color.length == 0) {\n        const errorMessage = `Invalid color ramp: ${this.guiConfig['color ramp']}`\n        this.$emit('error', errorMessage)\n      }\n\n      if (color.length) {\n        this.colors = []\n      }\n\n      this.colors = this.hexArrayToRgbArray(color)\n\n      // colors.push(colorRamp({ ramp: this.guiConfig['color ramp'] } as Ramp, this.guiConfig.steps))\n\n      // let colors = [\n      //   ...colorRamp({ ramp: this.guiConfig['color ramp'],  } as Ramp, this.guiConfig.steps || 10),\n      // ]\n\n      // this.colors = this.hexArrayToRgbArray(\n      //   colorRamp({ ramp: this.guiConfig['color ramp'] } as Ramp, this.guiConfig.steps)\n      // )\n\n      if (this.guiConfig.flip) this.colors = this.colors.reverse()\n\n      // Recalculating the color values for the colorRamp\n      for (let i = 0; i < this.data.mapData.length; i++) {\n        for (let j = 0; j < this.data.mapData[i].values.length; j++) {\n          const value = this.data.mapData[i].values[j]\n          const colors = this.pickColor(value)\n          if (colors == undefined) break\n          for (let colorIndex = j * 3; colorIndex <= j * 3 + 2; colorIndex++) {\n            this.data.mapData[i].colorData[colorIndex] = colors[colorIndex % 3]\n          }\n        }\n      }\n\n      // force Vue to take notice of the change - any prop change will do\n      this.currentTime = [...this.currentTime]\n    },\n\n    hexArrayToRgbArray(hexArray: string[]): any {\n      const rgbArray = []\n\n      for (let i = 0; i < hexArray.length; i++) {\n        const hex = hexArray[i].replace(/^#/, '')\n        const r = parseInt(hex.substring(0, 2), 16)\n        const g = parseInt(hex.substring(2, 4), 16)\n        const b = parseInt(hex.substring(4, 6), 16)\n        rgbArray.push([r, g, b, 255])\n      }\n\n      return rgbArray\n    },\n\n    setCustomGuiConfig() {\n      if (!this.config) return\n\n      if (this.config.colorRamp) {\n        if (this.config.colorRamp.ramp != undefined)\n          this.guiConfig['color ramp'] = this.config.colorRamp.ramp\n\n        if (this.config.colorRamp.reverse != undefined)\n          this.guiConfig.flip = this.config.colorRamp.reverse\n\n        if (this.config.colorRamp.steps != undefined)\n          this.guiConfig.steps = this.config.colorRamp.steps\n      }\n\n      // Set custom radius\n      if (this.config.cellSize >= this.minRadius && this.config.cellSize <= this.maxRadius) {\n        this.guiConfig.radius = this.config.cellSize\n      }\n\n      // Set custom maxHeight\n      if (this.config.maxHeight) this.guiConfig.height = this.config.maxHeight\n\n      // Set custom opacity\n      if (this.config.opacity) this.guiConfig.opacity = this.config.opacity\n    },\n  },\n\n  async mounted() {\n    this.$store.commit('setFullScreen', !this.thumbnail)\n\n    this.myState.thumbnail = this.thumbnail\n    this.myState.yamlConfig = this.yamlConfig || ''\n    this.myState.subfolder = this.subfolder\n\n    await this.getVizDetails()\n\n    if (this.thumbnail) return\n\n    this.setupGui()\n\n    this.myState.statusMessage = `${this.$i18n.t('loading')}`\n\n    this.data = await this.loadAndPrepareData()\n    // this.$emit('error', 'Error loading ' + this.vizDetails.file)\n\n    this.setColors()\n    // this.buildThumbnail()\n    this.isLoaded = true\n    this.setMapCenter()\n  },\n\n  beforeDestroy() {\n    // MUST erase the React view handle to prevent gigantic memory leak!\n    REACT_VIEW_HANDLES[this.id] = undefined\n    delete REACT_VIEW_HANDLES[this.id]\n\n    this.data = null\n\n    this.$store.commit('setFullScreen', false)\n  },\n})\n\nexport default GridMap\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.xy-hexagons {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  min-height: $thumbnailHeight;\n  background: url('assets/thumbnail.jpg') center / cover no-repeat;\n  z-index: -1;\n}\n\n.xy-hexagons.hide-thumbnail {\n  background: none;\n  z-index: 0;\n}\n\n.message {\n  z-index: 5;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  box-shadow: 0px 2px 10px #22222222;\n  display: flex;\n  flex-direction: row;\n  margin: auto auto 0 0;\n  background-color: var(--bgPanel);\n  padding: 0.5rem 1.5rem;\n\n  a {\n    color: white;\n    text-decoration: none;\n\n    &.router-link-exact-active {\n      color: white;\n    }\n  }\n\n  p {\n    font-size: 1.2rem;\n    line-height: 1.5rem;\n    font-weight: normal;\n    color: var(--textFancy);\n  }\n}\n\n.ui-slider {\n  padding: 0 0;\n  margin: 0.2rem 0 0.6rem 0;\n  min-width: 7rem;\n}\n\n.status-message {\n  font-size: 1.5rem;\n  line-height: 1.75rem;\n  font-weight: bold;\n}\n\n.big {\n  padding: 0.5rem 0;\n  font-size: 1.5rem;\n  line-height: 1.7rem;\n  font-weight: bold;\n}\n\n.top-right {\n  background-color: var(--bgPanel2);\n  color: white;\n  position: absolute;\n  top: 0;\n  right: 0;\n  z-index: 5;\n  border-left: 1px solid #66669940;\n  border-bottom: 1px solid #66669940;\n  box-shadow: 0px 0px 5px 3px rgba(128, 128, 128, 0.1);\n}\n\n.left-side {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column;\n  font-size: 0.8rem;\n  pointer-events: auto;\n  margin: 0 0 0 0;\n}\n\n.control-panel {\n  position: absolute;\n  bottom: 0;\n  display: flex;\n  flex-direction: row;\n  font-size: 0.8rem;\n  margin: 0 0 0.5rem 0.5rem;\n  pointer-events: auto;\n  background-color: var(--bgPanel);\n  padding: 0.5rem 0.5rem;\n  filter: drop-shadow(0px 2px 4px #22222233);\n}\n\n.is-dashboard {\n  position: static;\n  margin: 0 0;\n  padding: 0.25rem 0 0 0;\n  filter: unset;\n  background-color: unset;\n}\n\n.hex-layer {\n  pointer-events: auto;\n}\n\n.ui-label {\n  font-size: 0.8rem;\n  font-weight: bold;\n}\n\n.tooltip {\n  padding: 5rem 5rem;\n  background-color: #ccc;\n}\n\n.panel-items {\n  margin: 0.5rem 0.5rem;\n}\n\n.panel-item {\n  display: flex;\n  flex-direction: column;\n  margin-right: 1rem;\n  margin-left: 0.25rem;\n}\n\n.right {\n  margin-left: auto;\n}\n\ninput {\n  border: none;\n  background-color: #235;\n  color: #ccc;\n}\n\n.row {\n  display: 'grid';\n  grid-template-columns: 'auto 1fr';\n}\n\n.drawing-tool {\n  position: absolute;\n  top: 0;\n  right: 0;\n  pointer-events: none;\n}\n\n.time-slider-area {\n  position: absolute;\n  bottom: 0.5rem;\n  left: 0;\n  right: 0;\n  margin: 0 9rem 0 1rem;\n  filter: $filterShadow;\n}\n\n@media only screen and (max-width: 640px) {\n  .message {\n    padding: 0.5rem 0.5rem;\n  }\n\n  .right-side {\n    font-size: 0.7rem;\n  }\n\n  .big {\n    padding: 0 0rem;\n    margin-top: 0.5rem;\n    font-size: 1.3rem;\n    line-height: 2rem;\n  }\n}\n</style>\n"],"names":["CUBE_INDICES","CUBE_POSITIONS","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","CubeGeometry","Geometry","props","id","uid","defaultProps","GridCellLayer","ColumnLayer","diskResolution","uniforms","elevationScale","extruded","offset","coverage","cellSize","angle","radiusUnits","UNIT","_defineProperty","GRAB_HANDLE_WIDTH","_sfc_main","defineComponent","usableWidth","marginLeft","marginRight","parameter","left","right","result","mid","animationClockTime","sliderElement","index","h","m","s","hms","_a","durationWidth","deltaX","currentExtent","newLeft","newRight","newStartTime","newEndTime","Layer","viewId","colorRamp","dark","data","currentTimeIndex","mapIsIndependent","maxHeight","opacity","upperPercentile","viewState","setViewState","useState","globalStore","REACT_VIEW_HANDLES","view","handleViewState","getTooltip","object","currentData","lng","lat","value","roundedValue","unit","latDisplay","lngDisplay","colors","colormap","c","layers","React","DeckGL","e","StaticMap","MAPBOX_TOKEN","i18n","GridMap","CollapsiblePanel","DrawingTool","GridLayer","ToggleButton","ZoomButtons","TimeSlider","colorRamps","DashboardDataManager","HTTPFileSystem","svnProject","a","lightmode","darkmode","ColorScheme","i","hexToRgb","text","YAML","projection","Vue","filename","errorMessage","hasYaml","configuration","Status","t","buffer","base64","util","blob","records","resolve","reject","rows","avro","schema","row","maxValue","record","n1","n2","tableName","dataValues","scaleFactor","finalData","x","y","numPoints","msg","centroid","ix","iy","wgs84","Coords","time","timeIndex","j","config","csv","comment","minValue","numberOfElementsPerTime","lastValueIndex","lastColorIndex","lastCentroidIndex","timeValues","GUI","ramp","color","getColorRampHexCodes","colorIndex","hexArray","rgbArray","hex","r","g","b"],"mappings":"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","x_google_ignoreList":[0,1]}