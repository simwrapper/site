{"version":3,"file":"DashboardDataManager-9bea9fc4.js","sources":["../../src/js/avro.js","../../src/js/DashboardDataManager.ts"],"sourcesContent":["//@ts-ignore\nexport default avro\n","/**\n * DashboardDataManager: this class loads, caches, and filters CSV and XML datasets\n * for use by dashboard charts and maps. Loosely based on the VizWit system\n * (see http://vizwit.io/) but we don't have a Carto database so all of the data\n * is stored internally in this class.\n *\n * Each tabbed dashboard should instantiate this class once, and destroy it when the dashboard\n * is closed. Datasets can be big, we don't want them to stick around forever!\n *\n * Data queries always return -both- the full dataset AND a filtered dataset.\n * That way, the filtered data can be visually layered on top of the full data.\n */\n\nimport { rollup } from 'd3-array'\n\nimport globalStore from '@/store'\nimport HTTPFileSystem from './HTTPFileSystem'\nimport { DataTable, DataTableColumn, DataType, FileSystemConfig, Status } from '@/Globals'\nimport { findMatchingGlobInFiles } from '@/js/util'\nimport avro from '@/js/avro'\n\nimport DataFetcherWorker from '@/workers/DataFetcher.worker.ts?worker'\nimport RoadNetworkLoader from '@/workers/RoadNetworkLoader.worker.ts?worker'\nimport Coords from './Coords'\n\ninterface configuration {\n  dataset: string\n  groupBy?: string\n  value?: string\n  usedCol?: string[]\n  columns?: string[]\n  ignoreColumns?: any[]\n  skipFirstRow?: boolean\n  useLastRow?: boolean\n  x?: string\n}\n\nexport interface FilterDefinition {\n  dataset: string\n  column: string\n  value: any\n  operator?: string\n  invert?: boolean\n  range?: boolean\n}\n\nexport interface NetworkLinks {\n  source: Float32Array\n  dest: Float32Array\n  linkIds: any[]\n  projection: String\n}\n\n// This tells us if our environment has the Chrome File System Access API, meaning we are in Chrome\n//@ts-ignore\nconst isChrome = !!window.showDirectoryPicker\nconst isFirefox = !isChrome\n\nexport default class DashboardDataManager {\n  constructor(...args: string[]) {\n    // hello\n    this.root = args.length ? args[0] : ''\n    this.subfolder = args.length ? args[1] : ''\n    this.fileApi = this._getFileSystem(this.root)\n  }\n\n  private files: any[] = []\n  private threads: Worker[] = []\n  private subfolder = ''\n  private root = ''\n  private fileApi: FileSystemConfig\n  private networks: { [id: string]: Promise<NetworkLinks> } = {}\n  private featureCollections: { [id: string]: any } = {}\n\n  public kill() {\n    for (const worker of this.threads) worker.terminate()\n  }\n\n  public getFilteredDataset(config: { dataset: string }): { filteredRows: any[] | null } {\n    if (!(config.dataset in this.datasets)) return { filteredRows: null }\n\n    const filteredRows = this.datasets[config.dataset].filteredRows\n    return { filteredRows }\n  }\n\n  public async OLDgetFiltered(config: { dataset: string; groupBy?: string; value?: string }) {\n    const rows = this.datasets[config.dataset].filteredRows\n    if (!rows) return { filteredRows: null }\n\n    // group the rows as needed\n    let bars: any = {}\n\n    if (config.value && config.groupBy) {\n      const columnValues = config.value\n      const columnGroups = config.groupBy\n      bars = rollup(\n        rows,\n        v => v.reduce((a, b) => a + b[columnValues], 0),\n        (d: any) => d[columnGroups] // group-by\n      )\n    } else {\n      // TODO need to handle non-value, non-group here\n    }\n    const x = Array.from(bars.keys())\n    const y = Array.from(bars.values())\n\n    // filter the rows, too\n\n    return { filteredRows: { x, y } }\n  }\n\n  /**\n   *\n   * @param config the configuration params from the YAML file. Must include dataset,\n   *               and may include other optional parameters as needed by the viz\n   * @returns allRows object, containing a DataTableColumn for each column in this dataset\n   */\n  public async getDataset(config: configuration, options?: { highPrecision: boolean }) {\n    try {\n      // first, get the dataset\n      if (!this.datasets[config.dataset]) {\n        console.log('load:', config.dataset)\n\n        // fetchDataset() immediately returns a Promise<>, which we await on\n        // so that multiple charts don't all try to fetch the dataset individually\n        this.datasets[config.dataset] = {\n          dataset: this._fetchDataset(config, options),\n          activeFilters: {},\n          filteredRows: null,\n          filterListeners: new Set(),\n        }\n      }\n\n      // Firefox just silently dies if the text is too large. Set a timeout...\n      const withTimeout = (promise: Promise<any>, timeout: number) => {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(new Error(`Operation timed out after ${timeout}ms`))\n          }, timeout)\n        })\n        return Promise.race([promise, timeoutPromise])\n      }\n\n      // wait for dataset to load\n      // this will immediately return dataset if it is already loaded\n      let myDataset = await withTimeout(this.datasets[config.dataset].dataset, 60 * 1000)\n\n      let { _comments, ...allRows } = myDataset\n      let comments = _comments as unknown as string[]\n\n      // make a copy because each viz in a dashboard might be hacking it differently\n      // TODO: be more \"functional\" and return the object itself, and let views create copies if they need to\n      // let allRows = { ...myDataset }\n\n      // remove ignored columns\n      if (config.ignoreColumns) {\n        config.ignoreColumns.forEach(column => {\n          delete allRows[column]\n        })\n      }\n\n      // if useLastRow, drop all rows except the last row\n      if (config.useLastRow) {\n        Object.keys(allRows).forEach(colName => {\n          const values = myDataset[colName].values\n          allRows[colName] = values[values.length - 1]\n        })\n      }\n\n      return { allRows, comments }\n    } catch (e) {\n      console.error('' + e)\n      throw Error(`loading ${config.dataset}. Missing? CSV too large?`)\n      return { allRows: {}, comments: [] }\n    }\n  }\n\n  /**\n   * Convert row-wise columns into a DataTable. This is intended for\n   * columnar data formats such as avro networks\n   * @param fullpath full file path\n   * @param dataColumns map of column: data\n   * @param config data config object\n   */\n  public setRowWisePropertyTable(fullpath: string, dataTable: DataTable, config: any) {\n    const key = fullpath.substring(fullpath.lastIndexOf('/') + 1)\n\n    // merge key with keep/drop params (etc)\n    let fullConfig = { dataset: key }\n    if ('string' !== typeof config) fullConfig = Object.assign(fullConfig, config)\n\n    this.datasets[key] = {\n      activeFilters: {},\n      filteredRows: null,\n      filterListeners: new Set(),\n      dataset: new Promise<DataTable>(resolve => {\n        resolve(dataTable)\n      }),\n    }\n    // this is a promise:\n    return this.datasets[key].dataset\n  }\n\n  public getFeatureCollection(id: string): any[] {\n    return this.featureCollections[id]\n  }\n\n  public async registerFeatures(fullpath: string, features: any[], config: any) {\n    this.featureCollections[fullpath] = features\n\n    // set up feature-properties as dataset\n    const featureProperties = features.map((f: any) => f.properties || {})\n    await this.setFeatureProperties(fullpath, featureProperties, config)\n\n    // clear out memory, properties have been moved to column-data\n    features.forEach(feature => {\n      feature.properties = {}\n    })\n  }\n\n  /**\n   * Convert features array from GeoJSONs and Shapefiles into DataTable\n   * @param fullpath name of shape/geo file\n   * @param featureProperties array of feature PROPERTIES -- feature objects MAPPED to just be the props\n   */\n  public setFeatureProperties(fullpath: string, featureProperties: any[], config: any) {\n    const key = fullpath.substring(fullpath.lastIndexOf('/') + 1)\n\n    // merge key with keep/drop params (etc)\n    let fullConfig = { dataset: key }\n    if ('string' !== typeof config) fullConfig = Object.assign(fullConfig, config)\n\n    this.datasets[key] = {\n      activeFilters: {},\n      filteredRows: null,\n      filterListeners: new Set(),\n      dataset: new Promise<DataTable>((resolve, reject) => {\n        const thread = new DataFetcherWorker()\n        // console.log('NEW WORKER', thread)\n        this.threads.push(thread)\n\n        try {\n          thread.postMessage({ config: fullConfig, featureProperties })\n\n          thread.onmessage = e => {\n            thread.terminate()\n            if (e.data.error) {\n              console.error(e.data.error)\n              reject(`Problem loading properties in ${fullpath}`)\n            }\n            resolve(e.data)\n          }\n        } catch (err) {\n          thread.terminate()\n          console.error(err)\n          reject(err)\n        }\n      }),\n    }\n    // this is a promise:\n    return this.datasets[key].dataset\n  }\n\n  /**\n   *  Register an existing in-memory DataTable as a dataset in this Dashboard\n   * @param props key, dataTable, and filename associated with this DataTable\n   */\n  public setPreloadedDataset(props: { key: string; dataTable: DataTable }) {\n    // let filters = {}\n    // if (this.datasets[props.key]) {\n    //   filters = this.datasets[props.key].activeFilters\n    // }\n\n    this.datasets[props.key] = {\n      dataset: new Promise<DataTable>((resolve, reject) => {\n        resolve(props.dataTable)\n      }),\n      activeFilters: {}, // filters,\n      filteredRows: null,\n      filterListeners: new Set(),\n    }\n  }\n\n  public async getRoadNetwork(\n    filename: string,\n    subfolder: string,\n    vizDetails: any,\n    cbStatus?: any\n  ) {\n    const path = `/${subfolder}/${filename}`\n    const options = {} as any\n    if (vizDetails.projection) options.crs = vizDetails.projection\n\n    // Get the dataset the first time it is requested\n    if (!this.networks[path]) {\n      this.networks[path] = this._fetchNetwork({\n        subfolder,\n        filename,\n        vizDetails,\n        cbStatus,\n        options,\n      })\n    }\n\n    // wait for the worker to provide the network\n    let network = await this.networks[path]\n    return network\n  }\n\n  // /**\n  //  * Load simple dataset without grouping/filtering\n  //  * @param allRows Each row\n  //  * @returns TBD\n  //  */\n  // public loadSimple(config: configuration, allRows: any[]) {\n  //   // Simple requires x and columns/usedCol\n  //   if (!config.x || (!config.columns && !config.usedCol)) {\n  //     throw Error('Config requires \"x\" and \"columns\" parameters')\n  //   }\n\n  //   var useOwnNames = false\n\n  //   const x = [] as any[]\n\n  //   for (var i = 0; i < allRows.length; i++) {\n  //     if (i == 0 && config.skipFirstRow) {\n  //     } else {\n  //       x.push(allRows[i][config.x])\n  //     }\n  //   }\n\n  //   const columns = config.columns || config.usedCol || []\n\n  //   for (let i = 0; i < columns.length; i++) {\n  //     const name = columns[i]\n  //     let legendName = ''\n  //     if (columns[i] !== 'undefined') {\n  //       if (useOwnNames) {\n  //         legendName = this.config.legendTitles[i]\n  //       } else {\n  //         legendName = name\n  //       }\n  //       const value = []\n  //       for (var j = 0; j < this.dataRows.length; j++) {\n  //         if (j == 0 && this.config.skipFirstRow) {\n  //         } else {\n  //           value.push(this.dataRows[j][name])\n  //         }\n  //       }\n  //       this.data.push({\n  //         x: x,\n  //         y: value,\n  //         name: legendName,\n  //         type: 'bar',\n  //         textinfo: 'label+percent',\n  //         textposition: 'inside',\n  //         automargin: true,\n  //       })\n  //     }\n  //   }\n  // }\n\n  public async setFilter(filter: FilterDefinition) {\n    const { dataset, column, value, invert, range } = filter\n\n    if (!this.datasets[dataset]) {\n      console.warn(`${dataset} doesn't exist yet`)\n      console.warn(Object.keys(this.datasets))\n      return\n    }\n    console.log('> setFilter', dataset, column, value)\n\n    // Filter might be single or an array; make it an array.\n    const values = Array.isArray(value) ? value : [value]\n    if (this.datasets[dataset].activeFilters == null) {\n      this.datasets[dataset].activeFilters = {}\n    }\n    const allFilters = this.datasets[dataset].activeFilters\n    // a second click on a filter means REMOVE this filter.\n    // if (allFilters[column] !== undefined && allFilters[column] === values) {\n    //   console.log('A1', allFilters[column])\n    //   delete allFilters[column]\n    // } else\n    if (!values.length) {\n      delete allFilters[column]\n    } else {\n      allFilters[column] = { values, invert, range }\n    }\n    await this._updateFilters(dataset) // this is async\n  }\n\n  public addFilterListener(config: { dataset: string }, listener: any) {\n    const selectedDataset = this.datasets[config.dataset]\n    if (!selectedDataset) throw Error('No dataset named: ' + config.dataset)\n\n    // console.log(22, config.dataset, this.datasets[config.dataset])\n    this.datasets[config.dataset].filterListeners.add(listener)\n  }\n\n  public removeFilterListener(config: { dataset: string }, listener: any) {\n    try {\n      if (this.datasets[config.dataset].filterListeners) {\n        this.datasets[config.dataset].filterListeners.delete(listener)\n      }\n    } catch (e) {\n      // doesn't matter\n    }\n  }\n\n  public clearCache() {\n    this.kill() // any stragglers must die\n    this.datasets = {}\n    this.networks = {}\n  }\n\n  // ---- PRIVATE STUFFS -----------------------\n\n  private async _updateFilters(datasetId: string) {\n    console.log('> updateFilters ', datasetId)\n    const metaData = this.datasets[datasetId]\n    console.log({ metaData })\n\n    if (!Object.keys(metaData.activeFilters).length) {\n      console.log('no keys')\n      metaData.filteredRows = null\n      this._notifyListeners(datasetId)\n      return\n    }\n\n    // Let's do this the stupid way first, and make it better once we get it working.\n    const dataset = await metaData.dataset\n    const allColumns = Object.keys(dataset)\n    let filteredRows: any[] = []\n\n    const numberOfRowsInFullDataset = dataset[allColumns[0]].values.length\n    console.log('FILTERS:', metaData.activeFilters)\n    console.log('TOTLROWS', numberOfRowsInFullDataset)\n\n    // we will go thru each filter for this dataset and set the elements\n    // to false whenever a row fails a filter.\n    // This implements \"AND\" logic.\n    const hasMatchedFilters = new Array(numberOfRowsInFullDataset).fill(true)\n\n    const ltgt = /^(<|>)/ // starts with < or >\n    //            (╯° °)╯︵ ┻━┻\n\n    for (const [column, spec] of Object.entries(metaData.activeFilters)) {\n      const dataColumn = dataset[column]\n      if (spec.values[0] === undefined || spec.values[0] === '') {\n        throw Error(datasetId + ': filter error')\n      }\n\n      // prep LT/GT\n      if (ltgt.test(spec.values[0])) {\n        if (spec.values[0].startsWith('<=')) {\n          spec.conditional = '<='\n          spec.values[0] = spec.values[0].substring(2).trim()\n        } else if (spec.values[0].startsWith('>=')) {\n          spec.conditional = '>='\n          spec.values[0] = spec.values[0].substring(2).trim()\n        } else if (spec.values[0].startsWith('<')) {\n          spec.conditional = '<'\n          spec.values[0] = spec.values[0].substring(1).trim()\n        } else if (spec.values[0].startsWith('>')) {\n          spec.conditional = '>'\n          spec.values[0] = spec.values[0].substring(1).trim()\n        }\n      } else {\n        // handle case where we are testing equal/inequal and its a \"numeric\" string\n        if (spec.values.length === 1 && typeof spec.values[0] === 'string') {\n          const numericString = parseFloat(spec.values[0])\n          if (Number.isFinite(numericString)) spec.values.push(numericString)\n        }\n      }\n\n      // test every row: falsify if it fails the test.\n      for (let i = 0; i < numberOfRowsInFullDataset; i++) {\n        if (!checkFilterValue(spec, dataColumn.values[i])) {\n          hasMatchedFilters[i] = false\n        }\n      }\n    }\n\n    // Build the final filtered dataset based on hasMatchedFilters\n    for (let i = 0; i < numberOfRowsInFullDataset; i++) {\n      if (hasMatchedFilters[i]) {\n        const row = {} as any\n        allColumns.forEach(col => (row[col] = dataset[col].values[i]))\n        filteredRows.push(row)\n      }\n    }\n\n    // For now let's leave the filtered rows as an array of data objects\n\n    // // CONVERT array of objects to column-based DataTableColumns\n    // const filteredDataTable: { [id: string]: DataTableColumn } = {}\n    // allColumns.forEach(columnId => {\n    //   const column = { name: columnId, values: [], type: DataType.UNKNOWN } as any\n    //   for (const row of filteredRows) column.values.push(row[columnId])\n    //   filteredDataTable[columnId] = column\n    // })\n\n    // metaData.filteredRows = filteredDataTable as any\n\n    metaData.filteredRows = filteredRows\n    this._notifyListeners(datasetId)\n  }\n\n  // private _checkFilterValue(\n  //   spec: { conditional: string; invert: boolean; values: any[] },\n  //   elementValue: any\n  // ) {\n  //   // lookup closure functions for < > <= >=\n  //   const conditionals: any = {\n  //     '<': () => {\n  //       return elementValue < spec.values[0]\n  //     },\n  //     '<=': () => {\n  //       return elementValue <= spec.values[0]\n  //     },\n  //     '>': () => {\n  //       return elementValue > spec.values[0]\n  //     },\n  //     '>=': () => {\n  //       return elementValue >= spec.values[0]\n  //     },\n  //   }\n\n  //   let isValueInFilterSpec: boolean\n\n  //   if (spec.conditional) {\n  //     isValueInFilterSpec = conditionals[spec.conditional]()\n  //   } else {\n  //     isValueInFilterSpec = spec.values.includes(elementValue)\n  //   }\n\n  //   if (spec.invert) return !isValueInFilterSpec\n  //   return isValueInFilterSpec\n  // }\n\n  private _notifyListeners(datasetId: string) {\n    const dataset = this.datasets[datasetId]\n    for (const notifyListener of dataset.filterListeners) {\n      notifyListener(datasetId)\n    }\n  }\n\n  private async _fetchDataset(config: { dataset: string }, options?: { highPrecision: boolean }) {\n    if (!this.files.length) {\n      const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(this.subfolder)\n      this.files = files\n    }\n\n    return new Promise<DataTable>((resolve, reject) => {\n      const thread = new DataFetcherWorker()\n      this.threads.push(thread)\n      // console.log('NEW WORKER', thread)\n      try {\n        thread.postMessage({\n          fileSystemConfig: this.fileApi,\n          subfolder: this.subfolder,\n          files: this.files,\n          config: config,\n          options,\n        })\n\n        thread.onmessage = e => {\n          thread.terminate()\n          if (!e.data || e.data.error) {\n            let msg = '' + (e.data?.error || 'Error loading file')\n            msg = msg.replace('[object Response]', 'Error loading file')\n\n            if (config?.dataset && msg.indexOf(config.dataset) === -1) msg += `: ${config.dataset}`\n\n            reject(msg)\n          }\n          resolve(e.data)\n        }\n      } catch (err) {\n        thread.terminate()\n        console.error(err)\n        reject(err)\n      }\n    })\n  }\n\n  private async _getAvroNetwork(props: {\n    subfolder: string\n    filename: string\n    vizDetails: any\n    cbStatus?: any\n  }): Promise<NetworkLinks> {\n    const httpFileSystem = new HTTPFileSystem(this.fileApi)\n    const blob = await httpFileSystem.getFileBlob(`${props.subfolder}/${props.filename}`)\n\n    const records: any[] = await new Promise(async (resolve, reject) => {\n      const rows = [] as any[]\n\n      avro\n        .createBlobDecoder(blob)\n        .on('metadata', (schema: any) => {})\n        .on('data', (row: any) => {\n          rows.push(row)\n        })\n        .on('end', () => {\n          resolve(rows)\n        })\n    })\n\n    const network = records[0]\n\n    // Build bare network with no attributes, just like other networks\n    // TODO: at some point this should merge with Shapefile reader\n\n    const numLinks = network.linkId.length\n\n    const crs = network.crs || 'EPSG:4326'\n    const needsProjection = crs !== 'EPSG:4326' && crs !== 'WGS84'\n\n    const source: Float32Array = new Float32Array(2 * numLinks)\n    const dest: Float32Array = new Float32Array(2 * numLinks)\n    const linkIds: any = []\n\n    let coordFrom = [0, 0]\n    let coordTo = [0, 0]\n\n    for (let i = 0; i < numLinks; i++) {\n      const linkID = network.linkId[i]\n      const fromOffset = 2 * network.from[i]\n      const toOffset = 2 * network.to[i]\n\n      coordFrom[0] = network.nodeCoordinates[fromOffset]\n      coordFrom[1] = network.nodeCoordinates[1 + fromOffset]\n      coordTo[0] = network.nodeCoordinates[toOffset]\n      coordTo[1] = network.nodeCoordinates[1 + toOffset]\n\n      if (needsProjection) {\n        coordFrom = Coords.toLngLat(crs, coordFrom)\n        coordTo = Coords.toLngLat(crs, coordTo)\n      }\n\n      source[2 * i + 0] = coordFrom[0]\n      source[2 * i + 1] = coordFrom[1]\n      dest[2 * i + 0] = coordTo[0]\n      dest[2 * i + 1] = coordTo[1]\n\n      linkIds[i] = linkID\n    }\n\n    const links = { source, dest, linkIds, projection: 'EPSG:4326' }\n\n    return links\n  }\n\n  private async _fetchNetwork(props: {\n    subfolder: string\n    filename: string\n    vizDetails: any\n    cbStatus?: any\n    options: { crs?: string }\n  }) {\n    return new Promise<NetworkLinks>(async (resolve, reject) => {\n      const { subfolder, filename, vizDetails, cbStatus, options } = props\n\n      const path = `/${subfolder}/${filename}`\n      console.log('load network:', path)\n\n      // get folder\n      let folder =\n        path.indexOf('/') > -1 ? path.substring(0, path.lastIndexOf('/')) : this.subfolder\n\n      // get file path search pattern\n      try {\n        const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(folder)\n        let pattern = path.indexOf('/') === -1 ? path : path.substring(path.lastIndexOf('/') + 1)\n        const match = findMatchingGlobInFiles(files, pattern)\n        if (match.length !== 1) reject('File not found: ' + path)\n      } catch (e) {\n        // Could not get directory listing!\n        reject('Error reading folder: ' + folder)\n      }\n\n      // AVRO NETWORK: can't get crummy library to work in a web-worker\n      if (filename.toLocaleLowerCase().endsWith('.avro')) {\n        const result = await this._getAvroNetwork(props)\n        resolve(result)\n        return\n      }\n\n      const thread = new RoadNetworkLoader() as any\n      try {\n        thread.onmessage = (e: MessageEvent) => {\n          // perhaps network has no CRS and we need to ask user\n          if (e.data.promptUserForCRS) {\n            let crs =\n              prompt(\n                'Enter the projection coordinate reference system, e.g. \"EPSG:25832\", or cancel if unknown'\n              ) || 'Atlantis'\n            if (Number.isInteger(parseInt(crs))) crs = `EPSG:${crs}`\n\n            thread.postMessage({ crs })\n            return\n          }\n\n          // notify client of status update messages\n          if (e.data.status) {\n            if (cbStatus) cbStatus(e.data.status)\n            return\n          }\n\n          // normal exit\n          thread.terminate()\n\n          if (e.data.error) {\n            console.error(e.data.error)\n            reject(e.data.error)\n          }\n\n          resolve(e.data.links)\n        }\n\n        thread.postMessage({\n          filePath: path,\n          fileSystem: this.fileApi,\n          vizDetails,\n          options,\n          isFirefox, // we need this for now, because Firefox bug #260\n        })\n      } catch (err) {\n        thread.terminate()\n        console.error(err)\n        reject(err)\n      }\n    })\n  }\n\n  private _getFileSystem(name: string) {\n    const svnProject: FileSystemConfig[] = globalStore.state.svnProjects.filter(\n      (a: FileSystemConfig) => a.slug === name\n    )\n    if (svnProject.length === 0) {\n      // console.log(globalStore.state.svnProjects)\n      console.error(`DDM: no such project, is slug correct? (${name})`)\n      throw Error\n    }\n    return svnProject[0]\n  }\n\n  private datasets: {\n    [id: string]: {\n      dataset: Promise<DataTable>\n      filteredRows: any[] | null\n      activeFilters: { [column: string]: any }\n      filterListeners: Set<any>\n    }\n  } = {}\n}\n\nexport function checkFilterValue(\n  spec: { conditional: string; invert: boolean; values: any[]; range?: boolean },\n  elementValue: any\n) {\n  // lookup closure functions for < > <= >=\n  const conditionals: any = {\n    '<': () => {\n      return elementValue < spec.values[0]\n    },\n    '<=': () => {\n      return elementValue <= spec.values[0]\n    },\n    '>': () => {\n      return elementValue > spec.values[0]\n    },\n    '>=': () => {\n      return elementValue >= spec.values[0]\n    },\n  }\n\n  let isValueInFilterSpec: boolean\n\n  if (spec.range) {\n    isValueInFilterSpec = elementValue >= spec.values[0] && elementValue <= spec.values[1]\n  } else if (spec.conditional) {\n    isValueInFilterSpec = conditionals[spec.conditional]()\n  } else {\n    isValueInFilterSpec = spec.values.includes(elementValue)\n  }\n\n  if (spec.invert) return !isValueInFilterSpec\n  return isValueInFilterSpec\n}\n"],"names":["avro$1","isChrome","isFirefox","DashboardDataManager","args","__publicField","worker","config","rows","bars","columnValues","columnGroups","rollup","v","a","b","d","x","y","options","myDataset","promise","timeout","timeoutPromise","_","reject","_comments","allRows","comments","column","colName","values","e","fullpath","dataTable","key","fullConfig","resolve","id","features","featureProperties","f","feature","thread","DataFetcherWorker","err","props","filename","subfolder","vizDetails","cbStatus","path","filter","dataset","value","invert","range","allFilters","listener","datasetId","metaData","allColumns","filteredRows","numberOfRowsInFullDataset","hasMatchedFilters","ltgt","spec","dataColumn","numericString","i","checkFilterValue","row","col","notifyListener","files","HTTPFileSystem","msg","_a","blob","network","avro","schema","numLinks","crs","needsProjection","source","dest","linkIds","coordFrom","coordTo","linkID","fromOffset","toOffset","Coords","folder","pattern","findMatchingGlobInFiles","result","RoadNetworkLoader","name","svnProject","globalStore","elementValue","conditionals","isValueInFilterSpec"],"mappings":"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"}